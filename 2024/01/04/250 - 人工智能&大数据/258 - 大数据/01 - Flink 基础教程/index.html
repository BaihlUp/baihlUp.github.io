<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Flink 基础教程 | 梦之痕</title><meta name="author" content="梦之痕"><meta name="copyright" content="梦之痕"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="0 参考资料0.1 学习资料 2022 Flink 学习路线总结 学习经验  0.2 推荐书籍 《Flink大数据分析实战》 Flink入门与实战 Flink基础教程 Flink原理、实战与性能优化  1 初识 Flink1.1 大数据开发总体架构 总体架构图    数据来源层  在大数据领域，数据的来源往往是关系型数据库、日志文件（用户在Web网站和手机App中浏览相关内容时，服务器端会生成大量">
<meta property="og:type" content="article">
<meta property="og:title" content="Flink 基础教程">
<meta property="og:url" content="https://baihlup.github.io/2024/01/04/250%20-%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD&%E5%A4%A7%E6%95%B0%E6%8D%AE/258%20-%20%E5%A4%A7%E6%95%B0%E6%8D%AE/01%20-%20Flink%20%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/index.html">
<meta property="og:site_name" content="梦之痕">
<meta property="og:description" content="0 参考资料0.1 学习资料 2022 Flink 学习路线总结 学习经验  0.2 推荐书籍 《Flink大数据分析实战》 Flink入门与实战 Flink基础教程 Flink原理、实战与性能优化  1 初识 Flink1.1 大数据开发总体架构 总体架构图    数据来源层  在大数据领域，数据的来源往往是关系型数据库、日志文件（用户在Web网站和手机App中浏览相关内容时，服务器端会生成大量">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg">
<meta property="article:published_time" content="2024-01-04T00:00:00.000Z">
<meta property="article:modified_time" content="2024-10-26T14:27:27.269Z">
<meta property="article:author" content="梦之痕">
<meta property="article:tag" content="Flink">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://baihlup.github.io/2024/01/04/250%20-%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD&amp;%E5%A4%A7%E6%95%B0%E6%8D%AE/258%20-%20%E5%A4%A7%E6%95%B0%E6%8D%AE/01%20-%20Flink%20%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Flink 基础教程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-26 14:27:27'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="梦之痕"><span class="site-name">梦之痕</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Flink 基础教程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-01-04T00:00:00.000Z" title="Created 2024-01-04 00:00:00">2024-01-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-10-26T14:27:27.269Z" title="Updated 2024-10-26 14:27:27">2024-10-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-%E5%A4%A7%E6%95%B0%E6%8D%AE/">人工智能&amp;大数据</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Flink 基础教程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="0-参考资料"><a href="#0-参考资料" class="headerlink" title="0 参考资料"></a>0 参考资料</h1><h2 id="0-1-学习资料"><a href="#0-1-学习资料" class="headerlink" title="0.1 学习资料"></a>0.1 学习资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/tardis/zm/art/105620944?source_id=1003">2022 Flink 学习路线总结</a></li>
<li><a target="_blank" rel="noopener" href="https://www.baispace.cn/article/flink-source.html">学习经验</a></li>
</ol>
<h2 id="0-2-推荐书籍"><a href="#0-2-推荐书籍" class="headerlink" title="0.2 推荐书籍"></a>0.2 推荐书籍</h2><ul>
<li>《Flink大数据分析实战》</li>
<li>Flink入门与实战</li>
<li>Flink基础教程</li>
<li>Flink原理、实战与性能优化</li>
</ul>
<h1 id="1-初识-Flink"><a href="#1-初识-Flink" class="headerlink" title="1 初识 Flink"></a>1 初识 Flink</h1><h2 id="1-1-大数据开发总体架构"><a href="#1-1-大数据开发总体架构" class="headerlink" title="1.1 大数据开发总体架构"></a>1.1 大数据开发总体架构</h2><ul>
<li>总体架构图</li>
</ul>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240104163945.png"></p>
<ul>
<li>数据来源层</li>
</ul>
<p>在大数据领域，数据的来源往往是关系型数据库、日志文件（用户在Web网站和手机App中浏览相关内容时，服务器端会生成大量的日志文件）、其他非结构化数据等。要想对这些大量的数据进行离线或实时分析，需要使用数据传输工具将其导入Hadoop平台或其他大数据集群中。</p>
<ul>
<li><p>数据传输层<br>在大数据领域，数据的来源往往是关系型数据库、日志文件（用户在Web网站和手机App中浏览相关内容时，服务器端会生成大量的日志文件）、其他非结构化数据等。要想对这些大量的数据进行离线或实时分析，需要使用数据传输工具将其导入Hadoop平台或其他大数据集群中。</p>
</li>
<li><p>数据存储层<br>数据可以存储于分布式文件系统HDFS中，也可以存储于分布式数据库HBase中，而HBase的底层实际上还是将数据存储于HDFS中。此外，为了满足对大量数据的快速检索与统计，可以使用Elasticsearch作为全文检索引擎。</p>
</li>
<li><p>资源管理层<br>YARN是大数据开发中常用的资源管理器，它是一个通用资源（内存、CPU）管理系统，不仅可以集成于Hadoop中，也可以集成于Flink、Spark等其他大数据框架中。</p>
</li>
<li><p>数据计算层<br>MapReduce是Hadoop的核心组成部分，可以结合Hive通过SQL的方式进行数据的离线计算，当然也可以单独编写MapReduce应用程序进行计算。Storm用于进行数据的实时计算，可以非常容易地实时处理无限的流数据。Flink提供了离线计算库和实时计算库两种，离线计算库支持FlinkML（机器学习）、Gelly（图计算）、基于Table的关系操作，实时计算库支持CEP（复杂事件处理），同时也支持基于Table的关系操作。</p>
</li>
<li><p>任务调度层<br>Oozie是一个用于Hadoop平台的工作流调度引擎，可以使用工作流的方式对编写好的大数据任务进行调度。若任务不复杂，则可以使用Linux系统自带的Crontab定时任务进行调度。</p>
</li>
<li><p>业务模型层<br>对大量数据的处理结果最终需要通过可视化的方式进行展示。可以使用Java、PHP等处理业务逻辑，查询结果数据库，最终结合ECharts等前端可视化框架展示处理结果。</p>
</li>
<li><p>Flink 在大数据开发架构中的位置<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240104164306.png"></p>
</li>
</ul>
<h2 id="1-2-Flink-主要组件"><a href="#1-2-Flink-主要组件" class="headerlink" title="1.2 Flink 主要组件"></a>1.2 Flink 主要组件</h2><p>Flink是由多个组件构成的软件栈，整个软件栈可分为4层：</p>
<ol>
<li>存储层</li>
</ol>
<p>Flink本身并没有提供分布式文件系统，因此Flink的分析大多依赖于HDFS，也可以从HBase和Amazon S3（亚马逊云存储服务）等持久层读取数据。</p>
<ol start="2">
<li>调度层</li>
</ol>
<p>Flink自带一个简易的资源调度器，称为独立调度器(Standalone)。若集群中没有任何资源管理器，则可以使用自带的独立调度器。当然，Flink也支持在其他的集群管理器上运行，包括Hadoop YARN、Apache Mesos等。</p>
<ol start="3">
<li><p>计算层<br>Flink自带一个简易的资源调度器，称为独立调度器(Standalone)。若集群中没有任何资源管理器，则可以使用自带的独立调度器。当然，Flink也支持在其他的集群管理器上运行，包括Hadoop YARN、Apache Mesos等。</p>
</li>
<li><p>工具层<br>在Flink Runtime的基础上，Flink提供了面向流处理(DataStream API)和批处理(DataSet API)的不同计算接口，并在此接口上抽象出了不同的应用类型组件库，例如基于流处理的CEP（复杂事件处理库）、Table&amp;SQL（结构化表处理库）和基于批处理的Gelly（图计算库）、FlinkML（机器学习库）、Table&amp;SQL（结构化表处理库）。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240104164547.png"></p>
<h2 id="1-3-Flink-编程接口"><a href="#1-3-Flink-编程接口" class="headerlink" title="1.3 Flink 编程接口"></a>1.3 Flink 编程接口</h2><p>Flink提供了丰富的数据处理接口，并将接口抽象成4层，由下向上分别为Stateful Stream Processing API、DataStream&#x2F;DataSet API、Table API以及SQL API，开发者可以根据具体需求选择任意一层接口进行应用开发。</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240104165159.png"></p>
<h3 id="1-3-1-Stateful-Stream-Processing-API"><a href="#1-3-1-Stateful-Stream-Processing-API" class="headerlink" title="1.3.1 Stateful Stream Processing API"></a>1.3.1 Stateful Stream Processing API</h3><p>Flink中处理有状态流最底层的接口，它通过Process Function（低阶API，Flink提供的最具表达力的底层接口）嵌入DataStream API中，允许用户自由地处理一个或多个流中的事件，并使用一致的容错状态。此外，用户可以注册事件时间和处理时间回调，从而允许程序实现复杂的计算。用户可以通过这个API接口操作状态、时间等底层数据。</p>
<h3 id="1-3-2-DataStream-DataSet-API"><a href="#1-3-2-DataStream-DataSet-API" class="headerlink" title="1.3.2 DataStream&#x2F;DataSet API"></a>1.3.2 DataStream&#x2F;DataSet API</h3><p>大多数应用程序不需要上述低级抽象，而是针对核心API进行编程的，例如DataStream API和DataSet API。DataStream API用于处理无界数据集，即流处理；DataSet API用于处理有界数据集，即批处理。这两种API都提供了用于数据处理的通用操作，例如各种形式的转换、连接、聚合等。</p>
<p>低级Process Function与DataStream API集成在一起，从而使得仅对某些操作进行低级抽象成为可能。DataSet API在有限的数据集上提供了其他原语，例如循环／迭代。</p>
<h3 id="1-3-3-Table-API"><a href="#1-3-3-Table-API" class="headerlink" title="1.3.3 Table API"></a>1.3.3 Table API</h3><p>Table API作为批处理和流处理统一的关系型API，即查询在无界实时流或有界批数据集上以相同的语义执行，并产生相同的结果。Flink中的Table API通常用于简化数据分析、数据流水线和ETL应用程序的定义。</p>
<p>Table API构建在DataStream&#x2F;DataSet API之上，提供了大量编程接口，例如GroupByKey、Join等操作，是批处理和流处理统一的关系型API，使用起来更加简洁。使用Table API允许在表与DataStream&#x2F;DataSet数据集之间无缝切换，并且可以将Table API与DataStream&#x2F;DataSet API混合使用。</p>
<p>Table API的原理是将内存中的DataStream&#x2F;DataSet数据集在原有的基础上增加Schema信息，将数据类型统一抽象成表结构，然后通过Table API提供的接口处理对应的数据集，从而简化数据分析。</p>
<p>此外，Table API程序还会通过优化规则在数据处理过程中对处理逻辑进行大量优化。</p>
<h3 id="1-3-4-SQL-API"><a href="#1-3-4-SQL-API" class="headerlink" title="1.3.4 SQL API"></a>1.3.4 SQL API</h3><p>Flink提供的最高级别的抽象是SQL API。这种抽象在语义和表达方式上均类似于Table API，但是将程序表示为SQL查询表达式。SQL抽象与Table API紧密交互，并且可以对Table API中定义的表执行SQL查询。</p>
<h2 id="1-4-Flink-程序结构"><a href="#1-4-Flink-程序结构" class="headerlink" title="1.4 Flink 程序结构"></a>1.4 Flink 程序结构</h2><p>一个Flink应用程序由3部分构成，或者说将Flink的操作算子可以分成3部分，分别为Source、Transformation和Sink：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240104170129.png"></p>
<ul>
<li>Source：数据源部分。负责读取指定存储介质中的数据，转为分布式数据流或数据集，例如readTextFile()、socketTextStream()等算子。Flink在流处理和批处理上的Source主要有4种：基于本地集合、基于文件、基于网络套接字Socket和自定义Source。</li>
<li>Transformation：数据转换部分。负责对一个或多个数据流或数据集进行各种转换操作，并产生一个或多个输出数据流或数据集，例如map()、flatMap()、keyBy()等算子。</li>
<li>Sink：数据输出部分。负责将转换后的结果数据发送到HDFS、文本文件、MySQL、Elasticsearch等目的地，例如writeAsText()算子。图1-15描述了一个Flink应用程序的3部分。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240104170301.png"></p>
<h1 id="2-Flink-运行架构和原理"><a href="#2-Flink-运行架构和原理" class="headerlink" title="2 Flink 运行架构和原理"></a>2 Flink 运行架构和原理</h1><h2 id="2-1-Flink-运行时架构"><a href="#2-1-Flink-运行时架构" class="headerlink" title="2.1 Flink 运行时架构"></a>2.1 Flink 运行时架构</h2><h3 id="2-1-1-Flink-Standalone架构"><a href="#2-1-1-Flink-Standalone架构" class="headerlink" title="2.1.1 Flink Standalone架构"></a>2.1.1 Flink Standalone架构</h3><p>Flink Standalone模式为经典的主从(Master&#x2F;Slave)架构，资源调度是Flink自己实现的。集群启动后，主节点上会启动一个JobManager进程，主节点称为JobManager节点；各个从节点上会启动一个TaskManager进程，从节点称为TaskManager节点。从Flink 1.6版本开始，将主节点上的进程名称改为了StandaloneSessionClusterEntrypoint，从节点的进程名称改为了，在这里为了方便使用，仍然沿用之前版本的称呼，即JobManager和TaskManager。</p>
<p>Client接收到Flink应用程序后，将作业提交给JobManager。JobManager要做的第一件事就是分配Task（任务）所需的资源。完成资源分配后，Task将被JobManager提交给相应的TaskManager，TaskManager会启动线程开始执行。在执行过程中，TaskManager会持续向JobManager汇报状态信息，例如开始执行、进行中或完成等状态。作业执行完成后，结果将通过JobManager发送给Client。</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240104170507.png"></p>
<h4 id="2-1-1-1-Task"><a href="#2-1-1-1-Task" class="headerlink" title="2.1.1.1 Task"></a>2.1.1.1 Task</h4><p>Flink中的每一个操作算子称为一个Task（任务）。每个Task在一个JVM线程中执行。多个Task可以在同一个JVM进程中共享TCP连接（通过多路复用技术）和心跳信息。它们还可能共享数据集和数据结构，从而降低每个Task的开销。</p>
<h4 id="2-1-1-2-Task-Slot"><a href="#2-1-1-2-Task-Slot" class="headerlink" title="2.1.1.2 Task Slot"></a>2.1.1.2 Task Slot</h4><p>TaskManager为了控制执行的Task数量，将计算资源（内存）划分为多个Task Slot（任务槽），每个Task Slot代表TaskManager的一份固定内存资源，Task则在Task Slot中执行。</p>
<p>Task Slot是一个静态概念，TaskManager在启动的时候就设置好了Task Slot的数量。Task Slot的数量决定了TaskManager具有的并发执行能力。因此，建议将Task Slot的数量设置为节点CPU的核心数，以最大化利用资源，提高计算效率。Task Slot的数量设置可以修改Flink配置文件flink-conf.yaml中的taskmanager.numberOfTaskSlots属性值，默认为1。</p>
<h3 id="2-1-2-YARN-集群架构"><a href="#2-1-2-YARN-集群架构" class="headerlink" title="2.1.2 YARN 集群架构"></a>2.1.2 YARN 集群架构</h3><h2 id="2-2-Flink-任务调度原理"><a href="#2-2-Flink-任务调度原理" class="headerlink" title="2.2 Flink 任务调度原理"></a>2.2 Flink 任务调度原理</h2><h3 id="2-2-1-任务链"><a href="#2-2-1-任务链" class="headerlink" title="2.2.1 任务链"></a>2.2.1 任务链</h3><p>Flink中的每一个操作算子称为一个Task（任务），算子的每个具体实例则称为SubTask（子任务），SubTask是Flink中最小的处理单元，多个SubTask可能在不同的机器上执行。一个TaskManager进程包含一个或多个执行线程，用于执行SubTask。TaskManager中的一个Task Slot对应一个执行线程，一个执行线程可以执行一个或多个SubTask。<br>由于每个SubTask只能在一个线程中执行，为了能够减少线程间切换和缓冲的开销，在降低延迟的同时提高整体吞吐量，Flink可以将多个连续的SubTask链接成一个Task在一个线程中执行。这种将多个SubTask连在一起的方式称为任务链。如图：一个Source类算子的SubTask和一个map()算子的SubTask连在了一起，组成了任务链。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240104172145.png"></p>
<blockquote>
<p>任务链的好处是，同一任务链内的SubTask可以彼此直接传递数据，而无须通过序列化或Flink的网络栈。</p>
</blockquote>
<h3 id="2-2-2-并行度"><a href="#2-2-2-并行度" class="headerlink" title="2.2.2 并行度"></a>2.2.2 并行度</h3><p>为了充分利用计算资源，提高计算效率，可以增加算子的实例数（SubTask数量）。一个特定算子的SubTask数量称为该算子的并行度，且任意两个算子的并行度之间是独立的，不同算子可能拥有不同的并行度。例如，将Source算子、map()算子、keyby()&#x2F;window()&#x2F;apply()算子的并行度设置为2，Sink算子的并行度设置为1，运行效果如图：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240104172326.png"></p>
<p>由于一个Task Slot对应一个执行线程，因此并行度为2的算子的SubTask将被分配到不同的Task Slot中执行。<br>假设一个作业图(JobGraph)有A、B、C、D、E五个算子，其中A、B、D的并行度为4，C、E的并行度为2，该作业在TaskManager中的详细数据流程可能如图：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240104172406.png"></p>
<p>Flink中并行度的设置有4种级别：算子级别、执行环境(Execution Environment)级别、客户端（命令行）级别、系统级别。</p>
<ol>
<li><p>算子级别<br>每个算子、Source和Sink都可以通过调用setParallelism()方法指定其并行度。例如以下代码设置flatMap()算子的并行度为2：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.flatMap(_.split(<span class="string">&quot; &quot;</span>)).setParallelism(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行环境级别<br>调用执行环境对象的setParallelism()方法可以指定Flink应用程序中所有算子的默认并行度，代码如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> env=<span class="type">ExecutionEnvironment</span>.getExecutionEnvironment </span><br><span class="line">env.setParallelism(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端（命令行）级别<br>在向集群提交Flink应用程序时使用-p选项可以指定并行度。例如以下提交命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flink run -p 2 WordCount.jar</span><br></pre></td></tr></table></figure>
</li>
<li><p>系统级别<br>影响所有运行环境的系统级别的默认并行度可以在配置文件flink-conf.yaml中的parallelism.default属性中指定，默认为1。</p>
</li>
</ol>
<blockquote>
<p>4种并行度级别的作用顺序为：算子级别&gt;执行环境级别&gt;客户端级别&gt;系统级别。</p>
</blockquote>
<h3 id="2-2-3-共享Task-Slot"><a href="#2-2-3-共享Task-Slot" class="headerlink" title="2.2.3 共享Task Slot"></a>2.2.3 共享Task Slot</h3><p>默认情况下，Flink允许SubTask之间共享Task Slot，即使它们是不同Task（算子）的SubTask，只要它们来自同一个作业(Job)即可。在没有共享Task Slot的情况下，简单的SubTask（source()、map()等）将会占用和复杂的SubTask（keyBy()、window()等）一样多的资源，通过共享Task Slot可以充分利用Task Slot的资源，同时确保繁重的SubTask在TaskManager之间公平地获取资源。例如，将图2-7中的算子并行度从2增加到6，并行效果如图：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240104172833.png"></p>
<p>Flink集群的Task Slot数量最好与作业中使用的最高并行度一致，这样不需要计算作业总共包含多少个具有不同并行度的Task。</p>
<h3 id="2-2-4-数据流"><a href="#2-2-4-数据流" class="headerlink" title="2.2.4 数据流"></a>2.2.4 数据流</h3><p>一个Flink应用程序会被映射成逻辑数据流(Dataflow)，而Dataflow都是以一个或多个Source开始、以一个或多个Sink结束的，且始终包括Source、Transformation、Sink三部分。Dataflow描述了数据如何在不同算子之间流动，将这些算子用带方向的直线连接起来会形成一个关于计算路径的有向无环图，称为DAG（Directed Acyclic Graph，有向无环图）或Dataflow图。<br>假设一个Flink应用程序在读取数据后先对数据进行了map()操作，然后进行了keyBy()&#x2F;window()&#x2F;apply()操作，最后将计算结果输出到了指定的文件中，则该程序的Dataflow图如图：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240104173332.png"></p>
<p>假设该程序的Source、map()、keyBy()&#x2F;window()&#x2F;apply()算子的并行度为2，Sink算子的并行度为1，则该程序的逻辑数据流图、物理（并行）数据流图和Flink优化后的数据流图如图：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240104173358.png"></p>
<p>Flink应用程序在执行时，为了降低线程开销，会将多个SubTask连接在一起组成任务链，在一个线程中运行。对于上图的物理（并行）数据流来说，Flink执行时会对其进行优化，将Source[1]和map()[1]、Source[2]和map()[2]分别连接成一个任务，这是因为Source和map()之间采用了一对一的直连模式，而且没有任何的重分区（重分区往往发生在聚合阶段，类似于Spark的Shuffle），它们之间可以直接通过缓存进行数据传递，而不需要通过网络或序列化（如果不使用任务链，Source和map()可能在不同的机器上，它们之间的数据传递就需要通过网络）。这种优化在很大程度上提升了Flink的执行效率。</p>
<h3 id="2-2-5-执行图"><a href="#2-2-5-执行图" class="headerlink" title="2.2.5 执行图"></a>2.2.5 执行图</h3><p>Flink应用程序执行时会根据数据流生成多种图，每种图对应了作业的不同阶段，根据不同图的生成顺序，主要分为4层：StreamGraph→JobGraph→ExecutionGraph→物理执行图。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240104173706.png"></p>
<ul>
<li>StreamGraph：流图。使用DataStream API编写的应用程序生成的最初的图代表程序的拓扑结构，描述了程序的执行逻辑。StreamGraph在Flink客户端中生成，在客户端应用程序最后调用execute()方法时触发StreamGraph的构建。</li>
<li>JobGraph：作业图。所有高级别API都需要转换为JobGraph。StreamGraph经过优化（例如任务链）后生成了JobGraph，以提高执行效率。StreamGraph和JobGraph都是在本地客户端生成的数据结构，而JobGraph需要被提交给JobManager进行解析。</li>
<li>ExecutionGraph：执行图。JobManager对JobGraph进行解析后生成的并行化执行图是调度层最核心的数据结构。它包含对每个中间数据集或数据流、每个并行任务以及它们之间的通信的描述。</li>
<li>物理执行图：JobManager根据ExecutionGraph对作业进行调度后，在各个TaskManager上部署Task后形成的“图”。物理执行图并不是一个具体的数据结构，而是各个Task分布在不同的节点上所形成的物理上的关系表示。</li>
</ul>
<h1 id="3-Flink-DataStream-API"><a href="#3-Flink-DataStream-API" class="headerlink" title="3 Flink DataStream API"></a>3 Flink DataStream API</h1><p>DataStream API是Flink的核心层API。一个Flink程序，其实就是对DataStream的各种转换。具体来说，代码基本上都由以下几部分构成：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240104174200.png"></p>
<h2 id="3-1-执行模式"><a href="#3-1-执行模式" class="headerlink" title="3.1 执行模式"></a>3.1 执行模式</h2><p>DataStream API支持不同的运行时执行模式，可以根据用例的要求和作业的特征从中进行选择。DataStream API比较“经典”的执行行为称为“流”执行模式，主要用于需要连续增量处理并无限期保持在线的无限作业。</p>
<p>可以通过execution.runtime-mode属性来配置执行模式。其有3种可能的值：</p>
<ul>
<li>STREAMING：典型的DataStream执行模式（默认）。</li>
<li>BATCH：在DataStream API上以批处理方式执行。</li>
<li>AUTOMATIC：让系统根据数据源的有界性来决定。</li>
</ul>
<p><strong>Flink Task任务作业流程：</strong></p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240104174500.png"></p>
<h2 id="3-2-作业流程"><a href="#3-2-作业流程" class="headerlink" title="3.2 作业流程"></a>3.2 作业流程</h2><p>在一个作业提交前，JobManager和TaskManager等进程需要先被启动。可以在Flink安装目录中执行bin&#x2F;start-cluster.sh命令来启动这些进程。JobManager和TaskManager被启动后，TaskManager需要将自己注册给JobManager中的ResourceManager（资源注册）。这个初始化和资源注册过程发生在单个作业提交前。</p>
<p>Flink作业的具体执行流程如下：</p>
<ol>
<li>用户编写应用程序代码，并通过Flink客户端提交作业。程序一般为Java或Scala语言，调用Flink API构建逻辑数据流图，然后转为作业图JobGraph，并附加到StreamExecutionEnvironment中。代码和相关配置文件被编译打包，被提交到JobManager的Dispatcher，形成一个应用作业。</li>
<li>Dispatcher（JobManager的一个组件）接收到这个作业，启动JobManager，JobManager负责本次作业的各项协调工作。</li>
<li>接下来JobManager向ResourceManager申请本次作业所需的资源。</li>
<li>JobManager将用户作业中的作业图JobGraph转化为并行化的物理执行图，对作业并行处理并将其子任务分发部署到多个TaskManager上执行。每个作业的并行子任务将在Task Slot中执行。至此，一个Flink作业就开始执行了。</li>
<li>TaskManager在执行计算任务的过程中可能会与其他TaskManager交换数据，会使用相应的数据交换策略。同时，TaskManager也会将一些任务状态信息反馈给JobManager，这些信息包括任务启动、运行或终止的状态、快照的元数据等。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240104174753.png"></p>
<h2 id="3-3-Source-数据源"><a href="#3-3-Source-数据源" class="headerlink" title="3.3 Source 数据源"></a>3.3 Source 数据源</h2><p>DataStream API中直接提供了对一些基本数据源的支持，例如文件系统、Socket连接等，也提供了非常丰富的高级数据源连接器(Connector)，例如Kafka Connector、Elasticsearch Connector等。用户也可以实现自定义Connector数据源，以便使Flink能够与其他外部系统进行数据交互。</p>
<p><strong>数据源相关类的继承关系：</strong><br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240104175405.png"></p>
<p>从Flink1.12开始，主要使用流批统一的新Source架构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataStreamSource&lt;String&gt; stream = env.fromSource(…)</span><br></pre></td></tr></table></figure>

<p><strong>实现一个自定义数据源的示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.source;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkStrategy;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.Types;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.connector.source.util.ratelimit.RateLimiterStrategy;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.connector.datagen.source.DataGeneratorSource;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.connector.datagen.source.GeneratorFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataGeneratorDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">    </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 如果有n个并行度， 最大值设为a  </span></span><br><span class="line">        <span class="comment">// 将数值 均分成 n份，  a/n ,比如，最大100，并行度2，每个并行度生成50个  </span></span><br><span class="line">        <span class="comment">// 其中一个是 0-49，另一个50-99  </span></span><br><span class="line">        env.setParallelism(<span class="number">2</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/**  </span></span><br><span class="line"><span class="comment">         * 数据生成器Source，四个参数：  </span></span><br><span class="line"><span class="comment">         *     第一个： GeneratorFunction接口，需要实现， 重写map方法， 输入类型固定是Long  </span></span><br><span class="line"><span class="comment">         *     第二个： long类型， 自动生成的数字序列（从0自增）的最大值(小于)，达到这个值就停止了  </span></span><br><span class="line"><span class="comment">         *     第三个： 限速策略， 比如 每秒生成几条数据  </span></span><br><span class="line"><span class="comment">         *     第四个： 返回的类型  </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        DataGeneratorSource&lt;String&gt; dataGeneratorSource = <span class="keyword">new</span> <span class="title class_">DataGeneratorSource</span>&lt;&gt;(  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">GeneratorFunction</span>&lt;Long, String&gt;() &#123;  </span><br><span class="line">                    <span class="meta">@Override</span>  </span><br><span class="line">                    <span class="keyword">public</span> String <span class="title function_">map</span><span class="params">(Long value)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;Number:&quot;</span> + value;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;,  </span><br><span class="line">                <span class="number">100</span>,  </span><br><span class="line">                RateLimiterStrategy.perSecond(<span class="number">1</span>),  </span><br><span class="line">                Types.STRING  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        env  </span><br><span class="line">                .fromSource(dataGeneratorSource, WatermarkStrategy.noWatermarks(), <span class="string">&quot;data-generator&quot;</span>)  </span><br><span class="line">                .print();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上程序每秒自动产生随机数，直到达到100为止。</p>
<h2 id="3-4-Transformation-数据转换"><a href="#3-4-Transformation-数据转换" class="headerlink" title="3.4 Transformation 数据转换"></a>3.4 Transformation 数据转换</h2><p>在Flink中，Transformation（转换）算子就是将一个或多个DataStream转换为新的DataStream，可以将多个转换组合成复杂的数据流(Dataflow)拓扑。<br>Transformation应用于一个或多个数据流或数据集，并产生一个或多个输出数据流或数据集。Transformation可能会在每个记录的基础上更改数据流或数据集，但也可以只更改其分区或执行聚合。</p>
<h3 id="3-4-1-基本转换算子"><a href="#3-4-1-基本转换算子" class="headerlink" title="3.4.1 基本转换算子"></a>3.4.1 基本转换算子</h3><h4 id="3-4-1-1-map-func"><a href="#3-4-1-1-map-func" class="headerlink" title="3.4.1.1 map(func)"></a>3.4.1.1 map(func)</h4><p>map()算子接收一个函数作为参数，并把这个函数应用于DataStream的每个元素，最后将函数的返回结果作为结果DataStream中对应元素的值，即将DataStream的每个元素转换成新的元素。</p>
<p><strong>map()算子运行过程：</strong></p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240104175633.png"></p>
<p>只需要基于DataStream调用map()方法就可以进行转换处理。方法需要传入的参数是接口MapFunction的实现；返回值类型还是DataStream，不过泛型（流中的元素类型）可能改变。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.transfrom;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.bean.WaterSensor;  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.functions.MapFunctionImpl;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.MapFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">        DataStreamSource&lt;WaterSensor&gt; sensorDS = env.fromElements(  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s1&quot;</span>, <span class="number">1L</span>, <span class="number">1</span>),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s2&quot;</span>, <span class="number">2L</span>, <span class="number">2</span>),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s3&quot;</span>, <span class="number">3L</span>, <span class="number">3</span>)  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// TODO map算子： 一进一出  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// TODO 方式一： 匿名实现类  </span></span><br><span class="line"><span class="comment">//        SingleOutputStreamOperator&lt;String&gt; map = sensorDS.map(new MapFunction&lt;WaterSensor, String&gt;() &#123;  </span></span><br><span class="line"><span class="comment">//            @Override  </span></span><br><span class="line"><span class="comment">//            public String map(WaterSensor value) throws Exception &#123;  </span></span><br><span class="line"><span class="comment">//                return value.getId();  </span></span><br><span class="line"><span class="comment">//            &#125;  </span></span><br><span class="line"><span class="comment">//        &#125;);  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// TODO 方式二： lambda表达式  </span></span><br><span class="line"><span class="comment">//        SingleOutputStreamOperator&lt;String&gt; map = sensorDS.map(sensor -&gt; sensor.getId());  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// TODO 方式三： 定义一个类来实现MapFunction  </span></span><br><span class="line"><span class="comment">//        SingleOutputStreamOperator&lt;String&gt; map = sensorDS.map(new MyMapFunction());  </span></span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; map = sensorDS.map(<span class="keyword">new</span> <span class="title class_">MapFunctionImpl</span>());  </span><br><span class="line">        map.print();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyMapFunction</span> <span class="keyword">implements</span> <span class="title class_">MapFunction</span>&lt;WaterSensor,String&gt;&#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">map</span><span class="params">(WaterSensor value)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">            <span class="keyword">return</span> value.getId();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1</span><br><span class="line">s2</span><br><span class="line">s3</span><br></pre></td></tr></table></figure>
<p>MapFunction实现类的泛型类型，与输入数据类型和输出数据的类型有关。在实现MapFunction接口的时候，需要指定两个泛型，分别是输入事件和输出事件的类型，还需要重写一个map()方法，定义从一个输入事件转换为另一个输出事件的具体逻辑。</p>
<h4 id="3-4-1-2-flatMap-func"><a href="#3-4-1-2-flatMap-func" class="headerlink" title="3.4.1.2 flatMap(func)"></a>3.4.1.2 flatMap(func)</h4><p>flatMap操作又称为扁平映射，主要是将数据流中的整体（一般是集合类型）拆分成一个一个的个体使用。消费一个元素，可以产生0到多个元素。flatMap可以认为是“扁平化”（flatten）和“映射”（map）两步操作的结合，也就是先按照某种规则对数据进行打散拆分，再对拆分后的元素做转换处理。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240106205452.png"></p>
<p>同map一样，flatMap也可以使用Lambda表达式或者FlatMapFunction接口实现类的方式来进行传参，返回值类型取决于所传参数的具体逻辑，可以与原数据流相同，也可以不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.transfrom;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.bean.WaterSensor;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.FilterFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.FlatMapFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * TODO 如果输入的数据是sensor_1，只打印vc；如果输入的数据是sensor_2，既打印ts又打印vc  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cjp  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0  </span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlatmapDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">        DataStreamSource&lt;WaterSensor&gt; sensorDS = env.fromElements(  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s1&quot;</span>, <span class="number">1L</span>, <span class="number">1</span>),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s1&quot;</span>, <span class="number">11L</span>, <span class="number">11</span>),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s2&quot;</span>, <span class="number">2L</span>, <span class="number">2</span>),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s3&quot;</span>, <span class="number">3L</span>, <span class="number">3</span>)  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/**  </span></span><br><span class="line"><span class="comment">         * TODO flatmap： 一进多出（包含0出）  </span></span><br><span class="line"><span class="comment">         *      对于s1的数据，一进一出  </span></span><br><span class="line"><span class="comment">         *      对于s2的数据，一进2出  </span></span><br><span class="line"><span class="comment">         *      对于s3的数据，一进0出（类似于过滤的效果）  </span></span><br><span class="line"><span class="comment">         *  </span></span><br><span class="line"><span class="comment">         *    map怎么控制一进一出：  </span></span><br><span class="line"><span class="comment">         *      =》 使用 return  </span></span><br><span class="line"><span class="comment">         *         *    flatmap怎么控制的一进多出  </span></span><br><span class="line"><span class="comment">         *      =》 通过 Collector来输出， 调用几次就输出几条  </span></span><br><span class="line"><span class="comment">         *  </span></span><br><span class="line"><span class="comment">         *         */</span>        SingleOutputStreamOperator&lt;String&gt; flatmap = sensorDS.flatMap(<span class="keyword">new</span> <span class="title class_">FlatMapFunction</span>&lt;WaterSensor, String&gt;() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatMap</span><span class="params">(WaterSensor value, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;s1&quot;</span>.equals(value.getId())) &#123;  </span><br><span class="line">                    <span class="comment">// 如果是 s1，输出 vc                    out.collect(value.getVc().toString());  </span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;s2&quot;</span>.equals(value.getId())) &#123;  </span><br><span class="line">                    <span class="comment">// 如果是 s2，分别输出ts和vc  </span></span><br><span class="line">                    out.collect(value.getTs().toString());  </span><br><span class="line">                    out.collect(value.getVc().toString());  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        flatmap.print();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果输入的数据是sensor_1，只打印vc；如果输入的数据是sensor_2，既打印ts又打印vc。</p>
<h4 id="3-4-1-3-filter"><a href="#3-4-1-3-filter" class="headerlink" title="3.4.1.3 filter"></a>3.4.1.3 filter</h4><p>进行filter转换之后的新数据流的数据类型与原数据流是相同的。filter转换需要传入的参数需要实现FilterFunction接口，而FilterFunction内要实现filter()方法，就相当于一个返回布尔类型的条件表达式。</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240106205231.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.transfrom;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.bean.WaterSensor;  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.functions.FilterFunctionImpl;  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.functions.MapFunctionImpl;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.FilterFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.MapFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * TODO  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cjp  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0  </span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">        DataStreamSource&lt;WaterSensor&gt; sensorDS = env.fromElements(  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s1&quot;</span>, <span class="number">1L</span>, <span class="number">1</span>),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s1&quot;</span>, <span class="number">11L</span>, <span class="number">11</span>),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s2&quot;</span>, <span class="number">2L</span>, <span class="number">2</span>),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s3&quot;</span>, <span class="number">3L</span>, <span class="number">3</span>)  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// TODO filter： true保留，false过滤掉  </span></span><br><span class="line"><span class="comment">//        SingleOutputStreamOperator&lt;WaterSensor&gt; filter = sensorDS.filter(new FilterFunction&lt;WaterSensor&gt;() &#123;  </span></span><br><span class="line"><span class="comment">//            @Override  </span></span><br><span class="line"><span class="comment">//            public boolean filter(WaterSensor value) throws Exception &#123;  </span></span><br><span class="line"><span class="comment">//                return &quot;s1&quot;.equals(value.getId());  </span></span><br><span class="line"><span class="comment">//            &#125;  </span></span><br><span class="line"><span class="comment">//        &#125;);  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//        SingleOutputStreamOperator&lt;WaterSensor&gt; filter = sensorDS.filter(new FilterFunctionImpl(&quot;s1&quot;));  </span></span><br><span class="line">        SingleOutputStreamOperator&lt;WaterSensor&gt; filter = sensorDS.filter(waterSensor -&gt; <span class="string">&quot;s1&quot;</span>.equals(waterSensor.id));  </span><br><span class="line">  </span><br><span class="line">        filter.print();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-2-聚合算子"><a href="#3-4-2-聚合算子" class="headerlink" title="3.4.2 聚合算子"></a>3.4.2 聚合算子</h3><h4 id="3-4-2-1-简单聚合（sum-min-max-minBy-maxBy）"><a href="#3-4-2-1-简单聚合（sum-min-max-minBy-maxBy）" class="headerlink" title="3.4.2.1 简单聚合（sum&#x2F;min&#x2F;max&#x2F;minBy&#x2F;maxBy）"></a>3.4.2.1 简单聚合（sum&#x2F;min&#x2F;max&#x2F;minBy&#x2F;maxBy）</h4><p>使用聚合算子前都需要使用keyBy算子，把数据从DataStream转换为KeyedStream。KeyedStream可以认为是“分区流”或者“键控流”，它是对DataStream按照key的一个逻辑分区，所以泛型有两个类型：除去当前流中的元素类型外，还需要指定key的类型。</p>
<ul>
<li>sum()：在输入流上，对指定的字段做叠加求和的操作。</li>
<li>min()：在输入流上，对指定的字段求最小值。</li>
<li>max()：在输入流上，对指定的字段求最大值。</li>
<li>minBy()：与min()类似，在输入流上针对指定字段求最小值。不同的是，min()只计算指定字段的最小值，其他字段会保留最初第一个数据的值；而minBy()则会返回包含字段最小值的整条数据。</li>
<li>maxBy()：与max()类似，在输入流上针对指定字段求最大值。两者区别与min()&#x2F;minBy()完全一致。</li>
</ul>
<p>简单聚合算子返回的，同样是一个SingleOutputStreamOperator，也就是从KeyedStream又转换成了常规的DataStream。所以可以这样理解：keyBy和聚合是成对出现的，先分区、后聚合，得到的依然是一个DataStream。而且经过简单聚合之后的数据流，元素的数据类型保持不变。</p>
<h4 id="3-4-2-2-reduce"><a href="#3-4-2-2-reduce" class="headerlink" title="3.4.2.2 reduce"></a>3.4.2.2 reduce</h4><p>reduce可以对已有的数据进行归约处理，把每一个新输入的数据和当前已经归约出来的值，再做一个聚合计算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.aggreagte;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.bean.WaterSensor;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.ReduceFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.functions.KeySelector;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.KeyedStream;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReduceDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        DataStreamSource&lt;WaterSensor&gt; sensorDS = env.fromElements(  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s1&quot;</span>, <span class="number">1L</span>, <span class="number">1</span>),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s1&quot;</span>, <span class="number">11L</span>, <span class="number">11</span>),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s1&quot;</span>, <span class="number">21L</span>, <span class="number">21</span>),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s2&quot;</span>, <span class="number">2L</span>, <span class="number">2</span>),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s3&quot;</span>, <span class="number">3L</span>, <span class="number">3</span>)  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        KeyedStream&lt;WaterSensor, String&gt; sensorKS = sensorDS  </span><br><span class="line">                .keyBy(<span class="keyword">new</span> <span class="title class_">KeySelector</span>&lt;WaterSensor, String&gt;() &#123;  </span><br><span class="line">                    <span class="meta">@Override</span>  </span><br><span class="line">                    <span class="keyword">public</span> String <span class="title function_">getKey</span><span class="params">(WaterSensor value)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                        <span class="keyword">return</span> value.getId();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/**  </span></span><br><span class="line"><span class="comment">         * TODO reduce:  </span></span><br><span class="line"><span class="comment">         * 1、keyby之后调用  </span></span><br><span class="line"><span class="comment">         * 2、输入类型 = 输出类型，类型不能变  </span></span><br><span class="line"><span class="comment">         * 3、每个key的第一条数据来的时候，不会执行reduce方法，存起来，直接输出  </span></span><br><span class="line"><span class="comment">         * 4、reduce方法中的两个参数  </span></span><br><span class="line"><span class="comment">         *     value1： 之前的计算结果，存状态  </span></span><br><span class="line"><span class="comment">         *     value2： 现在来的数据  </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        SingleOutputStreamOperator&lt;WaterSensor&gt; reduce = sensorKS.reduce(<span class="keyword">new</span> <span class="title class_">ReduceFunction</span>&lt;WaterSensor&gt;() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> WaterSensor <span class="title function_">reduce</span><span class="params">(WaterSensor value1, WaterSensor value2)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;value1=&quot;</span> + value1);  </span><br><span class="line">                System.out.println(<span class="string">&quot;value2=&quot;</span> + value2);  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(value1.id, value2.ts, value1.vc + value2.vc);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        reduce.print();  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WaterSensor&#123;<span class="built_in">id</span>=<span class="string">&#x27;s1&#x27;</span>, ts=1, vc=1&#125;</span><br><span class="line">value1=WaterSensor&#123;<span class="built_in">id</span>=<span class="string">&#x27;s1&#x27;</span>, ts=1, vc=1&#125;</span><br><span class="line">value2=WaterSensor&#123;<span class="built_in">id</span>=<span class="string">&#x27;s1&#x27;</span>, ts=11, vc=11&#125;</span><br><span class="line">WaterSensor&#123;<span class="built_in">id</span>=<span class="string">&#x27;s1&#x27;</span>, ts=11, vc=12&#125;</span><br><span class="line">value1=WaterSensor&#123;<span class="built_in">id</span>=<span class="string">&#x27;s1&#x27;</span>, ts=11, vc=12&#125;</span><br><span class="line">value2=WaterSensor&#123;<span class="built_in">id</span>=<span class="string">&#x27;s1&#x27;</span>, ts=21, vc=21&#125;</span><br><span class="line">WaterSensor&#123;<span class="built_in">id</span>=<span class="string">&#x27;s1&#x27;</span>, ts=21, vc=33&#125;</span><br><span class="line">WaterSensor&#123;<span class="built_in">id</span>=<span class="string">&#x27;s2&#x27;</span>, ts=2, vc=2&#125;</span><br><span class="line">WaterSensor&#123;<span class="built_in">id</span>=<span class="string">&#x27;s3&#x27;</span>, ts=3, vc=3&#125;</span><br></pre></td></tr></table></figure>

<p>在输入第一条数据时不会触发reduce，后边每次数据到来会触发数据聚合，value1是当前聚合结果，value2是这次新的数据。</p>
<h3 id="3-4-3-用户自定义函数"><a href="#3-4-3-用户自定义函数" class="headerlink" title="3.4.3 用户自定义函数"></a>3.4.3 用户自定义函数</h3><h4 id="3-4-3-1-函数类"><a href="#3-4-3-1-函数类" class="headerlink" title="3.4.3.1 函数类"></a>3.4.3.1 函数类</h4><p>Flink暴露了所有UDF函数的接口，具体实现方式为接口或者抽象类，例如MapFunction、FilterFunction、ReduceFunction等。所以用户可以自定义一个函数类，实现对应的接口。<br>上边的示例，都是实现了对应UDF函数的类，可以是匿名类，Lambda，继承了接口或抽象类的自定义类。</p>
<h4 id="3-4-3-2-富函数类"><a href="#3-4-3-2-富函数类" class="headerlink" title="3.4.3.2 富函数类"></a>3.4.3.2 富函数类</h4><p>“富函数类”也是DataStream API提供的一个函数类的接口，所有的Flink函数类都有其Rich版本。富函数类一般是以抽象类的形式出现的。例如：RichMapFunction、RichFilterFunction、RichReduceFunction等。</p>
<p>与常规函数类的不同主要在于，富函数类可以获取运行环境的上下文，并拥有一些生命周期方法，所以可以实现更复杂的功能。</p>
<p>Rich Function有生命周期的概念。典型的生命周期方法有：</p>
<ul>
<li>open()方法，是Rich Function的初始化方法，也就是会开启一个算子的生命周期。当一个算子的实际工作方法例如map()或者filter()方法被调用之前，open()会首先被调用。</li>
<li>close()方法，是生命周期中的最后一个调用的方法，类似于结束方法。一般用来做一些清理工作。</li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.transfrom;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.bean.WaterSensor;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.RichMapFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.RuntimeContext;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.Configuration;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RichFunctionDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">2</span>);  </span><br><span class="line">  </span><br><span class="line">        DataStreamSource&lt;WaterSensor&gt; sensorDS = env.fromElements(  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s1&quot;</span>, <span class="number">1L</span>, <span class="number">1</span>),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s2&quot;</span>, <span class="number">2L</span>, <span class="number">2</span>),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s3&quot;</span>, <span class="number">3L</span>, <span class="number">3</span>)  </span><br><span class="line">        );  </span><br><span class="line">          </span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; map = sensorDS.map(<span class="keyword">new</span> <span class="title class_">RichMapFunction</span>&lt;WaterSensor, String&gt;() &#123;  </span><br><span class="line">  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                <span class="built_in">super</span>.open(parameters);  </span><br><span class="line">                System.out.println(  </span><br><span class="line">                        <span class="string">&quot;子任务编号=&quot;</span> + getRuntimeContext().getIndexOfThisSubtask()  </span><br><span class="line">                                + <span class="string">&quot;，子任务名称=&quot;</span> + getRuntimeContext().getTaskNameWithSubtasks()  </span><br><span class="line">                                + <span class="string">&quot;,调用open()&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                <span class="built_in">super</span>.close();  </span><br><span class="line">                System.out.println(  </span><br><span class="line">                        <span class="string">&quot;子任务编号=&quot;</span> + getRuntimeContext().getIndexOfThisSubtask()  </span><br><span class="line">                                + <span class="string">&quot;，子任务名称=&quot;</span> + getRuntimeContext().getTaskNameWithSubtasks()  </span><br><span class="line">                                + <span class="string">&quot;,调用close()&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">map</span><span class="params">(WaterSensor value)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                <span class="keyword">return</span> value.getId();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/**  </span></span><br><span class="line"><span class="comment">         * TODO RichXXXFunction: 富函数  </span></span><br><span class="line"><span class="comment">         * 1、多了生命周期管理方法：  </span></span><br><span class="line"><span class="comment">         *    open(): 每个子任务，在启动时，调用一次  </span></span><br><span class="line"><span class="comment">         *    close():每个子任务，在结束时，调用一次  </span></span><br><span class="line"><span class="comment">         *      =&gt; 如果是flink程序异常挂掉，不会调用close  </span></span><br><span class="line"><span class="comment">         *      =&gt; 如果是正常调用 cancel命令，可以close  </span></span><br><span class="line"><span class="comment">         * 2、多了一个 运行时上下文  </span></span><br><span class="line"><span class="comment">         *    可以获取一些运行时的环境信息，比如 子任务编号、名称、其他的.....  </span></span><br><span class="line"><span class="comment">         */</span><span class="comment">//        DataStreamSource&lt;Integer&gt; source = env.fromElements(1, 2, 3, 4); </span></span><br><span class="line">    </span><br><span class="line">        map.print();  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">子任务编号=0，子任务名称=Map -&gt; Sink: Print to Std. Out (1/2)<span class="comment">#0,调用open()</span></span><br><span class="line">子任务编号=1，子任务名称=Map -&gt; Sink: Print to Std. Out (2/2)<span class="comment">#0,调用open()</span></span><br><span class="line">1&gt; s1</span><br><span class="line">2&gt; s2</span><br><span class="line">1&gt; s3</span><br><span class="line">子任务编号=0，子任务名称=Map -&gt; Sink: Print to Std. Out (1/2)<span class="comment">#0,调用close()</span></span><br><span class="line">子任务编号=1，子任务名称=Map -&gt; Sink: Print to Std. Out (2/2)<span class="comment">#0,调用close()</span></span><br></pre></td></tr></table></figure>
<p>以上设置并行度为2，每个子任务启动时会调用open()，退出时调用close()。</p>
<h3 id="3-4-4-物理分区算子"><a href="#3-4-4-物理分区算子" class="headerlink" title="3.4.4 物理分区算子"></a>3.4.4 物理分区算子</h3><h4 id="3-4-4-1-随机分区"><a href="#3-4-4-1-随机分区" class="headerlink" title="3.4.4.1 随机分区"></a>3.4.4.1 随机分区</h4><p>随机分区服从均匀分布（uniform distribution），所以可以把流中的数据随机打乱，均匀地传递到下游任务分区。因为是完全随机的，所以对于同样的输入数据, 每次执行得到的结果也不会相同。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240108135209.png"></p>
<p>经过随机分区之后，得到的依然是一个DataStream。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sensorDS.shuffle().print();</span><br></pre></td></tr></table></figure>

<h4 id="3-4-4-2-轮询分区"><a href="#3-4-4-2-轮询分区" class="headerlink" title="3.4.4.2 轮询分区"></a>3.4.4.2 轮询分区</h4><p>轮询，按照先后顺序将数据做依次分发。</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240108135714.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.rebalance()</span><br></pre></td></tr></table></figure>

<h4 id="3-4-4-3-重缩放分区"><a href="#3-4-4-3-重缩放分区" class="headerlink" title="3.4.4.3 重缩放分区"></a>3.4.4.3 重缩放分区</h4><p>重缩放分区和轮询分区非常相似。当调用rescale()方法时，其实底层也是使用Round-Robin算法进行轮询，但是只会将数据轮询发送到下游并行任务的一部分中。rescale的做法是分成小团体，发牌人只给自己团体内的所有人轮流发牌。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240108140109.png"></p>
<p>重缩放分区与轮询分区相比，因为轮询的范围更小，性能更好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.rescale()</span><br></pre></td></tr></table></figure>
<h4 id="3-4-4-4-广播-全局分区"><a href="#3-4-4-4-广播-全局分区" class="headerlink" title="3.4.4.4 广播&#x2F;全局分区"></a>3.4.4.4 广播&#x2F;全局分区</h4><ul>
<li>广播分区</li>
</ul>
<p>数据会在不同的分区都保留一份，可能进行重复处理。可以通过调用DataStream的broadcast()方法，将输入数据复制并发送到下游算子的所有并行任务中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.broadcast()</span><br></pre></td></tr></table></figure>

<ul>
<li>全局分区</li>
</ul>
<p>会将所有的输入流数据都发送到下游算子的第一个并行子任务中去。这就相当于强行让下游任务并行度变成了1，所以使用这个操作需要非常谨慎，可能对程序造成很大的压力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.global()</span><br></pre></td></tr></table></figure>

<h4 id="3-4-4-5-自定义分区"><a href="#3-4-4-5-自定义分区" class="headerlink" title="3.4.4.5 自定义分区"></a>3.4.4.5 自定义分区</h4><p>如果所有分区策略无法满足需求，可以通过使用partitionCustom()方法来自定义分区策略。</p>
<ul>
<li>自定义分区 MyPartitioner</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.partition;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.Partitioner;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPartitioner</span> <span class="keyword">implements</span> <span class="title class_">Partitioner</span>&lt;String&gt; &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(String key, <span class="type">int</span> numPartitions)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(key) % numPartitions;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承Partitioner 后需要实现 partition方法，第一个参数为 从流数据中提取的计算分区的key，第二个参数为 并行度。</p>
<ul>
<li>使用自定义分区</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.partition;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.functions.KeySelector;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.Configuration;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PartitionCustomDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">2</span>);  </span><br><span class="line">  </span><br><span class="line">        DataStreamSource&lt;String&gt; elementsDs = env.fromElements(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        elementsDs  </span><br><span class="line">                .partitionCustom(<span class="keyword">new</span> <span class="title class_">MyPartitioner</span>(), r-&gt;r)  </span><br><span class="line">                .print();  </span><br><span class="line">  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上设置并行度为2，会把数据按奇偶分到两个分区中。</p>
<h4 id="3-4-4-6-总结"><a href="#3-4-4-6-总结" class="headerlink" title="3.4.4.6 总结"></a>3.4.4.6 总结</h4><p>Flink提供了 7种分区器+ 1种自定义：</p>
<ol>
<li>shuffle：随机分区</li>
<li>rebalance：轮询</li>
<li>recale：重缩放分区</li>
<li>broadcast：广播</li>
<li>global：全局</li>
<li>keyBy：one-by-one</li>
<li>partitionCustom：自定义分区</li>
</ol>
<h3 id="3-4-5-侧输出流"><a href="#3-4-5-侧输出流" class="headerlink" title="3.4.5 侧输出流"></a>3.4.5 侧输出流</h3><p>在处理流数据时，可以使用侧输出流把部分数据输出到其他流中，达到分流的效果。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240108144051.png"></p>
<p>示例：实现将WaterSensor按照Id类型进行分流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.split;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.bean.WaterSensor;  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.functions.WaterSensorMapFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.FilterFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.Types;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.Configuration;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SideOutputDataStream;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.ProcessFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.OutputTag;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SideOutputDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line"><span class="comment">//        StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(new Configuration());  </span></span><br><span class="line">  </span><br><span class="line">        env.setParallelism(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//        SingleOutputStreamOperator&lt;WaterSensor&gt; sensorDS = env  </span></span><br><span class="line"><span class="comment">//                .socketTextStream(&quot;10.211.55.4&quot;, 7777)  </span></span><br><span class="line"><span class="comment">//                .map(new WaterSensorMapFunction());  </span></span><br><span class="line">  </span><br><span class="line">        DataStreamSource&lt;WaterSensor&gt; sensorDS = env.fromElements(  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s1&quot;</span>, <span class="number">1L</span>, <span class="number">1</span>),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s1&quot;</span>, <span class="number">11L</span>, <span class="number">11</span>),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s2&quot;</span>, <span class="number">2L</span>, <span class="number">2</span>),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(<span class="string">&quot;s3&quot;</span>, <span class="number">3L</span>, <span class="number">3</span>)  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/**  </span></span><br><span class="line"><span class="comment">         * TODO 使用侧输出流 实现分流  </span></span><br><span class="line"><span class="comment">         * 需求： watersensor的数据，s1、s2的数据分别分开  </span></span><br><span class="line"><span class="comment">         *  </span></span><br><span class="line"><span class="comment">         * TODO 总结步骤：  </span></span><br><span class="line"><span class="comment">         *    1、使用 process算子  </span></span><br><span class="line"><span class="comment">         *    2、定义 OutputTag对象  </span></span><br><span class="line"><span class="comment">         *    3、调用 ctx.output  </span></span><br><span class="line"><span class="comment">         *    4、通过主流 获取 测流  </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/**         * 创建OutputTag对象  </span></span><br><span class="line"><span class="comment">         * 第一个参数： 标签名  </span></span><br><span class="line"><span class="comment">         * 第二个参数： 放入侧输出流中的 数据的 类型，Typeinformation  </span></span><br><span class="line"><span class="comment">         */</span>        OutputTag&lt;WaterSensor&gt; s1Tag = <span class="keyword">new</span> <span class="title class_">OutputTag</span>&lt;&gt;(<span class="string">&quot;s1&quot;</span>, Types.POJO(WaterSensor.class));  </span><br><span class="line">        OutputTag&lt;WaterSensor&gt; s2Tag = <span class="keyword">new</span> <span class="title class_">OutputTag</span>&lt;&gt;(<span class="string">&quot;s2&quot;</span>, Types.POJO(WaterSensor.class));  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;WaterSensor&gt; process = sensorDS  </span><br><span class="line">                .process(  </span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ProcessFunction</span>&lt;WaterSensor, WaterSensor&gt;() &#123;  </span><br><span class="line">                            <span class="meta">@Override</span>  </span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElement</span><span class="params">(WaterSensor value, Context ctx, Collector&lt;WaterSensor&gt; out)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                                <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> value.getId();  </span><br><span class="line">                                <span class="keyword">if</span> (<span class="string">&quot;s1&quot;</span>.equals(id)) &#123;  </span><br><span class="line">                                    <span class="comment">// 如果是 s1，放到侧输出流s1中  </span></span><br><span class="line">                                    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">                                     * 上下文ctx 调用ouput，将数据放入侧输出流  </span></span><br><span class="line"><span class="comment">                                     * 第一个参数： Tag对象  </span></span><br><span class="line"><span class="comment">                                     * 第二个参数： 放入侧输出流中的 数据  </span></span><br><span class="line"><span class="comment">                                     */</span>  </span><br><span class="line">                                    ctx.output(s1Tag, value);  </span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;s2&quot;</span>.equals(id)) &#123;  </span><br><span class="line">                                    <span class="comment">// 如果是 s2，放到侧输出流s2中  </span></span><br><span class="line">  </span><br><span class="line">                                    ctx.output(s2Tag, value);  </span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                                    <span class="comment">// 非s1、s2的数据，放到主流中  </span></span><br><span class="line">                                    out.collect(value);  </span><br><span class="line">                                &#125;  </span><br><span class="line">  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                );  </span><br><span class="line">        <span class="comment">// 从主流中，根据标签 获取 侧输出流  </span></span><br><span class="line">        SideOutputDataStream&lt;WaterSensor&gt; s1 = process.getSideOutput(s1Tag);  </span><br><span class="line">        SideOutputDataStream&lt;WaterSensor&gt; s2 = process.getSideOutput(s2Tag);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 打印主流  </span></span><br><span class="line">        process.print(<span class="string">&quot;主流-非s1、s2&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//打印 侧输出流  </span></span><br><span class="line"><span class="comment">//        s1.printToErr(&quot;s1&quot;);  </span></span><br><span class="line">        s1.filter(<span class="keyword">new</span> <span class="title class_">FilterFunction</span>&lt;WaterSensor&gt;() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(WaterSensor waterSensor)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                <span class="keyword">return</span> waterSensor.getTs() == <span class="number">11</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;).print(<span class="string">&quot;s1&quot;</span>);  </span><br><span class="line">        s2.printToErr(<span class="string">&quot;s2&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1&gt; WaterSensor&#123;<span class="built_in">id</span>=<span class="string">&#x27;s1&#x27;</span>, ts=11, vc=11&#125;</span><br><span class="line">主流-非s1、s2&gt; WaterSensor&#123;<span class="built_in">id</span>=<span class="string">&#x27;s3&#x27;</span>, ts=3, vc=3&#125;</span><br><span class="line">s2&gt; WaterSensor&#123;<span class="built_in">id</span>=<span class="string">&#x27;s2&#x27;</span>, ts=2, vc=2&#125;</span><br></pre></td></tr></table></figure>

<p>按照s1，s2，s3 类型进行分流，分成三条流，对s1流再进行 filter 操作。</p>
<h3 id="3-4-6-合流"><a href="#3-4-6-合流" class="headerlink" title="3.4.6 合流"></a>3.4.6 合流</h3><h4 id="3-4-6-1-联合"><a href="#3-4-6-1-联合" class="headerlink" title="3.4.6.1 联合"></a>3.4.6.1 联合</h4><p>最简单的合流操作，就是直接将多条流合在一起，叫作流的“联合”（union）。联合操作要求必须流中的数据类型必须相同，合并之后的新流会包括所有流中的元素，数据类型不变。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240108145943.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream1.union(stream2, stream3, ...)</span><br></pre></td></tr></table></figure>

<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.combine;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">        DataStreamSource&lt;Integer&gt; source1 = env.fromElements(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);  </span><br><span class="line">        DataStreamSource&lt;Integer&gt; source2 = env.fromElements(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>);  </span><br><span class="line">        DataStreamSource&lt;String&gt; source3 = env.fromElements(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/**  </span></span><br><span class="line"><span class="comment">         * TODO union：合并数据流  </span></span><br><span class="line"><span class="comment">         * 1、 流的数据类型必须一致  </span></span><br><span class="line"><span class="comment">         * 2、 一次可以合并多条流  </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line"><span class="comment">//        DataStream&lt;Integer&gt; union = source1.union(source2).union(source3.map(r -&gt; Integer.valueOf(r)));  </span></span><br><span class="line">        DataStream&lt;Integer&gt; union = source1.union(source2, source3.map(r -&gt; Integer.valueOf(r)));  </span><br><span class="line">        union.print();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有数据合并到一起输出。</p>
<h4 id="3-4-6-2-连接"><a href="#3-4-6-2-连接" class="headerlink" title="3.4.6.2 连接"></a>3.4.6.2 连接</h4><p>流的联合虽然简单，不过受限于数据类型不能改变，灵活性大打折扣，所以实际应用较少出现。</p>
<p>连接操作允许流的数据类型不同，但我们知道一个DataStream中的数据只能有唯一的类型，所以连接得到的并不是DataStream，而是“连接流”（ConnectedStreams），在连接以后，实际上内部仍保持各自的数据形式不变，彼此之间相互独立。要得到新的DataStream，需要进一步定义一个“同处理”（co-process）转换操作，用来说明对于不同来源、不同类型的数据，怎样分别进行处理转换、得到统一的输出类型。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240108150840.png"></p>
<ul>
<li>CoMapFunction</li>
</ul>
<p><strong>代码实现：</strong> 需要分为两步：</p>
<ol>
<li>基于一条DataStream调用 <code>.connect()</code> 方法，传入另一条DataStream作为参数，将两条流连接起来，得到一个ConnectedStreams</li>
<li>再调用同处理方法得到DataStream。这里可以的调用的同处理方法有.map()&#x2F;.flatMap()，以及.process()方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.combine;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.ConnectedStreams;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.co.CoMapFunction;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">        DataStreamSource&lt;Integer&gt; source1 = env.fromElements(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);  </span><br><span class="line">        DataStreamSource&lt;String&gt; source2 = env.fromElements(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/*** TODO 使用 connect 合流  </span></span><br><span class="line"><span class="comment">         * 1、一次只能连接 2条流  </span></span><br><span class="line"><span class="comment">         * 2、流的数据类型可以不一样  </span></span><br><span class="line"><span class="comment">         * 3、 连接后可以调用 map、flatmap、process来处理，但是各处理各的  </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        ConnectedStreams&lt;Integer, String&gt; connect = source1.connect(source2);  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; result = connect.map(<span class="keyword">new</span> <span class="title class_">CoMapFunction</span>&lt;Integer, String, String&gt;() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">map1</span><span class="params">(Integer value)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;来源于数字流:&quot;</span> + value.toString();  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">map2</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;来源于字母流:&quot;</span> + value;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        result.print();  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">来源于数字流:1</span><br><span class="line">来源于字母流:a</span><br><span class="line">来源于数字流:2</span><br><span class="line">来源于字母流:b</span><br><span class="line">来源于数字流:3</span><br><span class="line">来源于字母流:c</span><br></pre></td></tr></table></figure>

<p>ConnectedStreams有两个类型参数，分别表示内部包含的两条流各自的数据类型；<br>由于是两条不同类型的流，调用 <code>.map()</code>方法时传入的不再是一个简单的MapFunction，而是一个CoMapFunction，表示分别对两条流中的数据执行map操作。这个接口有三个类型参数，依次表示第一条流、第二条流，以及合并后的流中的数据类型。需要实现的方法：<code>.map1()</code>就是第一条流中数据的 <code>map</code> 操作，<code>.map2()</code> 则是针对第二条流的操作。</p>
<ul>
<li>CoProcessFunction</li>
</ul>
<p>调用.process()时，传入的则是一个CoProcessFunction。它也是“处理函数”家族中的一员，用法非常相似。它需要实现的就是processElement1()、processElement2()两个方法，在每个数据到来时，会根据来源的流调用其中的一个方法进行处理。<br>ConnectedStreams也可以直接调用.keyBy()进行按键分区的操作，得到的还是一个ConnectedStreams：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connectedStreams.keyBy(keySelector1, keySelector2);</span><br></pre></td></tr></table></figure>
<p>两个参数keySelector1和keySelector2，是两条流中各自的键选择器；当然也可以直接传入键的位置值（keyPosition），或者键的字段名（field），这与普通的keyBy用法完全一致。ConnectedStreams进行keyBy操作，其实就是把两条流中key相同的数据放到了一起，然后针对来源的流再做各自处理，这在一些场景下非常有用。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.combine;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple3;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.ConnectedStreams;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.co.CoProcessFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;  </span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;  </span><br><span class="line"><span class="keyword">import</span> java.util.List;  </span><br><span class="line"><span class="keyword">import</span> java.util.Map;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectKeybyDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">2</span>);  </span><br><span class="line">  </span><br><span class="line">        DataStreamSource&lt;Tuple2&lt;Integer, String&gt;&gt; source1 = env.fromElements(  </span><br><span class="line">                Tuple2.of(<span class="number">1</span>, <span class="string">&quot;a1&quot;</span>),  </span><br><span class="line">                Tuple2.of(<span class="number">1</span>, <span class="string">&quot;a2&quot;</span>),  </span><br><span class="line">                Tuple2.of(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>),  </span><br><span class="line">                Tuple2.of(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>)  </span><br><span class="line">        );  </span><br><span class="line">        DataStreamSource&lt;Tuple3&lt;Integer, String, Integer&gt;&gt; source2 = env.fromElements(  </span><br><span class="line">                Tuple3.of(<span class="number">1</span>, <span class="string">&quot;aa1&quot;</span>, <span class="number">1</span>),  </span><br><span class="line">                Tuple3.of(<span class="number">1</span>, <span class="string">&quot;aa2&quot;</span>, <span class="number">2</span>),  </span><br><span class="line">                Tuple3.of(<span class="number">2</span>, <span class="string">&quot;bb&quot;</span>, <span class="number">1</span>),  </span><br><span class="line">                Tuple3.of(<span class="number">3</span>, <span class="string">&quot;cc&quot;</span>, <span class="number">1</span>)  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        ConnectedStreams&lt;Tuple2&lt;Integer, String&gt;, Tuple3&lt;Integer, String, Integer&gt;&gt; connect = source1.connect(source2);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 多并行度下，需要根据 关联条件进行 keyby，才能保证 key相同的数据到一起去，才能匹配上  </span></span><br><span class="line">        ConnectedStreams&lt;Tuple2&lt;Integer, String&gt;, Tuple3&lt;Integer, String, Integer&gt;&gt; connectKeyby = connect.keyBy(s1 -&gt; s1.f0, s2 -&gt; s2.f0);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/**  </span></span><br><span class="line"><span class="comment">         * 实现互相匹配的效果：  两条流，，不一定谁的数据先来  </span></span><br><span class="line"><span class="comment">         *  1、每条流，有数据来，存到一个变量中  </span></span><br><span class="line"><span class="comment">         *      hashmap  </span></span><br><span class="line"><span class="comment">         *      =》key=id，第一个字段值  </span></span><br><span class="line"><span class="comment">         *      =》value=List&lt;数据&gt;  </span></span><br><span class="line"><span class="comment">         *  2、每条流有数据来的时候，除了存变量中， 不知道对方是否有匹配的数据，要去另一条流存的变量中 查找是否有匹配上的  </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; process = connectKeyby.process(  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">CoProcessFunction</span>&lt;Tuple2&lt;Integer, String&gt;, Tuple3&lt;Integer, String, Integer&gt;, String&gt;() &#123;  </span><br><span class="line">                    <span class="comment">// 每条流定义一个hashmap，用来存数据  </span></span><br><span class="line">                    Map&lt;Integer, List&lt;Tuple2&lt;Integer, String&gt;&gt;&gt; s1Cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">                    Map&lt;Integer, List&lt;Tuple3&lt;Integer, String, Integer&gt;&gt;&gt; s2Cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">                    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">                     * 第一条流的处理逻辑  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> value 第一条流的数据  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> ctx   上下文  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> out   采集器  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Exception  </span></span><br><span class="line"><span class="comment">                     */</span>  </span><br><span class="line">                    <span class="meta">@Override</span>  </span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElement1</span><span class="params">(Tuple2&lt;Integer, String&gt; value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                        <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> value.f0;  </span><br><span class="line">                        <span class="comment">// TODO 1. s1的数据来了，就存到变量中  </span></span><br><span class="line">                        <span class="keyword">if</span> (!s1Cache.containsKey(id)) &#123;  </span><br><span class="line">                            <span class="comment">// 1.1 如果key不存在，说明是该key的第一条数据，初始化，put进map中  </span></span><br><span class="line">                            List&lt;Tuple2&lt;Integer, String&gt;&gt; s1Values = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">                            s1Values.add(value);  </span><br><span class="line">                            s1Cache.put(id, s1Values);  </span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                            <span class="comment">// 1.2 key存在，不是该key的第一条数据，直接添加到 value的list中  </span></span><br><span class="line">                            s1Cache.get(id).add(value);  </span><br><span class="line">                        &#125;  </span><br><span class="line">  </span><br><span class="line">                        <span class="comment">// TODO 2.去 s2Cache中查找是否有id能匹配上的,匹配上就输出，没有就不输出  </span></span><br><span class="line">                        <span class="keyword">if</span> (s2Cache.containsKey(id)) &#123;  </span><br><span class="line">                            <span class="keyword">for</span> (Tuple3&lt;Integer, String, Integer&gt; s2Element : s2Cache.get(id)) &#123;  </span><br><span class="line">                                out.collect(<span class="string">&quot;s1:&quot;</span> + value + <span class="string">&quot;&lt;========&gt;&quot;</span> + <span class="string">&quot;s2:&quot;</span> + s2Element);  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">  </span><br><span class="line">                    &#125;  </span><br><span class="line">  </span><br><span class="line">                    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">                     * 第二条流的处理逻辑  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> value 第二条流的数据  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> ctx   上下文  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> out   采集器  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Exception  </span></span><br><span class="line"><span class="comment">                     */</span>  </span><br><span class="line">                    <span class="meta">@Override</span>  </span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElement2</span><span class="params">(Tuple3&lt;Integer, String, Integer&gt; value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                        <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> value.f0;  </span><br><span class="line">                        <span class="comment">// TODO 1. s2的数据来了，就存到变量中  </span></span><br><span class="line">                        <span class="keyword">if</span> (!s2Cache.containsKey(id)) &#123;  </span><br><span class="line">                            <span class="comment">// 1.1 如果key不存在，说明是该key的第一条数据，初始化，put进map中  </span></span><br><span class="line">                            List&lt;Tuple3&lt;Integer, String, Integer&gt;&gt; s2Values = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">                            s2Values.add(value);  </span><br><span class="line">                            s2Cache.put(id, s2Values);  </span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                            <span class="comment">// 1.2 key存在，不是该key的第一条数据，直接添加到 value的list中  </span></span><br><span class="line">                            s2Cache.get(id).add(value);  </span><br><span class="line">                        &#125;  </span><br><span class="line">  </span><br><span class="line">                        <span class="comment">// TODO 2.去 s1Cache中查找是否有id能匹配上的,匹配上就输出，没有就不输出  </span></span><br><span class="line">                        <span class="keyword">if</span> (s1Cache.containsKey(id)) &#123;  </span><br><span class="line">                            <span class="keyword">for</span> (Tuple2&lt;Integer, String&gt; s1Element : s1Cache.get(id)) &#123;  </span><br><span class="line">                                out.collect(<span class="string">&quot;s1:&quot;</span> + s1Element + <span class="string">&quot;&lt;========&gt;&quot;</span> + <span class="string">&quot;s2:&quot;</span> + value);  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        process.print();  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-Sink-数据输出"><a href="#3-5-Sink-数据输出" class="headerlink" title="3.5 Sink 数据输出"></a>3.5 Sink 数据输出</h2><p>Flink作为数据处理框架，最终还是要把计算处理的结果写入外部存储，为外部应用提供支持。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240108152743.png"></p>
<h3 id="3-5-1-连接到外部系统"><a href="#3-5-1-连接到外部系统" class="headerlink" title="3.5.1 连接到外部系统"></a>3.5.1 连接到外部系统</h3><p>Flink1.12开始，重构了Sink架构，使用如下方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.sinkTo(…)</span><br></pre></td></tr></table></figure>

<p>官方提供了众多 Sink 连接器，如下：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240108153223.png"></p>
<p>Flink官方之外，Apache Bahir框架，也实现了一些其他第三方系统与Flink的连接器。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240108153257.png"></p>
<h3 id="3-5-2-输出到文件"><a href="#3-5-2-输出到文件" class="headerlink" title="3.5.2 输出到文件"></a>3.5.2 输出到文件</h3><p>FileSink支持行编码（Row-encoded）和批量编码（Bulk-encoded）格式。这两种不同的方式都有各自的构建器（builder），可以直接调用FileSink的静态方法：</p>
<ul>
<li>行编码： FileSink.forRowFormat（basePath，rowEncoder）。</li>
<li>批量编码： FileSink.forBulkFormat（basePath，bulkWriterFactory）。</li>
</ul>
<p><strong>导入依赖：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-files<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.sink;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkStrategy;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.SimpleStringEncoder;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.Types;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.connector.source.util.ratelimit.RateLimiterStrategy;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.MemorySize;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.connector.datagen.source.DataGeneratorSource;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.connector.datagen.source.GeneratorFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.connector.file.sink.FileSink;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.core.fs.Path;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.CheckpointingMode;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.sink.filesystem.OutputFileConfig;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.sink.filesystem.bucketassigners.DateTimeBucketAssigner;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.sink.filesystem.rollingpolicies.DefaultRollingPolicy;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.time.Duration;  </span><br><span class="line"><span class="keyword">import</span> java.time.ZoneId;  </span><br><span class="line"><span class="keyword">import</span> java.util.TimeZone;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinkFile</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// TODO 每个目录中，都有 并行度个数的 文件在写入  </span></span><br><span class="line">        env.setParallelism(<span class="number">2</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 必须开启checkpoint，否则一直都是 .inprogress        env.enableCheckpointing(2000, CheckpointingMode.EXACTLY_ONCE);  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        DataGeneratorSource&lt;String&gt; dataGeneratorSource = <span class="keyword">new</span> <span class="title class_">DataGeneratorSource</span>&lt;&gt;(  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">GeneratorFunction</span>&lt;Long, String&gt;() &#123;  </span><br><span class="line">                    <span class="meta">@Override</span>  </span><br><span class="line">                    <span class="keyword">public</span> String <span class="title function_">map</span><span class="params">(Long value)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;Number:&quot;</span> + value;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;,  </span><br><span class="line">                Long.MAX_VALUE,  </span><br><span class="line">                RateLimiterStrategy.perSecond(<span class="number">1000</span>),  </span><br><span class="line">                Types.STRING  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        DataStreamSource&lt;String&gt; dataGen = env.fromSource(dataGeneratorSource, WatermarkStrategy.noWatermarks(), <span class="string">&quot;data-generator&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// TODO 输出到文件系统  </span></span><br><span class="line">        FileSink&lt;String&gt; fieSink = FileSink  </span><br><span class="line">                <span class="comment">// 输出行式存储的文件，指定路径、指定编码  </span></span><br><span class="line">                .&lt;String&gt;forRowFormat(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;./output/&quot;</span>), <span class="keyword">new</span> <span class="title class_">SimpleStringEncoder</span>&lt;&gt;(<span class="string">&quot;UTF-8&quot;</span>))  </span><br><span class="line">                <span class="comment">// 输出文件的一些配置： 文件名的前缀、后缀  </span></span><br><span class="line">                .withOutputFileConfig(  </span><br><span class="line">                        OutputFileConfig.builder()  </span><br><span class="line">                                .withPartPrefix(<span class="string">&quot;atguigu-&quot;</span>)  </span><br><span class="line">                                .withPartSuffix(<span class="string">&quot;.log&quot;</span>)  </span><br><span class="line">                                .build()  </span><br><span class="line">                )  </span><br><span class="line">                <span class="comment">// 按照目录分桶：如下，就是每个小时一个目录  </span></span><br><span class="line">                .withBucketAssigner(<span class="keyword">new</span> <span class="title class_">DateTimeBucketAssigner</span>&lt;&gt;(<span class="string">&quot;yyyy-MM-dd HH&quot;</span>, ZoneId.systemDefault()))  </span><br><span class="line">                <span class="comment">// 文件滚动策略:  1分钟 或 1m                .withRollingPolicy(  </span></span><br><span class="line">                        DefaultRollingPolicy.builder()  </span><br><span class="line">                                .withRolloverInterval(Duration.ofMinutes(<span class="number">1</span>))  </span><br><span class="line">                                .withMaxPartSize(<span class="keyword">new</span> <span class="title class_">MemorySize</span>(<span class="number">1024</span>*<span class="number">1024</span>))  </span><br><span class="line">                                .build()  </span><br><span class="line">                )  </span><br><span class="line">                .build();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        dataGen.sinkTo(fieSink);  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-3-输出到Kafka"><a href="#3-5-3-输出到Kafka" class="headerlink" title="3.5.3 输出到Kafka"></a>3.5.3 输出到Kafka</h3><p><strong>导入依赖：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.sink;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.SimpleStringSchema;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.connector.base.DeliveryGuarantee;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.connector.kafka.sink.KafkaRecordSerializationSchema;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.connector.kafka.sink.KafkaSink;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.CheckpointingMode;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerConfig;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinkKafka</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 如果是精准一次，必须开启checkpoint（后续章节介绍）  </span></span><br><span class="line">        env.enableCheckpointing(<span class="number">2000</span>, CheckpointingMode.EXACTLY_ONCE);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; sensorDS = env  </span><br><span class="line">                .socketTextStream(<span class="string">&quot;hadoop102&quot;</span>, <span class="number">7777</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/**  </span></span><br><span class="line"><span class="comment">         * Kafka Sink:         * TODO 注意：如果要使用 精准一次 写入Kafka，需要满足以下条件，缺一不可  </span></span><br><span class="line"><span class="comment">         * 1、开启checkpoint（后续介绍）  </span></span><br><span class="line"><span class="comment">         * 2、设置事务前缀  </span></span><br><span class="line"><span class="comment">         * 3、设置事务超时时间：   checkpoint间隔 &lt;  事务超时时间  &lt; max的15分钟  </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        KafkaSink&lt;String&gt; kafkaSink = KafkaSink.&lt;String&gt;builder()  </span><br><span class="line">                <span class="comment">// 指定 kafka 的地址和端口  </span></span><br><span class="line">                .setBootstrapServers(<span class="string">&quot;hadoop102:9092,hadoop103:9092,hadoop104:9092&quot;</span>)  </span><br><span class="line">                <span class="comment">// 指定序列化器：指定Topic名称、具体的序列化  </span></span><br><span class="line">                .setRecordSerializer(  </span><br><span class="line">                        KafkaRecordSerializationSchema.&lt;String&gt;builder()  </span><br><span class="line">                                .setTopic(<span class="string">&quot;ws&quot;</span>)  </span><br><span class="line">                                .setValueSerializationSchema(<span class="keyword">new</span> <span class="title class_">SimpleStringSchema</span>())  </span><br><span class="line">                                .build()  </span><br><span class="line">                )  </span><br><span class="line">                <span class="comment">// 写到kafka的一致性级别： 精准一次、至少一次  </span></span><br><span class="line">                .setDeliveryGuarantee(DeliveryGuarantee.EXACTLY_ONCE)  </span><br><span class="line">                <span class="comment">// 如果是精准一次，必须设置 事务的前缀  </span></span><br><span class="line">                .setTransactionalIdPrefix(<span class="string">&quot;atguigu-&quot;</span>)  </span><br><span class="line">                <span class="comment">// 如果是精准一次，必须设置 事务超时时间: 大于checkpoint间隔，小于 max 15分钟  </span></span><br><span class="line">                .setProperty(ProducerConfig.TRANSACTION_TIMEOUT_CONFIG, <span class="number">10</span>*<span class="number">60</span>*<span class="number">1000</span>+<span class="string">&quot;&quot;</span>)  </span><br><span class="line">                .build();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        sensorDS.sinkTo(kafkaSink);  </span><br><span class="line">	    env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-4-输出到-MySQL（JDBC）"><a href="#3-5-4-输出到-MySQL（JDBC）" class="headerlink" title="3.5.4 输出到 MySQL（JDBC）"></a>3.5.4 输出到 MySQL（JDBC）</h3><p><strong>导入依赖：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--目前中央仓库还没有 jdbc的连接器，暂时用一个快照版本--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.17-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.sink;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.bean.WaterSensor;  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.functions.WaterSensorMapFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.restartstrategy.RestartStrategies;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.connector.jdbc.JdbcConnectionOptions;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.connector.jdbc.JdbcExecutionOptions;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.connector.jdbc.JdbcSink;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.connector.jdbc.JdbcStatementBuilder;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.CheckpointingMode;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.sink.SinkFunction;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;  </span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinkMySQL</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;WaterSensor&gt; sensorDS = env  </span><br><span class="line">                .socketTextStream(<span class="string">&quot;hadoop102&quot;</span>, <span class="number">7777</span>)  </span><br><span class="line">                .map(<span class="keyword">new</span> <span class="title class_">WaterSensorMapFunction</span>());  </span><br><span class="line"></span><br><span class="line">        <span class="comment">/**  </span></span><br><span class="line"><span class="comment">         * TODO 写入mysql  </span></span><br><span class="line"><span class="comment">         * 1、只能用老的sink写法： addsink  </span></span><br><span class="line"><span class="comment">         * 2、JDBCSink的4个参数:  </span></span><br><span class="line"><span class="comment">         *    第一个参数： 执行的sql，一般就是 insert into  </span></span><br><span class="line"><span class="comment">         *    第二个参数： 预编译sql， 对占位符填充值  </span></span><br><span class="line"><span class="comment">         *    第三个参数： 执行选项 ---》 攒批、重试  </span></span><br><span class="line"><span class="comment">         *    第四个参数： 连接选项 ---》 url、用户名、密码  </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        SinkFunction&lt;WaterSensor&gt; jdbcSink = JdbcSink.sink(  </span><br><span class="line">                <span class="string">&quot;insert into ws values(?,?,?)&quot;</span>,  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">JdbcStatementBuilder</span>&lt;WaterSensor&gt;() &#123;  </span><br><span class="line">                    <span class="meta">@Override</span>  </span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(PreparedStatement preparedStatement, WaterSensor waterSensor)</span> <span class="keyword">throws</span> SQLException &#123;  </span><br><span class="line">                        <span class="comment">//每收到一条WaterSensor，如何去填充占位符  </span></span><br><span class="line">                        preparedStatement.setString(<span class="number">1</span>, waterSensor.getId());  </span><br><span class="line">                        preparedStatement.setLong(<span class="number">2</span>, waterSensor.getTs());  </span><br><span class="line">                        preparedStatement.setInt(<span class="number">3</span>, waterSensor.getVc());  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;,  </span><br><span class="line">                JdbcExecutionOptions.builder()  </span><br><span class="line">                        .withMaxRetries(<span class="number">3</span>) <span class="comment">// 重试次数  </span></span><br><span class="line">                        .withBatchSize(<span class="number">100</span>) <span class="comment">// 批次的大小：条数  </span></span><br><span class="line">                        .withBatchIntervalMs(<span class="number">3000</span>) <span class="comment">// 批次的时间  </span></span><br><span class="line">                        .build(),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">JdbcConnectionOptions</span>.JdbcConnectionOptionsBuilder()  </span><br><span class="line">                        .withUrl(<span class="string">&quot;jdbc:mysql://hadoop102:3306/test?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=UTF-8&quot;</span>)  </span><br><span class="line">                        .withUsername(<span class="string">&quot;root&quot;</span>)  </span><br><span class="line">                        .withPassword(<span class="string">&quot;000000&quot;</span>)  </span><br><span class="line">                        .withConnectionCheckTimeoutSeconds(<span class="number">60</span>) <span class="comment">// 重试的超时时间  </span></span><br><span class="line">                        .build()  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        sensorDS.addSink(jdbcSink);   </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-5-自定义-Sink-输出"><a href="#3-5-5-自定义-Sink-输出" class="headerlink" title="3.5.5 自定义 Sink 输出"></a>3.5.5 自定义 Sink 输出</h3><p> 如果我们想将数据存储到我们自己的存储设备中，而Flink并没有提供可以直接使用的连接器，就只能自定义Sink进行输出了。与Source类似，Flink为我们提供了通用的SinkFunction接口和对应的RichSinkDunction抽象类，只要实现它，通过简单地调用DataStream的.addSink()方法就可以自定义写入任何外部存储。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.addSink(<span class="keyword">new</span> <span class="title class_">MySinkFunction</span>&lt;String&gt;());</span><br></pre></td></tr></table></figure>
<p>在实现SinkFunction的时候，需要重写的一个关键方法invoke()，在这个方法中我们就可以实现将流里的数据发送出去的逻辑。</p>
<p>这种方式比较通用，对于任何外部存储系统都有效；不过自定义Sink想要实现状态一致性并不容易，所以一般只在没有其它选择时使用。实际项目中用到的外部连接器Flink官方基本都已实现，而且在不断地扩充，因此自定义的场景并不常见。</p>
<h1 id="4-Flink-中的窗口"><a href="#4-Flink-中的窗口" class="headerlink" title="4 Flink 中的窗口"></a>4 Flink 中的窗口</h1><h2 id="4-1-窗口"><a href="#4-1-窗口" class="headerlink" title="4.1 窗口"></a>4.1 窗口</h2><p>Flink是一种流式计算引擎，主要是来处理无界数据流的，数据源源不断、无穷无尽。想要更加方便高效地处理无界流，一种方式就是将无限数据切割成有限的“数据块”进行处理，这就是所谓的“窗口”（Window）。<br>在Flink中窗口可以把流切割成有限大小的多个“存储桶”（bucket），每个数据都会分发到对应的桶中，当到达窗口结束时间时，就对每个桶中收集的数据进行计算处理。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240109091736.png"></p>
<blockquote>
<p>Flink中窗口并不是静态准备好的，而是动态创建——当有落在这个窗口区间范围的数据达到时，才创建对应的窗口。</p>
</blockquote>
<h3 id="4-2-窗口分类"><a href="#4-2-窗口分类" class="headerlink" title="4.2 窗口分类"></a>4.2 窗口分类</h3><h3 id="4-2-1-按照驱动类型划分"><a href="#4-2-1-按照驱动类型划分" class="headerlink" title="4.2.1 按照驱动类型划分"></a>4.2.1 按照驱动类型划分</h3><ul>
<li><p>时间窗口（Time Window）<br>时间窗口以时间点来定义窗口的开始和结束，所以截取出的就是某一段时间段的数据，到达结束时间时，窗口不再收集数据，触发计算输出结果，并将窗口关闭销毁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sensorKS.window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">10</span>))) <span class="comment">// 滚动窗口，窗口长度10s  </span></span><br><span class="line">sensorKS.window(SlidingProcessingTimeWindows.of(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">2</span>))) <span class="comment">// 滑动窗口，窗口长度10s，滑动步长2s  </span></span><br><span class="line">sensorKS.window(ProcessingTimeSessionWindows.withGap(Time.seconds(<span class="number">5</span>))) <span class="comment">// 会话窗口，超时间隔5s</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>计数窗口（Count Window）<br>计数窗口基于元素的个数来截取数据，到达固定的个数时就触发计算并关闭窗口，每个窗口截取数据的个数，就是窗口的大小。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240109093047.png"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sensorKS.countWindow(<span class="number">5</span>)  <span class="comment">// 滚动窗口，窗口长度=5个元素  </span></span><br><span class="line">sensorKS.countWindow(<span class="number">5</span>,<span class="number">2</span>) <span class="comment">// 滑动窗口，窗口长度=5个元素，滑动步长=2个元素  </span></span><br><span class="line">sensorKS.window(GlobalWindows.create())  <span class="comment">// 全局窗口，计数窗口的底层就是用的这个，需要自定义的时候才会用</span></span><br></pre></td></tr></table></figure>
<h4 id="3-6-2-2-按照窗口分配数据的规则分类"><a href="#3-6-2-2-按照窗口分配数据的规则分类" class="headerlink" title="3.6.2.2 按照窗口分配数据的规则分类"></a>3.6.2.2 按照窗口分配数据的规则分类</h4><p>根据分配数据的规则，窗口具体实现可以分为4类：滚动窗口（Tumbling Window）、滑动窗口（Sliding Window）、会话窗口（Session Window）、全局窗口（Global Window）。</p>
<ul>
<li>滚动窗口<br>窗口有固定的大小，是一种对数据进行“均匀切片”的划分方式，窗口之间没有重叠，是“首尾相接”的状态，每个数据都会被分配到一个窗口，而且只会属于一个窗口。</li>
</ul>
<p>滚动窗口可以基于时间定义，也可以基于数据个数定义；需要的参数只有一个，就是<strong>窗口的大小（window size）</strong>。</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240109093518.png"></p>
<p>滚动处理时间窗口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">		<span class="comment">//长度为5秒的滚动窗口</span></span><br><span class="line">       .window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">       .aggregate(...)</span><br></pre></td></tr></table></figure>

<p>滚动事件时间窗口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">       .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">       .aggregate(...)</span><br></pre></td></tr></table></figure>


<ul>
<li>滑动窗口<br>滑动窗口的大小也是固定的，但是窗口之间并不是首尾相接，而是可以“错开”一定的位置。<br>定义滑动窗口的参数有两个：除了窗口大小（window size），还有一个“滑动步长”（window slide），它其实就代表了窗口计算的频率。窗口在结束时间触发计算输出结果，那么滑动步长就代表计算频率。</li>
</ul>
<p>当滑动步长小于窗口大小时，滑动窗口就会出现重叠，这时数据也可能会被同时分配到多个窗口中。而具体的个数，就由窗口大小和滑动步长的比值（size&#x2F;slide）来决定。<br>滚动窗口也可以看作是一种特殊的滑动窗口（窗口大小等于滑动步长）。滑动窗口适合计算结果更新频率非常高的场景。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240109094006.png"></p>
<p>滑动事件时间窗口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">       .window(SlidingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)，Time.seconds(<span class="number">5</span>)))</span><br><span class="line">       .aggregate(...)</span><br></pre></td></tr></table></figure>

<p>滑动计数窗口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">       .countWindow(<span class="number">10</span>，<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>定义了一个长度为10、滑动步长为3的滑动计数窗口。每个窗口统计10个数据，每隔3个数据就统计输出一次结果。</p>
<ul>
<li>会话窗口<br>会话窗口，基于“会话（session）”来对数据进行分组，会话窗口只能基于时间来定义。<br>会话窗口中，最终的参数就是会话的超时时间，也就是两个会话窗口之间的最小距离。如果相邻两个数据到来的时间间隔（Gap）小于指定的大小（size），那说明还在保持会话，他们就属于同一个窗口；如果</li>
</ul>
<p>gap大于size，那么新来的数据就应该属于新的会话窗口，而前一个窗口就应该关闭了。<br>会话窗口的长度不固定，起始和结束时间也是不确定的，各个分区之间窗口没有任何关联，会话窗口之间一定是不会重叠的，而是会留有至少为size的间隔。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240109094413.png"></p>
<p>事件时间会话窗口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">       .window(EventTimeSessionWindows.withGap(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">       .aggregate(...)</span><br></pre></td></tr></table></figure>

<ul>
<li>全局窗口<br>这种窗口全局有效，会把相同key的所有数据都分配到同一个窗口中，这种窗口没有结束的时候，默认是不会做触发计算的。如果希望他能对数据进行计算处理，还需要自定义“触发器”（Trigger）。</li>
</ul>
<p>全局窗口没有结束的时间点，所以一般在希望做更加灵活的窗口处理时自定义使用，Flink中的计数窗口（Count Window），底层就是用全局窗口实现。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240109094644.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">       .window(GlobalWindows.create());</span><br></pre></td></tr></table></figure>
<p>需要注意使用全局窗口，必须自行定义触发器才能实现窗口计算，否则起不到任何作用。</p>
<h2 id="4-3-窗口API"><a href="#4-3-窗口API" class="headerlink" title="4.3 窗口API"></a>4.3 窗口API</h2><ol>
<li>按键分区窗口（Keyed Windows）</li>
</ol>
<p>经过按键分区keyBy操作后，数据流会按照key被分为多条逻辑流（logical streams），这就是KeyedStream。基于KeyedStream进行窗口操作时，窗口计算会在多个并行子任务上同时执行。相同key的数据会被发送到同一个并行子任务，而窗口操作会基于每个key进行单独的处理。所以可以认为，每个key上都定义了一组窗口，各自独立地进行统计计算。</p>
<p>在代码实现上，我们需要先对DataStream调用.keyBy()进行按键分区，然后再调用.window()定义窗口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">       .window(...)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>非按键分区（Non-Keyed Windows）</li>
</ol>
<p>如果没有进行keyBy，那么原始的DataStream就不会分成多条逻辑流。这时窗口逻辑只能在一个任务（task）上执行，就相当于并行度变成了1。<br>在代码中，直接基于DataStream调用.windowAll()定义窗口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.windowAll(...)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于非按键分区的窗口操作，手动调大窗口算子的并行度也是无效的，windowAll本身就是一个非并行的操作。</p>
</blockquote>
<p>以 时间类型的 滚动窗口 为例，分析原理：</p>
<ol>
<li><p>窗口什么时候触发输出：时间进展 &gt;&#x3D; 窗口的最大时间戳（end - 1ms），窗口区间为 左闭右开。</p>
</li>
<li><p>窗口的划分：<br>start &#x3D; 向下取整，取窗口长度的整数倍（不是取当前数据到达的时间）<br>end&#x3D; start + 窗口长度</p>
</li>
<li><p>窗口的生命周期？<br>创建： 属于本窗口的第一条数据来的时候，现new的，放入一个singleton单例的集合中<br>销毁（关窗）： 时间进展 &gt;&#x3D;  窗口的最大时间戳（end - 1ms） + 允许迟到的时间（默认0）</p>
</li>
</ol>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.window;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.bean.WaterSensor;  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.functions.WaterSensorMapFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateFormatUtils;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.KeyedStream;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.WindowedStream;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.windowing.ProcessWindowFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.ProcessingTimeSessionWindows;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.SessionWindowTimeGapExtractor;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.SlidingProcessingTimeWindows;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingProcessingTimeWindows;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.TimeWindow;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeWindowDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;WaterSensor&gt; sensorDS = env  </span><br><span class="line">                .socketTextStream(<span class="string">&quot;hadoop102&quot;</span>, <span class="number">7777</span>)  </span><br><span class="line">                .map(<span class="keyword">new</span> <span class="title class_">WaterSensorMapFunction</span>());  </span><br><span class="line">  </span><br><span class="line">        KeyedStream&lt;WaterSensor, String&gt; sensorKS = sensorDS.keyBy(sensor -&gt; sensor.getId());  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 1. 窗口分配器  </span></span><br><span class="line">        WindowedStream&lt;WaterSensor, String, TimeWindow&gt; sensorWS = sensorKS  </span><br><span class="line">                .window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">10</span>))); <span class="comment">// 滚动窗口，窗口长度10秒  </span></span><br><span class="line"><span class="comment">//                .window(SlidingProcessingTimeWindows.of(Time.seconds(10), Time.seconds(5)));//滑动窗口，长度10s，步长5s  </span></span><br><span class="line"><span class="comment">//                .window(ProcessingTimeSessionWindows.withGap(Time.seconds(5)));//会话窗口，间隔5s  </span></span><br><span class="line"><span class="comment">//                .window(ProcessingTimeSessionWindows.withDynamicGap(  </span></span><br><span class="line"><span class="comment">//                        new SessionWindowTimeGapExtractor&lt;WaterSensor&gt;() &#123;  </span></span><br><span class="line"><span class="comment">//                            @Override  </span></span><br><span class="line"><span class="comment">//                            public long extract(WaterSensor element) &#123;  </span></span><br><span class="line"><span class="comment">//                                // 从数据中提取ts，作为间隔,单位ms  </span></span><br><span class="line"><span class="comment">//                                return element.getTs() * 1000L;  </span></span><br><span class="line"><span class="comment">//                            &#125;  </span></span><br><span class="line"><span class="comment">//                        &#125;  </span></span><br><span class="line"><span class="comment">//                ));// 会话窗口，动态间隔，每条来的数据都会更新 间隔时间  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; process = sensorWS  </span><br><span class="line">                .process(  </span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ProcessWindowFunction</span>&lt;WaterSensor, String, String, TimeWindow&gt;() &#123;  </span><br><span class="line">                            <span class="comment">/**  </span></span><br><span class="line"><span class="comment">                             * 全窗口函数计算逻辑：  窗口触发时才会调用一次，统一计算窗口的所有数据  </span></span><br><span class="line"><span class="comment">                             * <span class="doctag">@param</span> s   分组的key  </span></span><br><span class="line"><span class="comment">                             * <span class="doctag">@param</span> context  上下文  </span></span><br><span class="line"><span class="comment">                             * <span class="doctag">@param</span> elements 存的数据  </span></span><br><span class="line"><span class="comment">                             * <span class="doctag">@param</span> out      采集器  </span></span><br><span class="line"><span class="comment">                             * <span class="doctag">@throws</span> Exception  </span></span><br><span class="line"><span class="comment">                             */</span>  </span><br><span class="line">                            <span class="meta">@Override</span>  </span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String s, Context context, Iterable&lt;WaterSensor&gt; elements, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                                <span class="comment">// 上下文可以拿到window对象，还有其他东西：侧输出流 等等  </span></span><br><span class="line">                                <span class="type">long</span> <span class="variable">startTs</span> <span class="operator">=</span> context.window().getStart();  </span><br><span class="line">                                <span class="type">long</span> <span class="variable">endTs</span> <span class="operator">=</span> context.window().getEnd();  </span><br><span class="line">                                <span class="type">String</span> <span class="variable">windowStart</span> <span class="operator">=</span> DateFormatUtils.format(startTs, <span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);  </span><br><span class="line">                                <span class="type">String</span> <span class="variable">windowEnd</span> <span class="operator">=</span> DateFormatUtils.format(endTs, <span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">                                <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> elements.spliterator().estimateSize();  </span><br><span class="line">  </span><br><span class="line">                                out.collect(<span class="string">&quot;key=&quot;</span> + s + <span class="string">&quot;的窗口[&quot;</span> + windowStart + <span class="string">&quot;,&quot;</span> + windowEnd + <span class="string">&quot;)包含&quot;</span> + count + <span class="string">&quot;条数据===&gt;&quot;</span> + elements.toString());  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                );  </span><br><span class="line">  </span><br><span class="line">        process.print();  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-窗口函数"><a href="#4-4-窗口函数" class="headerlink" title="4.4 窗口函数"></a>4.4 窗口函数</h2><p>以上关于窗口的API是为了定义窗口分配器，知道了数据属于哪个窗口，可以将数据收集起来，至于收集起来到底要做什么，必须再接上一个定义窗口如何进行计算的操作，这就是“窗口函数”（window functions）。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240109112005.png"><br>窗口函数定义了要对窗口中收集的数据做的计算操作，根据处理的方式可以分为两类：增量聚合函数和全窗口函数。</p>
<h3 id="4-4-1-增量聚合函数（ReduceFunction-AggregateFunction）"><a href="#4-4-1-增量聚合函数（ReduceFunction-AggregateFunction）" class="headerlink" title="4.4.1 增量聚合函数（ReduceFunction&#x2F;AggregateFunction）"></a>4.4.1 增量聚合函数（ReduceFunction&#x2F;AggregateFunction）</h3><ol>
<li>ReduceFunction</li>
</ol>
<p>Reduce算子接收相同类型的数据，进行增量聚合，输出类型与输入类型一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.window;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.bean.WaterSensor;  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.functions.WaterSensorMapFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.ReduceFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.KeyedStream;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.WindowedStream;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingProcessingTimeWindows;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.TimeWindow;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowReduceDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;WaterSensor&gt; sensorDS = env  </span><br><span class="line">                .socketTextStream(<span class="string">&quot;10.211.55.4&quot;</span>, <span class="number">7777</span>)  </span><br><span class="line">                .map(<span class="keyword">new</span> <span class="title class_">WaterSensorMapFunction</span>());  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        KeyedStream&lt;WaterSensor, String&gt; sensorKS = sensorDS.keyBy(sensor -&gt; sensor.getId());  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 1. 窗口分配器  </span></span><br><span class="line">        WindowedStream&lt;WaterSensor, String, TimeWindow&gt; sensorWS = sensorKS.window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">10</span>)));  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 2. 窗口函数： 增量聚合 Reduce        </span></span><br><span class="line">        <span class="comment">/*** 窗口的reduce：  </span></span><br><span class="line"><span class="comment">         * 1、相同key的第一条数据来的时候，不会调用reduce方法  </span></span><br><span class="line"><span class="comment">         * 2、增量聚合： 来一条数据，就会计算一次，但是不会输出  </span></span><br><span class="line"><span class="comment">         * 3、在窗口触发的时候，才会输出窗口的最终计算结果  </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        SingleOutputStreamOperator&lt;WaterSensor&gt; reduce = sensorWS.reduce(  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ReduceFunction</span>&lt;WaterSensor&gt;() &#123;  </span><br><span class="line">                    <span class="meta">@Override</span>  </span><br><span class="line">                    <span class="keyword">public</span> WaterSensor <span class="title function_">reduce</span><span class="params">(WaterSensor value1, WaterSensor value2)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                        System.out.println(<span class="string">&quot;调用reduce方法，value1=&quot;</span> + value1 + <span class="string">&quot;,value2=&quot;</span> + value2);  </span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WaterSensor</span>(value1.getId(), value2.getTs(), value1.getVc() + value2.getVc());  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        reduce.print();  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实现一个10秒滚动窗口，对窗口中的Vc值进行累加操作。10秒后输出窗口结果。</p>
<ol start="2">
<li>AggregateFunction</li>
</ol>
<p>AggregateFunction可以看作是ReduceFunction的通用版本，这里有三种类型：输入类型（IN）、累加器类型（ACC）和输出类型（OUT）。输入类型IN就是输入流中元素的数据类型；累加器类型ACC则是我们进行聚合的中间状态类型；而输出类型当然就是最终计算结果的类型了。<br>接口中有四个方法：</p>
<ul>
<li>createAccumulator()：创建一个累加器，这就是为聚合创建了一个初始状态，每个聚合任务只会调用一次。</li>
<li>add()：将输入的元素添加到累加器中。</li>
<li>getResult()：从累加器中提取聚合的输出结果。</li>
<li>merge()：合并两个累加器，并将合并后的状态作为一个累加器返回。</li>
</ul>
<p><strong>AggregateFunction的工作原理是</strong>：首先调用createAccumulator()为任务初始化一个状态（累加器）；而后每来一个数据就调用一次add()方法，对数据进行聚合，得到的结果保存在状态中；等到了窗口需要输出时，再调用getResult()方法得到计算结果。很明显，与ReduceFunction相同，AggregateFunction也是增量式的聚合；而由于输入、中间状态、输出的类型可以不同，使得应用更加灵活方便。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.window;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.bean.WaterSensor;  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.functions.WaterSensorMapFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.AggregateFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.ReduceFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.KeyedStream;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.WindowedStream;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingProcessingTimeWindows;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.TimeWindow;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowAggregateDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;WaterSensor&gt; sensorDS = env  </span><br><span class="line">                .socketTextStream(<span class="string">&quot;hadoop102&quot;</span>, <span class="number">7777</span>)  </span><br><span class="line">                .map(<span class="keyword">new</span> <span class="title class_">WaterSensorMapFunction</span>());  </span><br><span class="line">  </span><br><span class="line">        KeyedStream&lt;WaterSensor, String&gt; sensorKS = sensorDS.keyBy(sensor -&gt; sensor.getId());  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 1. 窗口分配器  </span></span><br><span class="line">        WindowedStream&lt;WaterSensor, String, TimeWindow&gt; sensorWS = sensorKS.window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">10</span>)));  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 2. 窗口函数： 增量聚合 Aggregate        </span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1、属于本窗口的第一条数据来，创建窗口，创建累加器  </span></span><br><span class="line"><span class="comment">         * 2、增量聚合： 来一条计算一条， 调用一次add方法  </span></span><br><span class="line"><span class="comment">         * 3、窗口输出时调用一次getresult方法  </span></span><br><span class="line"><span class="comment">         * 4、输入、中间累加器、输出 类型可以不一样，非常灵活  </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; aggregate = sensorWS.aggregate(  </span><br><span class="line">                <span class="comment">/**  </span></span><br><span class="line"><span class="comment">                 * 第一个类型： 输入数据的类型  </span></span><br><span class="line"><span class="comment">                 * 第二个类型： 累加器的类型，存储的中间计算结果的类型  </span></span><br><span class="line"><span class="comment">                 * 第三个类型： 输出的类型  </span></span><br><span class="line"><span class="comment">                 */</span>  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AggregateFunction</span>&lt;WaterSensor, Integer, String&gt;() &#123;  </span><br><span class="line">                    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">                     * 创建累加器，初始化累加器  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment">                     */</span>  </span><br><span class="line">                    <span class="meta">@Override</span>  </span><br><span class="line">                    <span class="keyword">public</span> Integer <span class="title function_">createAccumulator</span><span class="params">()</span> &#123;  </span><br><span class="line">                        System.out.println(<span class="string">&quot;创建累加器&quot;</span>);  </span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line">  </span><br><span class="line">                    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">                     * 聚合逻辑  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> value  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> accumulator  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment">                     */</span>  </span><br><span class="line">                    <span class="meta">@Override</span>  </span><br><span class="line">                    <span class="keyword">public</span> Integer <span class="title function_">add</span><span class="params">(WaterSensor value, Integer accumulator)</span> &#123;  </span><br><span class="line">                        System.out.println(<span class="string">&quot;调用add方法,value=&quot;</span>+value);  </span><br><span class="line">                        <span class="keyword">return</span> accumulator + value.getVc();  </span><br><span class="line">                    &#125;  </span><br><span class="line">  </span><br><span class="line">                    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">                     * 获取最终结果，窗口触发时输出  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> accumulator  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment">                     */</span>  </span><br><span class="line">                    <span class="meta">@Override</span>  </span><br><span class="line">                    <span class="keyword">public</span> String <span class="title function_">getResult</span><span class="params">(Integer accumulator)</span> &#123;  </span><br><span class="line">                        System.out.println(<span class="string">&quot;调用getResult方法&quot;</span>);  </span><br><span class="line">                        <span class="keyword">return</span> accumulator.toString();  </span><br><span class="line">                    &#125;  </span><br><span class="line">  </span><br><span class="line">                    <span class="meta">@Override</span>  </span><br><span class="line">                    <span class="keyword">public</span> Integer <span class="title function_">merge</span><span class="params">(Integer a, Integer b)</span> &#123;  </span><br><span class="line">                        <span class="comment">// 只有会话窗口才会用到  </span></span><br><span class="line">                        System.out.println(<span class="string">&quot;调用merge方法&quot;</span>);  </span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        aggregate.print();  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上聚合逻辑计算后，返回类型与输入类型不同。</p>
<h3 id="4-4-2-全窗口函数（WindowFunction-ProcessWindowFunction）"><a href="#4-4-2-全窗口函数（WindowFunction-ProcessWindowFunction）" class="headerlink" title="4.4.2 全窗口函数（WindowFunction&#x2F;ProcessWindowFunction）"></a>4.4.2 全窗口函数（WindowFunction&#x2F;ProcessWindowFunction）</h3><p>有些场景下，我们要做的计算必须基于全部的数据才有效，这时做增量聚合就没什么意义了；另外，输出的结果有可能要包含上下文中的一些信息（比如窗口的起始时间），这是增量聚合函数做不到的。</p>
<p>所以，我们还需要有更丰富的窗口计算方式。窗口操作中的另一大类就是全窗口函数。与增量聚合函数不同，全窗口函数需要先收集窗口中的数据，并在内部缓存起来，等到窗口要输出结果的时候再取出数据进行计算。</p>
<p>在Flink中，全窗口函数也有两种：WindowFunction和ProcessWindowFunction。</p>
<ol>
<li>窗口函数（WindowFunction）</li>
</ol>
<p>逐渐被 ProcessWindowFunction 替代，弃用。</p>
<ol start="2">
<li>处理窗口函数（ProcessWindowFunction）</li>
</ol>
<p>ProcessWindowFunction是Window API中最底层的通用窗口函数接口。之所以说它“最底层”，是因为除了可以拿到窗口中的所有数据之外，ProcessWindowFunction还可以获取到一个“上下文对象”（Context）。这个上下文对象非常强大，不仅能够获取窗口信息，还可以访问当前的时间和状态信息。这里的时间就包括了处理时间（processing time）和事件时间水位线（event time watermark）。这就使得ProcessWindowFunction更加灵活、功能更加丰富，其实就是一个增强版的WindowFunction。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.window;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.bean.WaterSensor;  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.functions.WaterSensorMapFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateFormatUtils;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.AggregateFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.KeyedStream;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.WindowedStream;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.windowing.ProcessWindowFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.windowing.WindowFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingProcessingTimeWindows;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.TimeWindow;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowProcessDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;WaterSensor&gt; sensorDS = env  </span><br><span class="line">                .socketTextStream(<span class="string">&quot;10.211.55.4&quot;</span>, <span class="number">7777</span>)  </span><br><span class="line">                .map(<span class="keyword">new</span> <span class="title class_">WaterSensorMapFunction</span>());  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        KeyedStream&lt;WaterSensor, String&gt; sensorKS = sensorDS.keyBy(sensor -&gt; sensor.getId());  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 1. 窗口分配器  </span></span><br><span class="line">        WindowedStream&lt;WaterSensor, String, TimeWindow&gt; sensorWS = sensorKS.window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">10</span>)));  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 老写法  </span></span><br><span class="line"><span class="comment">//        sensorWS  </span></span><br><span class="line"><span class="comment">//                .apply(  </span></span><br><span class="line"><span class="comment">//                        new WindowFunction&lt;WaterSensor, String, String, TimeWindow&gt;() &#123;  </span></span><br><span class="line"><span class="comment">//                            /**  </span></span><br><span class="line"><span class="comment">//                             *  </span></span><br><span class="line"><span class="comment">//                             * @param s  分组的key  </span></span><br><span class="line"><span class="comment">//                             * @param window 窗口对象  </span></span><br><span class="line"><span class="comment">//                             * @param input 存的数据  </span></span><br><span class="line"><span class="comment">//                             * @param out   采集器  </span></span><br><span class="line"><span class="comment">//                             * @throws Exception  </span></span><br><span class="line"><span class="comment">//                             */  </span></span><br><span class="line"><span class="comment">//                            @Override  </span></span><br><span class="line"><span class="comment">//                            public void apply(String s, TimeWindow window, Iterable&lt;WaterSensor&gt; input, Collector&lt;String&gt; out) throws Exception &#123;  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">//                            &#125;  </span></span><br><span class="line"><span class="comment">//                        &#125;  </span></span><br><span class="line"><span class="comment">//                )  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; process = sensorWS  </span><br><span class="line">                .process(  </span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ProcessWindowFunction</span>&lt;WaterSensor, String, String, TimeWindow&gt;() &#123;  </span><br><span class="line">                            <span class="comment">/**  </span></span><br><span class="line"><span class="comment">                             * 全窗口函数计算逻辑：  窗口触发时才会调用一次，统一计算窗口的所有数据  </span></span><br><span class="line"><span class="comment">                             * <span class="doctag">@param</span> s   分组的key  </span></span><br><span class="line"><span class="comment">                             * <span class="doctag">@param</span> context  上下文  </span></span><br><span class="line"><span class="comment">                             * <span class="doctag">@param</span> elements 存的数据  </span></span><br><span class="line"><span class="comment">                             * <span class="doctag">@param</span> out      采集器  </span></span><br><span class="line"><span class="comment">                             * <span class="doctag">@throws</span> Exception  </span></span><br><span class="line"><span class="comment">                             */</span>  </span><br><span class="line">                            <span class="meta">@Override</span>  </span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String s, Context context, Iterable&lt;WaterSensor&gt; elements, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                                <span class="comment">// 上下文可以拿到window对象，还有其他东西：侧输出流 等等  </span></span><br><span class="line">                                <span class="type">long</span> <span class="variable">startTs</span> <span class="operator">=</span> context.window().getStart();  </span><br><span class="line">                                <span class="type">long</span> <span class="variable">endTs</span> <span class="operator">=</span> context.window().getEnd();  </span><br><span class="line">                                <span class="type">String</span> <span class="variable">windowStart</span> <span class="operator">=</span> DateFormatUtils.format(startTs, <span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);  </span><br><span class="line">                                <span class="type">String</span> <span class="variable">windowEnd</span> <span class="operator">=</span> DateFormatUtils.format(endTs, <span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">                                <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> elements.spliterator().estimateSize();  </span><br><span class="line">  </span><br><span class="line">                                out.collect(<span class="string">&quot;key=&quot;</span> + s + <span class="string">&quot;的窗口[&quot;</span> + windowStart + <span class="string">&quot;,&quot;</span> + windowEnd + <span class="string">&quot;)包含&quot;</span> + count + <span class="string">&quot;条数据===&gt;&quot;</span> + elements.toString());  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                );  </span><br><span class="line">  </span><br><span class="line">        process.print();  </span><br><span class="line">		env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key=s1的窗口[2024-01-09 11:37:40.000,2024-01-09 11:37:50.000)包含2条数据===&gt;[WaterSensor&#123;<span class="built_in">id</span>=<span class="string">&#x27;s1&#x27;</span>, ts=1, vc=1&#125;, WaterSensor&#123;<span class="built_in">id</span>=<span class="string">&#x27;s1&#x27;</span>, ts=2, vc=3&#125;]</span><br><span class="line">key=s1的窗口[2024-01-09 11:37:50.000,2024-01-09 11:38:00.000)包含1条数据===&gt;[WaterSensor&#123;<span class="built_in">id</span>=<span class="string">&#x27;s1&#x27;</span>, ts=3, vc=3&#125;]</span><br></pre></td></tr></table></figure>
<p>全窗口函数不是来一条数据就计算一条，是窗口时间到达后，再计算输出。</p>
<h3 id="4-4-3-增量聚合和全窗口函数结合"><a href="#4-4-3-增量聚合和全窗口函数结合" class="headerlink" title="4.4.3 增量聚合和全窗口函数结合"></a>4.4.3 增量聚合和全窗口函数结合</h3><p>通过结合可以兼具两者的优点，调用WindowedStream的.reduce()和.aggregate()方法时，只是简单地直接传入了一个ReduceFunction或AggregateFunction进行增量聚合。除此之外，其实还可以传入第二个参数：一个全窗口函数，可以是WindowFunction或者ProcessWindowFunction。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReduceFunction与WindowFunction结合</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; SingleOutputStreamOperator&lt;R&gt; <span class="title function_">reduce</span><span class="params">(</span></span><br><span class="line"><span class="params">        ReduceFunction&lt;T&gt; reduceFunction，WindowFunction&lt;T，R，K，W&gt; function)</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// ReduceFunction与ProcessWindowFunction结合</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; SingleOutputStreamOperator&lt;R&gt; <span class="title function_">reduce</span><span class="params">(</span></span><br><span class="line"><span class="params">        ReduceFunction&lt;T&gt; reduceFunction，ProcessWindowFunction&lt;T，R，K，W&gt; function)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AggregateFunction与WindowFunction结合</span></span><br><span class="line"><span class="keyword">public</span> &lt;ACC，V，R&gt; SingleOutputStreamOperator&lt;R&gt; <span class="title function_">aggregate</span><span class="params">(</span></span><br><span class="line"><span class="params">        AggregateFunction&lt;T，ACC，V&gt; aggFunction，WindowFunction&lt;V，R，K，W&gt; windowFunction)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AggregateFunction与ProcessWindowFunction结合</span></span><br><span class="line"><span class="keyword">public</span> &lt;ACC，V，R&gt; SingleOutputStreamOperator&lt;R&gt; <span class="title function_">aggregate</span><span class="params">(</span></span><br><span class="line"><span class="params">        AggregateFunction&lt;T，ACC，V&gt; aggFunction,</span></span><br><span class="line"><span class="params">        ProcessWindowFunction&lt;V，R，K，W&gt; windowFunction)</span></span><br></pre></td></tr></table></figure>

<p>基于第一个参数（增量聚合函数）来处理窗口数据，每来一个数据就做一次聚合；等到窗口需要触发计算<br>时，则调用第二个参数（全窗口函数）的处理逻辑输出结果。需要注意的是，这里的全窗口函数就不再缓存所有数据了，而是直接将增量聚合函数的结果拿来当作了Iterable类型的输入。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.window;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.bean.WaterSensor;  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.functions.WaterSensorMapFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateFormatUtils;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.AggregateFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.KeyedStream;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.WindowedStream;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.windowing.ProcessWindowFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingProcessingTimeWindows;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.TimeWindow;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowAggregateAndProcessDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;WaterSensor&gt; sensorDS = env  </span><br><span class="line">                .socketTextStream(<span class="string">&quot;hadoop102&quot;</span>, <span class="number">7777</span>)  </span><br><span class="line">                .map(<span class="keyword">new</span> <span class="title class_">WaterSensorMapFunction</span>());  </span><br><span class="line">  </span><br><span class="line">        KeyedStream&lt;WaterSensor, String&gt; sensorKS = sensorDS.keyBy(sensor -&gt; sensor.getId());  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 1. 窗口分配器  </span></span><br><span class="line">        WindowedStream&lt;WaterSensor, String, TimeWindow&gt; sensorWS = sensorKS.window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">10</span>)));  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 2. 窗口函数：  </span></span><br><span class="line">        <span class="comment">/**  </span></span><br><span class="line"><span class="comment">         * 增量聚合 Aggregate + 全窗口 process  </span></span><br><span class="line"><span class="comment">         * 1、增量聚合函数处理数据： 来一条计算一条  </span></span><br><span class="line"><span class="comment">         * 2、窗口触发时， 增量聚合的结果（只有一条） 传递给 全窗口函数  </span></span><br><span class="line"><span class="comment">         * 3、经过全窗口函数的处理包装后，输出  </span></span><br><span class="line"><span class="comment">         *  </span></span><br><span class="line"><span class="comment">         * 结合两者的优点：  </span></span><br><span class="line"><span class="comment">         * 1、增量聚合： 来一条计算一条，存储中间的计算结果，占用的空间少  </span></span><br><span class="line"><span class="comment">         * 2、全窗口函数： 可以通过 上下文 实现灵活的功能  </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//        sensorWS.reduce()   //也可以传两个  </span></span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; result = sensorWS.aggregate(  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MyAgg</span>(),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MyProcess</span>()  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        result.print();  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyAgg</span> <span class="keyword">implements</span> <span class="title class_">AggregateFunction</span>&lt;WaterSensor, Integer, String&gt;&#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">createAccumulator</span><span class="params">()</span> &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;创建累加器&quot;</span>);  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">add</span><span class="params">(WaterSensor value, Integer accumulator)</span> &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;调用add方法,value=&quot;</span>+value);  </span><br><span class="line">            <span class="keyword">return</span> accumulator + value.getVc();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getResult</span><span class="params">(Integer accumulator)</span> &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;调用getResult方法&quot;</span>);  </span><br><span class="line">            <span class="keyword">return</span> accumulator.toString();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">merge</span><span class="params">(Integer a, Integer b)</span> &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;调用merge方法&quot;</span>);  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 全窗口函数的输入类型 = 增量聚合函数的输出类型  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyProcess</span> <span class="keyword">extends</span> <span class="title class_">ProcessWindowFunction</span>&lt;String,String,String,TimeWindow&gt;&#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String s, Context context, Iterable&lt;String&gt; elements, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">            <span class="type">long</span> <span class="variable">startTs</span> <span class="operator">=</span> context.window().getStart();  </span><br><span class="line">            <span class="type">long</span> <span class="variable">endTs</span> <span class="operator">=</span> context.window().getEnd();  </span><br><span class="line">            <span class="type">String</span> <span class="variable">windowStart</span> <span class="operator">=</span> DateFormatUtils.format(startTs, <span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);  </span><br><span class="line">            <span class="type">String</span> <span class="variable">windowEnd</span> <span class="operator">=</span> DateFormatUtils.format(endTs, <span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">            <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> elements.spliterator().estimateSize();  </span><br><span class="line">  </span><br><span class="line">            out.collect(<span class="string">&quot;key=&quot;</span> + s + <span class="string">&quot;的窗口[&quot;</span> + windowStart + <span class="string">&quot;,&quot;</span> + windowEnd + <span class="string">&quot;)包含&quot;</span> + count + <span class="string">&quot;条数据===&gt;&quot;</span> + elements.toString());  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-其他-API"><a href="#4-5-其他-API" class="headerlink" title="4.5 其他 API"></a>4.5 其他 API</h2><p>对于一个窗口算子而言，窗口分配器和窗口函数是必不可少的。除此之外，Flink还提供了其他一些可选的API，让我们可以更加灵活地控制窗口行为。</p>
<p>触发器、移除器： 现成的几个窗口，都有默认的实现，一般不需要自定义</p>
<h4 id="4-5-1-触发器（Trigger）"><a href="#4-5-1-触发器（Trigger）" class="headerlink" title="4.5.1 触发器（Trigger）"></a>4.5.1 触发器（Trigger）</h4><p>触发器主要是用来控制窗口什么时候触发计算。所谓的“触发计算”，本质上就是执行窗口函数，所以可以认为是计算得到结果并输出的过程。<br>基于WindowedStream调用.trigger()方法，就可以传入一个自定义的窗口触发器（Trigger）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">       .window(...)</span><br><span class="line">       .trigger(<span class="keyword">new</span> <span class="title class_">MyTrigger</span>())</span><br></pre></td></tr></table></figure>
<h3 id="4-5-2-移除器（Evictor）"><a href="#4-5-2-移除器（Evictor）" class="headerlink" title="4.5.2 移除器（Evictor）"></a>4.5.2 移除器（Evictor）</h3><p>移除器主要用来定义移除某些数据的逻辑。基于WindowedStream调用.evictor()方法，就可以传入一个自定义的移除器（Evictor）。Evictor是一个接口，不同的窗口类型都有各自预实现的移除器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">       .window(...)</span><br><span class="line">       .evictor(<span class="keyword">new</span> <span class="title class_">MyEvictor</span>())</span><br></pre></td></tr></table></figure>

<h1 id="5-水位线（Watermark）"><a href="#5-水位线（Watermark）" class="headerlink" title="5 水位线（Watermark）"></a>5 水位线（Watermark）</h1><h2 id="5-1-时间语义"><a href="#5-1-时间语义" class="headerlink" title="5.1 时间语义"></a>5.1 时间语义</h2><p>事件时间：数据产生的时间；处理时间：数据真正被处理的时刻。<br>在实际应用中，事件时间语义会更为常见。一般情况下，业务日志数据中都会记录数据生成的时间戳（timestamp），它就可以作为事件时间的判断基础。</p>
<blockquote>
<p>早期版本默认的时间语义是处理时间；而考虑到事件时间在实际应用中更为广泛，从Flink1.12版本开始，Flink已经将事件时间作为默认的时间语义了。</p>
</blockquote>
<h2 id="5-2-水位线（Watermark）"><a href="#5-2-水位线（Watermark）" class="headerlink" title="5.2 水位线（Watermark）"></a>5.2 水位线（Watermark）</h2><h3 id="5-2-1-事件时间和窗口"><a href="#5-2-1-事件时间和窗口" class="headerlink" title="5.2.1 事件时间和窗口"></a>5.2.1 事件时间和窗口</h3><p>在窗口的处理过程中，可以基于数据的时间戳，自定义一个“逻辑时钟”，这个时钟的时间不会自动流逝，他的时间进展，就是靠着新到数据的时间戳来推动。<br>这样好处在于，计算的过程可以完全不依赖处理时间（系统时间），不论什么时候进行统计处理，得到的结果都是正确的。而一般实时流处理的场景中，事件时间可以基本与处理时间保持同步，只是略微有点延迟。</p>
<h3 id="5-2-2-什么是水位线"><a href="#5-2-2-什么是水位线" class="headerlink" title="5.2.2 什么是水位线"></a>5.2.2 什么是水位线</h3><p>在Flink中，用来衡量事件时间进展的标记，就被称作“水位线”（Watermark）。<br>水位线可以看作一条特殊的数据记录，它是插入到数据流中的一个标记点，主要内容就是一个时间戳，用来指示当前的事件时间。而它插入流中的位置，就应该是在某个数据到来之后；这样就可以从这个数据中提取时间戳，作为当前水位线的时间戳了。</p>
<ul>
<li>乱序流中的水位线</li>
</ul>
<p>在分布式系统中，数据在节点间传输，会因为网络传输延迟的不确定性，导致顺序发生改变，这就是所谓的“乱序数据”。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240109144354.png"></p>
<p><strong>乱序 + 数据量小</strong>：我们还是靠数据来驱动，每来一个数据就提取他的时间戳、插入水位线，不过现在的情况是数据乱序，所以插入新的水位线时，要先判断一下时间戳是否比之前的大，否则就不再生成新的水位线，只有数据的时间戳比当前时钟大，才能推进时钟前进，这时才插入水位线。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240109144554.png"></p>
<p><strong>乱序 + 数据量大</strong>：如果考虑到大量数据同时到来的处理效率，同样可以周期性地生成水位线，这时只需要保存一下之前所有数据中的最大时间戳，需要插入水位线时，就直接以它作为时间戳生成新的水位线。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240109144737.png"></p>
<p><strong>乱序 + 迟到数据</strong>：为了让窗口能够正确收集迟到的数据，可以等上一段时间，比如2秒；就是当前已有数据的最大时间戳减去2秒，就是要插入的水位线的时间戳。这样的话，9秒的数据到来之后，事件时钟不会直接推进到9秒，而是进展到7秒；必须等到11秒的数据到来之后，事件时钟才会进展到9秒，这时迟到数据也都已收集齐，0～9秒的窗口就可以正确计算结果了。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240109145043.png"></p>
<blockquote>
<p>水位线代表了当前的事件时间时钟，而且可以在数据的时间戳基础上加一些延迟来保证不丢数据，在对于乱序流的正确处理非常重要。</p>
</blockquote>
<p><strong>水位线特性：</strong></p>
<ol>
<li>水位线是插入到数据流中的一个标记，可以认为是一个特殊的数据</li>
<li>水位线主要的内容是一个时间戳，用来表示当前事件时间的进展</li>
<li>水位线是基于数据的时间戳生成的</li>
<li>水位线的时间戳必须单调递增，以确保任务的事件时间时钟一直向前推进</li>
<li>水位线可以通过设置延迟，来保证正确处理乱序数据</li>
<li>一个水位线Watermark（t），表示在当前流中事件时间已经达到了时间戳t，这代表t之前的所有数据都到齐了，之后流中不会出现时间戳 t’ &lt;&#x3D; t 的数据<blockquote>
<p>水位线是Flink流处理中保证结果正确性的核心机制，它往往会跟窗口一起配合，完成对乱序数据的正确处理。</p>
</blockquote>
</li>
</ol>
<h3 id="5-2-3-水位线和窗口的工作原理"><a href="#5-2-3-水位线和窗口的工作原理" class="headerlink" title="5.2.3 水位线和窗口的工作原理"></a>5.2.3 水位线和窗口的工作原理</h3><p>在Flink中，窗口可以理解为一个“桶”，窗口可以把流切割成有限大小的多个“存储桶”（bucket），每个数据都会分发到对应的桶中，当到达窗口结束时间时，就对每个桶中收集的数据进行计算处理。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240109150018.png"></p>
<blockquote>
<p>Flink中窗口并不是静态准备好的，而是动态创建——当有落在这个窗口区间范围的数据达到时，才创建对应的窗口。另外，这里我们认为到达窗口结束时间时，窗口就触发计算并关闭，事实上“触发计算”和“窗口关闭”两个行为也可以分开。</p>
</blockquote>
<h3 id="5-2-4-生成水位线"><a href="#5-2-4-生成水位线" class="headerlink" title="5.2.4 生成水位线"></a>5.2.4 生成水位线</h3><p>完美的水位线是“绝对正确”的，也就是一个水位线一旦出现，就表示这个时间之前的数据已经全部到齐、之后再也不会出现了。不过如果要保证绝对正确，就必须等足够长的时间，这会带来更高的延迟。<br>如果希望处理得更快、实时性更强，那么可以将水位线延迟设得更低一些。这样可以遗漏延迟到达的数据。<br>所以水位线是流处理中对低延迟和结果正确行的一个权衡机制，而且可以由程序控制。</p>
<p><strong>示例代码：</strong> </p>
<ol>
<li><p><code>&lt;WaterSensor&gt;forMonotonousTimestamps() </code>：没有乱序数据，生序的 watermark，没有等待时间</p>
</li>
<li><p><code>&lt;WaterSensor&gt;forBoundedOutOfOrderness(Duration.ofSeconds(3)) </code>：乱序数据，指定 延迟 3s</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.watermark;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.bean.WaterSensor;  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.functions.WaterSensorMapFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateFormatUtils;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.SerializableTimestampAssigner;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkStrategy;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.KeyedStream;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.WindowedStream;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.windowing.ProcessWindowFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingProcessingTimeWindows;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.TimeWindow;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WatermarkMonoDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;WaterSensor&gt; sensorDS = env  </span><br><span class="line">                .socketTextStream(<span class="string">&quot;hadoop102&quot;</span>, <span class="number">7777</span>)  </span><br><span class="line">                .map(<span class="keyword">new</span> <span class="title class_">WaterSensorMapFunction</span>());  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// TODO 1.定义Watermark策略  </span></span><br><span class="line">        WatermarkStrategy&lt;WaterSensor&gt; watermarkStrategy = WatermarkStrategy  </span><br><span class="line">                <span class="comment">// 1.1 指定watermark生成：升序的watermark，没有等待时间  </span></span><br><span class="line">                .&lt;WaterSensor&gt;forMonotonousTimestamps() </span><br><span class="line">                <span class="comment">// 1.1 指定watermark生成：乱序的，等待3s  </span></span><br><span class="line">				<span class="comment">//.&lt;WaterSensor&gt;forBoundedOutOfOrderness(Duration.ofSeconds(3)) </span></span><br><span class="line">                <span class="comment">// 1.2 指定 时间戳分配器，从数据中提取  </span></span><br><span class="line">                .withTimestampAssigner(<span class="keyword">new</span> <span class="title class_">SerializableTimestampAssigner</span>&lt;WaterSensor&gt;() &#123;  </span><br><span class="line">                    <span class="meta">@Override</span>  </span><br><span class="line">                    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">extractTimestamp</span><span class="params">(WaterSensor element, <span class="type">long</span> recordTimestamp)</span> &#123;  </span><br><span class="line">                        <span class="comment">// 返回的时间戳，要 毫秒  </span></span><br><span class="line">                        System.out.println(<span class="string">&quot;数据=&quot;</span> + element + <span class="string">&quot;,recordTs=&quot;</span> + recordTimestamp);  </span><br><span class="line">                        <span class="keyword">return</span> element.getTs() * <span class="number">1000L</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// TODO 2. 指定 watermark策略  </span></span><br><span class="line">        SingleOutputStreamOperator&lt;WaterSensor&gt; sensorDSwithWatermark = sensorDS.assignTimestampsAndWatermarks(watermarkStrategy);  </span><br><span class="line">  </span><br><span class="line">        sensorDSwithWatermark.keyBy(sensor -&gt; sensor.getId())  </span><br><span class="line">                <span class="comment">// TODO 3.使用 事件时间语义 的窗口  </span></span><br><span class="line">                .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))  </span><br><span class="line">                .process(  </span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ProcessWindowFunction</span>&lt;WaterSensor, String, String, TimeWindow&gt;() &#123;  </span><br><span class="line">  </span><br><span class="line">                            <span class="meta">@Override</span>  </span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String s, Context context, Iterable&lt;WaterSensor&gt; elements, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                                <span class="type">long</span> <span class="variable">startTs</span> <span class="operator">=</span> context.window().getStart();  </span><br><span class="line">                                <span class="type">long</span> <span class="variable">endTs</span> <span class="operator">=</span> context.window().getEnd();  </span><br><span class="line">                                <span class="type">String</span> <span class="variable">windowStart</span> <span class="operator">=</span> DateFormatUtils.format(startTs, <span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);  </span><br><span class="line">                                <span class="type">String</span> <span class="variable">windowEnd</span> <span class="operator">=</span> DateFormatUtils.format(endTs, <span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">                                <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> elements.spliterator().estimateSize();  </span><br><span class="line">  </span><br><span class="line">                                out.collect(<span class="string">&quot;key=&quot;</span> + s + <span class="string">&quot;的窗口[&quot;</span> + windowStart + <span class="string">&quot;,&quot;</span> + windowEnd + <span class="string">&quot;)包含&quot;</span> + count + <span class="string">&quot;条数据===&gt;&quot;</span> + elements.toString());  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                )  </span><br><span class="line">                .print();  </span><br><span class="line">  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>先定义watermark策略</p>
</li>
<li><p>指定watermark策略</p>
</li>
<li><p>注意使用的是事件时间窗口</p>
</li>
</ol>
<ul>
<li>watermark的生成原理</li>
</ul>
<ol>
<li>周期性生成：默认 200ms</li>
<li>有序流：wartermark &#x3D; 当前最大事件时间 - 1ms</li>
<li>乱序流：wartermark &#x3D; 当前最大事件时间 - 延迟时间 - 1ms</li>
</ol>
<h3 id="5-2-5-自定义水位线生成器"><a href="#5-2-5-自定义水位线生成器" class="headerlink" title="5.2.5 自定义水位线生成器"></a>5.2.5 自定义水位线生成器</h3><ul>
<li>周期性和断点式水位生成器</li>
</ul>
<p>周期性水位生成器通过继承WatermarkGenerator，重载onEvent()观察判断输入的事件，而在onPeriodicEmit()里发出水位线。</p>
<p>断点式生成器会不停地检测onEvent()中的事件，当发现带有水位线信息的事件时，就立即发出水位线。我们把发射水位线的逻辑写在onEvent方法当中即可。</p>
<p><strong>定义周期性水位线生成器</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.watermark;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.Watermark;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkGenerator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkOutput;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPeriodWatermarkGenerator</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">WatermarkGenerator</span>&lt;T&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 乱序等待时间  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> delayTs;  </span><br><span class="line">    <span class="comment">// 用来保存 当前为止 最大的事件时间  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> maxTs;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyPeriodWatermarkGenerator</span><span class="params">(<span class="type">long</span> delayTs)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.delayTs = delayTs;  </span><br><span class="line">        <span class="built_in">this</span>.maxTs = Long.MIN_VALUE + <span class="built_in">this</span>.delayTs + <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 每条数据来，都会调用一次： 用来提取最大的事件时间，保存下来  </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eventTimestamp 提取到的数据的 事件时间  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> output  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(T event, <span class="type">long</span> eventTimestamp, WatermarkOutput output)</span> &#123;  </span><br><span class="line">        maxTs = Math.max(maxTs, eventTimestamp);  </span><br><span class="line">        System.out.println(<span class="string">&quot;调用onEvent方法，获取目前为止的最大时间戳=&quot;</span> + maxTs);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 周期性调用： 发射 watermark  </span></span><br><span class="line"><span class="comment">     *     * <span class="doctag">@param</span> output  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPeriodicEmit</span><span class="params">(WatermarkOutput output)</span> &#123;  </span><br><span class="line">        output.emitWatermark(<span class="keyword">new</span> <span class="title class_">Watermark</span>(maxTs - delayTs - <span class="number">1</span>));  </span><br><span class="line">        System.out.println(<span class="string">&quot;调用onPeriodicEmit方法，生成watermark=&quot;</span> + (maxTs - delayTs - <span class="number">1</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义断点式水位生成器</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.watermark;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.Watermark;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkGenerator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkOutput;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPuntuatedWatermarkGenerator</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">WatermarkGenerator</span>&lt;T&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 乱序等待时间  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> delayTs;  </span><br><span class="line">    <span class="comment">// 用来保存 当前为止 最大的事件时间  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> maxTs;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyPuntuatedWatermarkGenerator</span><span class="params">(<span class="type">long</span> delayTs)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.delayTs = delayTs;  </span><br><span class="line">        <span class="built_in">this</span>.maxTs = Long.MIN_VALUE + <span class="built_in">this</span>.delayTs + <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 每条数据来，都会调用一次： 用来提取最大的事件时间，保存下来,并发射watermark  </span></span><br><span class="line"><span class="comment">     *     * <span class="doctag">@param</span> event  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eventTimestamp 提取到的数据的 事件时间  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> output  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(T event, <span class="type">long</span> eventTimestamp, WatermarkOutput output)</span> &#123;  </span><br><span class="line">        maxTs = Math.max(maxTs, eventTimestamp);  </span><br><span class="line">        output.emitWatermark(<span class="keyword">new</span> <span class="title class_">Watermark</span>(maxTs - delayTs - <span class="number">1</span>));  </span><br><span class="line">        System.out.println(<span class="string">&quot;调用onEvent方法，获取目前为止的最大时间戳=&quot;</span> + maxTs+<span class="string">&quot;,watermark=&quot;</span>+(maxTs - delayTs - <span class="number">1</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 周期性调用： 不需要  </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> output  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPeriodicEmit</span><span class="params">(WatermarkOutput output)</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用周期性水位线生成器：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.watermark;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.bean.WaterSensor;  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.functions.WaterSensorMapFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateFormatUtils;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkGenerator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkGeneratorSupplier;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkStrategy;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.windowing.ProcessWindowFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.TimeWindow;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.time.Duration;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WatermarkCustomDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// watermark 生成周期，默认周期 200ms        env.getConfig().setAutoWatermarkInterval(2000);  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;WaterSensor&gt; sensorDS = env  </span><br><span class="line">                .socketTextStream(<span class="string">&quot;hadoop102&quot;</span>, <span class="number">7777</span>)  </span><br><span class="line">                .map(<span class="keyword">new</span> <span class="title class_">WaterSensorMapFunction</span>());  </span><br><span class="line">  </span><br><span class="line">        WatermarkStrategy&lt;WaterSensor&gt; watermarkStrategy = WatermarkStrategy  </span><br><span class="line">                <span class="comment">// TODO 指定 自定义的 生成器  </span></span><br><span class="line">                <span class="comment">// 1.自定义的 周期性生成  </span></span><br><span class="line"><span class="comment">//                .&lt;WaterSensor&gt;forGenerator(ctx -&gt; new MyPeriodWatermarkGenerator&lt;&gt;(3000L))  </span></span><br><span class="line">                <span class="comment">// 2.自定义的 断点式生成  </span></span><br><span class="line">                .&lt;WaterSensor&gt;forGenerator(ctx -&gt; <span class="keyword">new</span> <span class="title class_">MyPuntuatedWatermarkGenerator</span>&lt;&gt;(<span class="number">3000L</span>))  </span><br><span class="line">                .withTimestampAssigner(  </span><br><span class="line">                        (element, recordTimestamp) -&gt; &#123;  </span><br><span class="line">                            <span class="keyword">return</span> element.getTs() * <span class="number">1000L</span>;  </span><br><span class="line">                        &#125;);  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;WaterSensor&gt; sensorDSwithWatermark = sensorDS.assignTimestampsAndWatermarks(watermarkStrategy);  </span><br><span class="line">  </span><br><span class="line">        sensorDSwithWatermark.keyBy(sensor -&gt; sensor.getId())  </span><br><span class="line">                .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))  </span><br><span class="line">                .process(  </span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ProcessWindowFunction</span>&lt;WaterSensor, String, String, TimeWindow&gt;() &#123;  </span><br><span class="line">  </span><br><span class="line">                            <span class="meta">@Override</span>  </span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String s, Context context, Iterable&lt;WaterSensor&gt; elements, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                                <span class="type">long</span> <span class="variable">startTs</span> <span class="operator">=</span> context.window().getStart();  </span><br><span class="line">                                <span class="type">long</span> <span class="variable">endTs</span> <span class="operator">=</span> context.window().getEnd();  </span><br><span class="line">                                <span class="type">String</span> <span class="variable">windowStart</span> <span class="operator">=</span> DateFormatUtils.format(startTs, <span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);  </span><br><span class="line">                                <span class="type">String</span> <span class="variable">windowEnd</span> <span class="operator">=</span> DateFormatUtils.format(endTs, <span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">                                <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> elements.spliterator().estimateSize();  </span><br><span class="line">  </span><br><span class="line">                                out.collect(<span class="string">&quot;key=&quot;</span> + s + <span class="string">&quot;的窗口[&quot;</span> + windowStart + <span class="string">&quot;,&quot;</span> + windowEnd + <span class="string">&quot;)包含&quot;</span> + count + <span class="string">&quot;条数据===&gt;&quot;</span> + elements.toString());  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                )  </span><br><span class="line">                .print();  </span><br><span class="line">  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在数据源中发送水位线</li>
</ul>
<p>也可以在自定义的数据源中抽取事件时间，然后发送水位线。这里要注意的是，在自定义数据源中发送了水位线以后，就不能再在程序中使用assignTimestampsAndWatermarks方法来生成水位线了。在自定义数据源中生成水位线和在程序中使用assignTimestampsAndWatermarks方法生成水位线二者只能取其一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env.fromSource(kafkaSource, WatermarkStrategy.forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">3</span>)), <span class="string">&quot;kafkasource&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="5-2-6-水位线的传递"><a href="#5-2-6-水位线的传递" class="headerlink" title="5.2.6 水位线的传递"></a>5.2.6 水位线的传递</h3><p>在流处理中，上游任务处理完水位线、时钟改变之后，要把当前的水位线再次发出，广播给所有的下游子任务。而当一个任务接收到多个上游并行任务传递来的水位线时，应该以最小的那个作为当前任务的事件时钟。</p>
<p>水位线在上下游任务之间的传递，非常巧妙地避免了分布式系统中没有统一时钟的问题，每个任务都以“处理完之前所有数据”为标准来确定自己的时钟。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240109163531.png"></p>
<p>一个任务接收多个上游并行任务传递时，取最小的那个水位线，但是如果其中一个水位线一直不更新，则一直处在最小，下游任务则一直无法触发窗口，针对这种情况，需要设置空闲等待时间（如果上游任务长时间没有更新水位线，下游则不会再参考此任务的水位线最小值）。</p>
<p><strong>代码示例：</strong> 并行度为2，有两个map算子，自定义分区以输入数据奇偶数，若只输入 奇数，偶数分区则长时间不会更新水位线，设置空闲等待时间 5s<br><strong>自定义分区：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.partition;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.Partitioner;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPartitioner</span> <span class="keyword">implements</span> <span class="title class_">Partitioner</span>&lt;String&gt; &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(String key, <span class="type">int</span> numPartitions)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(key) % numPartitions;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.watermark;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.bean.WaterSensor;  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.functions.WaterSensorMapFunction;  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.partition.MyPartitioner;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateFormatUtils;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkStrategy;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.windowing.ProcessWindowFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.TimeWindow;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.time.Duration;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WatermarkIdlenessDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">  </span><br><span class="line">        env.setParallelism(<span class="number">2</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 自定义分区器：数据%分区数，只输入奇数，都只会去往map的一个子任务  </span></span><br><span class="line">        SingleOutputStreamOperator&lt;Integer&gt; socketDS = env  </span><br><span class="line">                .socketTextStream(<span class="string">&quot;hadoop102&quot;</span>, <span class="number">7777</span>)  </span><br><span class="line">                .partitionCustom(<span class="keyword">new</span> <span class="title class_">MyPartitioner</span>(), r -&gt; r)  </span><br><span class="line">                .map(r -&gt; Integer.parseInt(r))  </span><br><span class="line">                .assignTimestampsAndWatermarks(  </span><br><span class="line">                        WatermarkStrategy  </span><br><span class="line">                                .&lt;Integer&gt;forMonotonousTimestamps()  </span><br><span class="line">                                .withTimestampAssigner((r, ts) -&gt; r * <span class="number">1000L</span>)  </span><br><span class="line">                                .withIdleness(Duration.ofSeconds(<span class="number">5</span>))  <span class="comment">//空闲等待5s  </span></span><br><span class="line">                );  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 分成两组： 奇数一组，偶数一组 ， 开10s的事件时间滚动窗口  </span></span><br><span class="line">        socketDS  </span><br><span class="line">                .keyBy(r -&gt; r % <span class="number">2</span>)  </span><br><span class="line">                .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))  </span><br><span class="line">                .process(<span class="keyword">new</span> <span class="title class_">ProcessWindowFunction</span>&lt;Integer, String, Integer, TimeWindow&gt;() &#123;  </span><br><span class="line">                    <span class="meta">@Override</span>  </span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Integer integer, Context context, Iterable&lt;Integer&gt; elements, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                        <span class="type">long</span> <span class="variable">startTs</span> <span class="operator">=</span> context.window().getStart();  </span><br><span class="line">                        <span class="type">long</span> <span class="variable">endTs</span> <span class="operator">=</span> context.window().getEnd();  </span><br><span class="line">                        <span class="type">String</span> <span class="variable">windowStart</span> <span class="operator">=</span> DateFormatUtils.format(startTs, <span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);  </span><br><span class="line">                        <span class="type">String</span> <span class="variable">windowEnd</span> <span class="operator">=</span> DateFormatUtils.format(endTs, <span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">                        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> elements.spliterator().estimateSize();  </span><br><span class="line">  </span><br><span class="line">                        out.collect(<span class="string">&quot;key=&quot;</span> + integer + <span class="string">&quot;的窗口[&quot;</span> + windowStart + <span class="string">&quot;,&quot;</span> + windowEnd + <span class="string">&quot;)包含&quot;</span> + count + <span class="string">&quot;条数据===&gt;&quot;</span> + elements.toString());  </span><br><span class="line">  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;)  </span><br><span class="line">                .print();  </span><br><span class="line">  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-7-迟到数据的处理"><a href="#5-2-7-迟到数据的处理" class="headerlink" title="5.2.7 迟到数据的处理"></a>5.2.7 迟到数据的处理</h3><ul>
<li><p>乱序等待时间：<br>在水印（watermark）产生时，设置一个乱序容忍度，推迟系统时间的推进，保证窗口计算被延迟执行，为乱序的数据争取更多的时间进入窗口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WatermarkStrategy.forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>窗口延迟关闭<br>Flink的窗口，也允许迟到数据。当触发了窗口计算后，会先计算当前的结果，但是此时并不会关闭窗口。</p>
</li>
</ul>
<p>以后每来一条迟到数据，就触发一次这条数据所在窗口计算(增量计算)。直到wartermark 超过了窗口结束时间+推迟时间，此时窗口会真正关闭。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)))  </span><br><span class="line">.allowedLateness(Time.seconds(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不会延迟窗口计算时间，只会延迟窗口关闭时间，只能运用在 eventtime 上。</p>
</blockquote>
<p><strong>使用侧输出流接收迟到的数据</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.watermark;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.bean.WaterSensor;  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.functions.WaterSensorMapFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateFormatUtils;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkStrategy;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.Types;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.windowing.ProcessWindowFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.TimeWindow;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.OutputTag;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.time.Duration;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WatermarkLateDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;WaterSensor&gt; sensorDS = env  </span><br><span class="line">                .socketTextStream(<span class="string">&quot;hadoop102&quot;</span>, <span class="number">7777</span>)  </span><br><span class="line">                .map(<span class="keyword">new</span> <span class="title class_">WaterSensorMapFunction</span>());  </span><br><span class="line">  </span><br><span class="line">        WatermarkStrategy&lt;WaterSensor&gt; watermarkStrategy = WatermarkStrategy  </span><br><span class="line">                .&lt;WaterSensor&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">3</span>))  </span><br><span class="line">                .withTimestampAssigner((element, recordTimestamp) -&gt; element.getTs() * <span class="number">1000L</span>);  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;WaterSensor&gt; sensorDSwithWatermark = sensorDS.assignTimestampsAndWatermarks(watermarkStrategy);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        OutputTag&lt;WaterSensor&gt; lateTag = <span class="keyword">new</span> <span class="title class_">OutputTag</span>&lt;&gt;(<span class="string">&quot;late-data&quot;</span>, Types.POJO(WaterSensor.class));  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; process = sensorDSwithWatermark.keyBy(sensor -&gt; sensor.getId())  </span><br><span class="line">                .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))  </span><br><span class="line">                .allowedLateness(Time.seconds(<span class="number">2</span>)) <span class="comment">// 推迟2s关窗  </span></span><br><span class="line">                .sideOutputLateData(lateTag) <span class="comment">// 关窗后的迟到数据，放入侧输出流  </span></span><br><span class="line">                .process(  </span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ProcessWindowFunction</span>&lt;WaterSensor, String, String, TimeWindow&gt;() &#123;  </span><br><span class="line">  </span><br><span class="line">                            <span class="meta">@Override</span>  </span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String s, Context context, Iterable&lt;WaterSensor&gt; elements, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                                <span class="type">long</span> <span class="variable">startTs</span> <span class="operator">=</span> context.window().getStart();  </span><br><span class="line">                                <span class="type">long</span> <span class="variable">endTs</span> <span class="operator">=</span> context.window().getEnd();  </span><br><span class="line">                                <span class="type">String</span> <span class="variable">windowStart</span> <span class="operator">=</span> DateFormatUtils.format(startTs, <span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);  </span><br><span class="line">                                <span class="type">String</span> <span class="variable">windowEnd</span> <span class="operator">=</span> DateFormatUtils.format(endTs, <span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">                                <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> elements.spliterator().estimateSize();  </span><br><span class="line">  </span><br><span class="line">                                out.collect(<span class="string">&quot;key=&quot;</span> + s + <span class="string">&quot;的窗口[&quot;</span> + windowStart + <span class="string">&quot;,&quot;</span> + windowEnd + <span class="string">&quot;)包含&quot;</span> + count + <span class="string">&quot;条数据===&gt;&quot;</span> + elements.toString());  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                );  </span><br><span class="line">  </span><br><span class="line">        process.print();  </span><br><span class="line">        <span class="comment">// 从主流获取侧输出流，打印  </span></span><br><span class="line">        process.getSideOutput(lateTag).printToErr(<span class="string">&quot;关窗后的迟到数据&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>乱序与迟到的区别<ol>
<li>乱序：数据的顺序乱了，时间小的 比 时间大的 晚来</li>
<li>迟到：数据的时间戳 &lt; 当前的 watermark</li>
</ol>
</li>
<li>窗口延迟关闭：在关窗之前，迟到的数据来了，还能被窗口计算，来一条迟到数据触发一次计算。关窗后，迟到的数据不会被计算， 关窗后的迟到数据，可以放入侧输出流。</li>
<li>为什么不直接把 watermark等待时间设置长些，而是设置允许迟到时间：<ol>
<li>watermark 等待时间一般不会设太大，否则会影响计算延迟</li>
<li>设置窗口延迟关闭，不影响计算延迟，而且可以尽量让结果准确</li>
</ol>
</li>
<li>设置经验：<ol>
<li>watermark等待时间：设置不算大的，一般秒级</li>
<li>设置一定的窗口延迟关闭，只考虑大部分的迟到数据，极端小部分迟到很久的数据不管。</li>
<li>极端小部分迟到很久的数据，放到侧输出流，可以针对性做其他处理</li>
</ol>
</li>
</ol>
<h2 id="5-3-基于时间的合流（双流联结join）"><a href="#5-3-基于时间的合流（双流联结join）" class="headerlink" title="5.3 基于时间的合流（双流联结join）"></a>5.3 基于时间的合流（双流联结join）</h2><h3 id="5-3-1-窗口联结（Window-Join）"><a href="#5-3-1-窗口联结（Window-Join）" class="headerlink" title="5.3.1 窗口联结（Window Join）"></a>5.3.1 窗口联结（Window Join）</h3><p>窗口联结在代码中的实现，首先需要调用DataStream的.join()方法来合并两条流，得到一个JoinedStreams；接着通过.where()和.equalTo()方法指定两条流中联结的key；然后通过.window()开窗口，并调用.apply()传入联结窗口函数进行处理计算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stream1.join(stream2)</span><br><span class="line">        .where(&lt;KeySelector&gt;)</span><br><span class="line">        .equalTo(&lt;KeySelector&gt;)</span><br><span class="line">        .window(&lt;WindowAssigner&gt;)</span><br><span class="line">        .apply(&lt;JoinFunction&gt;)</span><br></pre></td></tr></table></figure>
<p>上面代码中.where()的参数是键选择器（KeySelector），用来指定第一条流中的key；而.equalTo()传入的KeySelector则指定了第二条流中的key。两者相同的元素，如果在同一窗口中，就可以匹配起来，并通过一个“联结函数”（JoinFunction）进行处理了。<br>这里.window()传入的就是窗口分配器，之前讲到的三种时间窗口都可以用在这里：滚动窗口（tumbling window）、滑动窗口（sliding window）和会话窗口（session window）。<br>而后面调用.apply()可以看作实现了一个特殊的窗口函数。注意这里只能调用.apply()，没有其他替代的方法。<br>传入的JoinFunction也是一个函数类接口，使用时需要实现内部的.join()方法。这个方法有两个参数，分别表示两条流中成对匹配的数据。<br>其实仔细观察可以发现，窗口join的调用语法和我们熟悉的SQL中表的join非常相似：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 t1, table2 t2 <span class="keyword">WHERE</span> t1.id <span class="operator">=</span> t2.id;</span><br></pre></td></tr></table></figure>
<p>这句SQL中where子句的表达，等价于inner join … on，所以本身表示的是两张表基于id的“内连接”（inner join）。而Flink中的window join，同样类似于inner join。也就是说，最后处理输出的，只有两条流中数据按key配对成功的那些；如果某个窗口中一条流的数据没有任何另一条流的数据匹配，那么就不会调用JoinFunction的.join()方法，也就没有任何输出了。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.watermark;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkStrategy;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.JoinFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple3;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowJoinDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; ds1 = env  </span><br><span class="line">                .fromElements(  </span><br><span class="line">                        Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>),  </span><br><span class="line">                        Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">2</span>),  </span><br><span class="line">                        Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">3</span>),  </span><br><span class="line">                        Tuple2.of(<span class="string">&quot;c&quot;</span>, <span class="number">4</span>)  </span><br><span class="line">                )  </span><br><span class="line">                .assignTimestampsAndWatermarks(  </span><br><span class="line">                        WatermarkStrategy  </span><br><span class="line">                                .&lt;Tuple2&lt;String, Integer&gt;&gt;forMonotonousTimestamps()  </span><br><span class="line">                                .withTimestampAssigner((value, ts) -&gt; value.f1 * <span class="number">1000L</span>)  </span><br><span class="line">                );  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple3&lt;String, Integer,Integer&gt;&gt; ds2 = env  </span><br><span class="line">                .fromElements(  </span><br><span class="line">                        Tuple3.of(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>,<span class="number">1</span>),  </span><br><span class="line">                        Tuple3.of(<span class="string">&quot;a&quot;</span>, <span class="number">11</span>,<span class="number">1</span>),  </span><br><span class="line">                        Tuple3.of(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>,<span class="number">1</span>),  </span><br><span class="line">                        Tuple3.of(<span class="string">&quot;b&quot;</span>, <span class="number">12</span>,<span class="number">1</span>),  </span><br><span class="line">                        Tuple3.of(<span class="string">&quot;c&quot;</span>, <span class="number">14</span>,<span class="number">1</span>),  </span><br><span class="line">                        Tuple3.of(<span class="string">&quot;d&quot;</span>, <span class="number">15</span>,<span class="number">1</span>)  </span><br><span class="line">                )  </span><br><span class="line">                .assignTimestampsAndWatermarks(  </span><br><span class="line">                        WatermarkStrategy  </span><br><span class="line">                                .&lt;Tuple3&lt;String, Integer,Integer&gt;&gt;forMonotonousTimestamps()  </span><br><span class="line">                                .withTimestampAssigner((value, ts) -&gt; value.f1 * <span class="number">1000L</span>)  </span><br><span class="line">                );  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// TODO window join  </span></span><br><span class="line">        <span class="comment">// 1. 落在同一个时间窗口范围内才能匹配  </span></span><br><span class="line">        <span class="comment">// 2. 根据keyby的key，来进行匹配关联  </span></span><br><span class="line">        <span class="comment">// 3. 只能拿到匹配上的数据，类似有固定时间范围的inner join  </span></span><br><span class="line">        DataStream&lt;String&gt; join = ds1.join(ds2)  </span><br><span class="line">                .where(r1 -&gt; r1.f0)  <span class="comment">// ds1的keyby  </span></span><br><span class="line">                .equalTo(r2 -&gt; r2.f0) <span class="comment">// ds2的keyby  </span></span><br><span class="line">                .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))  </span><br><span class="line">                .apply(<span class="keyword">new</span> <span class="title class_">JoinFunction</span>&lt;Tuple2&lt;String, Integer&gt;, Tuple3&lt;String, Integer, Integer&gt;, String&gt;() &#123;  </span><br><span class="line">                    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">                     * 关联上的数据，调用join方法  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> first  ds1的数据  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> second ds2的数据  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Exception  </span></span><br><span class="line"><span class="comment">                     */</span>  </span><br><span class="line">                    <span class="meta">@Override</span>  </span><br><span class="line">                    <span class="keyword">public</span> String <span class="title function_">join</span><span class="params">(Tuple2&lt;String, Integer&gt; first, Tuple3&lt;String, Integer, Integer&gt; second)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                        <span class="keyword">return</span> first + <span class="string">&quot;&lt;-----&gt;&quot;</span> + second;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;);  </span><br><span class="line">  </span><br><span class="line">        join.print();  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a,1)&lt;-----&gt;(a,1,1)</span><br><span class="line">(a,2)&lt;-----&gt;(a,1,1)</span><br><span class="line">(b,3)&lt;-----&gt;(b,2,1)</span><br></pre></td></tr></table></figure>

<h3 id="5-3-2-间隔联结（Interval-Join）"><a href="#5-3-2-间隔联结（Interval-Join）" class="headerlink" title="5.3.2 间隔联结（Interval Join）"></a>5.3.2 间隔联结（Interval Join）</h3><ul>
<li>原理</li>
</ul>
<p>间隔联结具体的定义方式是，我们给定两个时间点，分别叫作间隔的“上界”（upperBound）和“下界”（lowerBound）；于是对于一条流（不妨叫作A）中的任意一个数据元素a，就可以开辟一段时间间隔：<code>[a.timestamp + lowerBound, a.timestamp + upperBound]</code>,即以a的时间戳为中心，下至下界点、上至上界点的一个闭区间：我们就把这段时间作为可以匹配另一条流数据的“窗口”范围。所以对于另一条流（不妨叫B）中的数据元素b，如果它的时间戳落在了这个区间范围内，a和b就可以成功配对，进而进行计算输出结果。所以匹配的条件为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.timestamp + lowerBound &lt;= b.timestamp &lt;= a.timestamp + upperBound</span><br></pre></td></tr></table></figure>
<p>做间隔联结的两条流A和B，也必须基于相同的key；下界lowerBound应该小于等于上界upperBound，两者都可正可负；间隔联结目前只支持事件时间语义。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240110094819.png"></p>
<p>下方的流A去间隔联结上方的流B，所以基于A的每个数据元素，都可以开辟一个间隔区间。我们这里设置下界为-2毫秒，上界为1毫秒。于是对于时间戳为2的A中元素，它的可匹配区间就是[0, 3],流B中有时间戳为0、1的两个元素落在这个范围内，所以就可以得到匹配数据对（2, 0）和（2, 1）。同样地，A中时间戳为3的元素，可匹配区间为[1, 4]，B中只有时间戳为1的一个数据可以匹配，于是得到匹配数据对（3, 1）。</p>
<blockquote>
<p>间隔联结同样是一种内连接（inner join）。与窗口联结不同的是，interval join做匹配的时间段是基于流中数据的，所以并不确定；而且流B中的数据可以不只在一个区间内被匹配。</p>
</blockquote>
<ul>
<li>示例</li>
</ul>
<p>间隔联结在代码中，是基于KeyedStream的联结（join）操作。DataStream在keyBy得到KeyedStream之后，可以调用.intervalJoin()来合并两条流，传入的参数同样是一个KeyedStream，两者的key类型应该一致；得到的是一个IntervalJoin类型。后续的操作同样是完全固定的：先通过.between()方法指定间隔的上下界，再调用.process()方法，定义对匹配数据对的处理操作。调用.process()需要传入一个处理函数，这是处理函数家族的最后一员：“处理联结函数”ProcessJoinFunction。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stream1</span><br><span class="line">    .keyBy(&lt;KeySelector&gt;)</span><br><span class="line">    .intervalJoin(stream2.keyBy(&lt;KeySelector&gt;))</span><br><span class="line">    .between(Time.milliseconds(-<span class="number">2</span>), Time.milliseconds(<span class="number">1</span>))</span><br><span class="line">    .process (<span class="keyword">new</span> <span class="title class_">ProcessJoinFunction</span>&lt;Integer, Integer, String()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElement</span><span class="params">(Integer left, Integer right, Context ctx, Collector&lt;String&gt; out)</span> &#123;</span><br><span class="line">            out.collect(left + <span class="string">&quot;,&quot;</span> + right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>抽象类ProcessJoinFunction就像是ProcessFunction和JoinFunction的结合，内部同样有一个抽象方法.processElement()。与其他处理函数不同的是，它多了一个参数，这自然是因为有来自两条流的数据。参数中left指的就是第一条流中的数据，right则是第二条流中与它匹配的数据。每当检测到一组匹配，就会调用这里的.processElement()方法，经处理转换之后输出结果。</p>
<blockquote>
<p>应用案例：在电商网站中，某些用户行为往往会有短时间内的强关联。我们这里举一个例子，我们有两条流，一条是下订单的流，一条是浏览数据的流。我们可以针对同一个用户，来做这样一个联结。也就是使用一个用户的下订单的事件和这个用户的最近十分钟的浏览数据进行一个联结查询。</p>
</blockquote>
<p><strong>代码案例：</strong> 两条流，进行 IntervalJoin，输出 迟到流数据和联结数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.watermark;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkStrategy;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.MapFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.Types;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple3;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.KeyedStream;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.co.ProcessJoinFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.OutputTag;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.time.Duration;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntervalJoinWithLateDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; ds1 = env  </span><br><span class="line">                .socketTextStream(<span class="string">&quot;10.211.55.4&quot;</span>, <span class="number">7777</span>)  </span><br><span class="line">                .map(<span class="keyword">new</span> <span class="title class_">MapFunction</span>&lt;String, Tuple2&lt;String, Integer&gt;&gt;() &#123;  </span><br><span class="line">                    <span class="meta">@Override</span>  </span><br><span class="line">                    <span class="keyword">public</span> Tuple2&lt;String, Integer&gt; <span class="title function_">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                        String[] datas = value.split(<span class="string">&quot;,&quot;</span>);  </span><br><span class="line">                        <span class="keyword">return</span> Tuple2.of(datas[<span class="number">0</span>], Integer.valueOf(datas[<span class="number">1</span>]));  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;)  </span><br><span class="line">                .assignTimestampsAndWatermarks(  </span><br><span class="line">                        WatermarkStrategy  </span><br><span class="line">                                .&lt;Tuple2&lt;String, Integer&gt;&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">3</span>))  </span><br><span class="line">                                .withTimestampAssigner((value, ts) -&gt; value.f1 * <span class="number">1000L</span>)  </span><br><span class="line">                );  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple3&lt;String, Integer, Integer&gt;&gt; ds2 = env  </span><br><span class="line">                .socketTextStream(<span class="string">&quot;10.211.55.4&quot;</span>, <span class="number">8888</span>)  </span><br><span class="line">                .map(<span class="keyword">new</span> <span class="title class_">MapFunction</span>&lt;String, Tuple3&lt;String, Integer, Integer&gt;&gt;() &#123;  </span><br><span class="line">                    <span class="meta">@Override</span>  </span><br><span class="line">                    <span class="keyword">public</span> Tuple3&lt;String, Integer, Integer&gt; <span class="title function_">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                        String[] datas = value.split(<span class="string">&quot;,&quot;</span>);  </span><br><span class="line">                        <span class="keyword">return</span> Tuple3.of(datas[<span class="number">0</span>], Integer.valueOf(datas[<span class="number">1</span>]), Integer.valueOf(datas[<span class="number">2</span>]));  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;)  </span><br><span class="line">                .assignTimestampsAndWatermarks(  </span><br><span class="line">                        WatermarkStrategy  </span><br><span class="line">                                .&lt;Tuple3&lt;String, Integer, Integer&gt;&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">3</span>))  </span><br><span class="line">                                .withTimestampAssigner((value, ts) -&gt; value.f1 * <span class="number">1000L</span>)  </span><br><span class="line">                );  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/**  </span></span><br><span class="line"><span class="comment">         * TODO Interval join  </span></span><br><span class="line"><span class="comment">         * 1、只支持事件时间  </span></span><br><span class="line"><span class="comment">         * 2、指定上界、下界的偏移，负号代表时间往前，正号代表时间往后  </span></span><br><span class="line"><span class="comment">         * 3、process中，只能处理 join上的数据  </span></span><br><span class="line"><span class="comment">         * 4、两条流关联后的watermark，以两条流中最小的为准  </span></span><br><span class="line"><span class="comment">         * 5、如果 当前数据的事件时间 &lt; 当前的watermark，就是迟到数据， 主流的process不处理  </span></span><br><span class="line"><span class="comment">         *  =&gt; between后，可以指定将 左流 或 右流 的迟到数据 放入侧输出流  </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//1. 分别做keyby，key其实就是关联条件  </span></span><br><span class="line">        KeyedStream&lt;Tuple2&lt;String, Integer&gt;, String&gt; ks1 = ds1.keyBy(r1 -&gt; r1.f0);  </span><br><span class="line">        KeyedStream&lt;Tuple3&lt;String, Integer, Integer&gt;, String&gt; ks2 = ds2.keyBy(r2 -&gt; r2.f0);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//2. 调用 interval join        OutputTag&lt;Tuple2&lt;String, Integer&gt;&gt; ks1LateTag = new OutputTag&lt;&gt;(&quot;ks1-late&quot;, Types.TUPLE(Types.STRING, Types.INT));  </span></span><br><span class="line">        OutputTag&lt;Tuple3&lt;String, Integer, Integer&gt;&gt; ks2LateTag = <span class="keyword">new</span> <span class="title class_">OutputTag</span>&lt;&gt;(<span class="string">&quot;ks2-late&quot;</span>, Types.TUPLE(Types.STRING, Types.INT, Types.INT));  </span><br><span class="line">          </span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; process = ks1.intervalJoin(ks2)  </span><br><span class="line">                .between(Time.seconds(-<span class="number">2</span>), Time.seconds(<span class="number">2</span>))  </span><br><span class="line">                .sideOutputLeftLateData(ks1LateTag)  <span class="comment">// 将 ks1的迟到数据，放入侧输出流  </span></span><br><span class="line">                .sideOutputRightLateData(ks2LateTag) <span class="comment">// 将 ks2的迟到数据，放入侧输出流  </span></span><br><span class="line">                .process(  </span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ProcessJoinFunction</span>&lt;Tuple2&lt;String, Integer&gt;, Tuple3&lt;String, Integer, Integer&gt;, String&gt;() &#123;  </span><br><span class="line">                            <span class="comment">/**  </span></span><br><span class="line"><span class="comment">                             * 两条流的数据匹配上，才会调用这个方法  </span></span><br><span class="line"><span class="comment">                             * <span class="doctag">@param</span> left  ks1的数据  </span></span><br><span class="line"><span class="comment">                             * <span class="doctag">@param</span> right ks2的数据  </span></span><br><span class="line"><span class="comment">                             * <span class="doctag">@param</span> ctx   上下文  </span></span><br><span class="line"><span class="comment">                             * <span class="doctag">@param</span> out   采集器  </span></span><br><span class="line"><span class="comment">                             * <span class="doctag">@throws</span> Exception  </span></span><br><span class="line"><span class="comment">                             */</span>  </span><br><span class="line">                            <span class="meta">@Override</span>  </span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElement</span><span class="params">(Tuple2&lt;String, Integer&gt; left, Tuple3&lt;String, Integer, Integer&gt; right, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                                <span class="comment">// 进入这个方法，是关联上的数据  </span></span><br><span class="line">                                out.collect(left + <span class="string">&quot;&lt;------&gt;&quot;</span> + right);  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;);  </span><br><span class="line">  </span><br><span class="line">        process.print(<span class="string">&quot;主流&quot;</span>);  </span><br><span class="line">        process.getSideOutput(ks1LateTag).printToErr(<span class="string">&quot;ks1迟到数据&quot;</span>);  </span><br><span class="line">        process.getSideOutput(ks2LateTag).printToErr(<span class="string">&quot;ks2迟到数据&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输入如下：</strong><br>stream1：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1,2  </span><br><span class="line">s1,10  <span class="comment"># watermark 到 7</span></span><br><span class="line">s1,3   </span><br><span class="line">s1,4  <span class="comment"># 迟到数据</span></span><br></pre></td></tr></table></figure>
<p>stream2：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1,2,2</span><br><span class="line">s1,2,3   </span><br><span class="line">s1,10,22 <span class="comment"># watermark 到 7</span></span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">主流&gt; (s1,2)&lt;------&gt;(s1,2,2)</span><br><span class="line">主流&gt; (s1,2)&lt;------&gt;(s1,2,3)</span><br><span class="line">主流&gt; (s1,3)&lt;------&gt;(s1,2,2)</span><br><span class="line">主流&gt; (s1,3)&lt;------&gt;(s1,2,3)</span><br><span class="line">主流&gt; (s1,10)&lt;------&gt;(s1,10,22)</span><br><span class="line">ks1迟到数据&gt; (s1,4) <span class="comment"># watermark 到 7 后stream1输入，迟到数据</span></span><br></pre></td></tr></table></figure>

<h1 id="6-处理函数"><a href="#6-处理函数" class="headerlink" title="6 处理函数"></a>6 处理函数</h1><h2 id="6-1-基本处理函数（ProcessFunction）"><a href="#6-1-基本处理函数（ProcessFunction）" class="headerlink" title="6.1 基本处理函数（ProcessFunction）"></a>6.1 基本处理函数（ProcessFunction）</h2><h3 id="6-1-1-处理函数的功能和作用"><a href="#6-1-1-处理函数的功能和作用" class="headerlink" title="6.1.1 处理函数的功能和作用"></a>6.1.1 处理函数的功能和作用</h3><p>转换算子，一般只是针对某种具体操作来定义的，能够拿到的信息比较有限。如果我们想要访问事件的时间戳，或者当前的水位线信息，都是完全做不到的。跟时间相关的操作，目前我们只会用窗口来处理。而在很多应用需求中，要求我们对时间有更精细的控制，需要能够获取水位线，甚至要“把控时间”、定义什么时候做什么事，这就不是基本的时间窗口能够实现的了。<br>处理函数提供了一个“定时服务”（TimerService），我们可以通过它访问流中的事件（event）、时间戳（timestamp）、水位线（watermark），甚至可以注册“定时事件”。而且处理函数继承了AbstractRichFunction抽象类，所以拥有富函数类的所有特性，同样可以访问状态（state）和其他运行时信息。此外，处理函数还可以直接将数据输出到侧输出流（side output）中。所以，处理函数是最为灵活的处理方法，可以实现各种自定义的业务逻辑。<br>处理函数的使用与基本的转换操作类似，只需要直接基于DataStream调用.process()方法就可以了。方法需要传入一个ProcessFunction作为参数，用来定义处理逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.process(<span class="keyword">new</span> <span class="title class_">MyProcessFunction</span>())</span><br></pre></td></tr></table></figure>

<p>这里ProcessFunction不是接口，而是一个抽象类，继承了AbstractRichFunction；MyProcessFunction是它的一个具体实现。所以所有的处理函数，都是富函数（RichFunction），富函数可以调用的东西这里同样都可以调用。</p>
<h3 id="6-1-2-ProcessFunction介绍"><a href="#6-1-2-ProcessFunction介绍" class="headerlink" title="6.1.2 ProcessFunction介绍"></a>6.1.2 ProcessFunction介绍</h3><p>抽象类ProcessFunction继承了AbstractRichFunction，有两个泛型类型参数：I表示Input，也就是输入的数据类型；O表示Output，也就是处理完成之后输出的数据类型。<br>内部单独定义了两个方法：一个是必须要实现的抽象方法.processElement()；另一个是非抽象方法.onTimer()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ProcessFunction</span>&lt;I, O&gt; <span class="keyword">extends</span> <span class="title class_">AbstractRichFunction</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">processElement</span><span class="params">(I value, Context ctx, Collector&lt;O&gt; out)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTimer</span><span class="params">(<span class="type">long</span> timestamp, OnTimerContext ctx, Collector&lt;O&gt; out)</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>抽象方法.processElement()</strong></li>
</ol>
<p>用于“处理元素”，定义了处理的核心逻辑。这个方法对于流中的每个元素都会调用一次，参数包括三个：输入数据值value，上下文ctx，以及“收集器”（Collector）out。方法没有返回值，处理之后的输出数据是通过收集器out来定义的。</p>
<ul>
<li>value：当前流中的输入元素，也就是正在处理的数据，类型与流中数据类型一致。</li>
<li>ctx：类型是ProcessFunction中定义的内部抽象类Context，表示当前运行的上下文，可以获取到当前的时间戳，并提供了用于查询时间和注册定时器的“定时服务”（TimerService），以及可以将数据发送到“侧输出流”（side output）的方法.output()。</li>
<li>out：“收集器”（类型为Collector），用于返回输出数据。使用方式与flatMap算子中的收集器完全一样，直接调用out.collect()方法就可以向下游发出一个数据。这个方法可以多次调用，也可以不调用。</li>
</ul>
<ol start="2">
<li><strong>非抽象方法.onTimer()</strong></li>
</ol>
<p>这个方法只有在注册好的定时器触发的时候才会调用，而定时器是通过“定时服务”TimerService来注册的。打个比方，注册定时器（timer）就是设了一个闹钟，到了设定时间就会响；而.onTimer()中定义的，就是闹钟响的时候要做的事。所以它本质上是一个基于时间的“回调”（callback）方法，通过时间的进展来触发；在事件时间语义下就是由水位线（watermark）来触发了。<br>定时方法.onTimer()也有三个参数：时间戳（timestamp），上下文（ctx），以及收集器（out）。这里的timestamp是指设定好的触发时间，事件时间语义下当然就是水位线了。另外这里同样有上下文和收集器，所以也可以调用定时服务（TimerService），以及任意输出处理之后的数据。</p>
<p>既然有.onTimer()方法做定时触发，我们用ProcessFunction也可以自定义数据按照时间分组、定时触发计算输出结果；这其实就实现了窗口（window）的功能。所以说ProcessFunction其实可以实现一切功能。</p>
<blockquote>
<p>在Flink中，只有“按键分区流”KeyedStream才支持设置定时器的操作。</p>
</blockquote>
<h3 id="6-1-3-处理函数的分类"><a href="#6-1-3-处理函数的分类" class="headerlink" title="6.1.3 处理函数的分类"></a>6.1.3 处理函数的分类</h3><p>Flink提供了8个不同的处理函数：<br>（1） ProcessFunction<br>最基本的处理函数，基于DataStream直接调用.process()时作为参数传入。</p>
<p>（2）KeyedProcessFunction</p>
<p>对流按键分区后的处理函数，基于KeyedStream调用.process()时作为参数传入。要想使用定时器，比如基于KeyedStream。</p>
<p>（3）ProcessWindowFunction</p>
<p>开窗之后的处理函数，也是全窗口函数的代表。基于WindowedStream调用.process()时作为参数传入。</p>
<p>（4）ProcessAllWindowFunction</p>
<p>同样是开窗之后的处理函数，基于AllWindowedStream调用.process()时作为参数传入。</p>
<p>（5）CoProcessFunction</p>
<p>合并（connect）两条流之后的处理函数，基于ConnectedStreams调用.process()时作为参数传入。关于流的连接合并操作，我们会在后续章节详细介绍。</p>
<p>（6）ProcessJoinFunction</p>
<p>间隔连接（interval join）两条流之后的处理函数，基于IntervalJoined调用.process()时作为参数传入。</p>
<p>（7）BroadcastProcessFunction</p>
<p>广播连接流处理函数，基于BroadcastConnectedStream调用.process()时作为参数传入。这里的“广播连接流”BroadcastConnectedStream，是一个未keyBy的普通DataStream与一个广播流（BroadcastStream）做连接（conncet）之后的产物。关于广播流的相关操作，我们会在后续章节详细介绍。</p>
<p>（8）KeyedBroadcastProcessFunction</p>
<p>按键分区的广播连接流处理函数，同样是基于BroadcastConnectedStream调用.process()时作为参数传入。与BroadcastProcessFunction不同的是，这时的广播连接流，是一个KeyedStream与广播流（BroadcastStream）做连接之后的产物。</p>
<h2 id="6-2-按键分区处理函数"><a href="#6-2-按键分区处理函数" class="headerlink" title="6.2 按键分区处理函数"></a>6.2 按键分区处理函数</h2><h3 id="6-2-1-定时器（Timer）和定时服务（TimerService）"><a href="#6-2-1-定时器（Timer）和定时服务（TimerService）" class="headerlink" title="6.2.1 定时器（Timer）和定时服务（TimerService）"></a>6.2.1 定时器（Timer）和定时服务（TimerService）</h3><p>在.onTimer()方法中可以实现定时处理的逻辑，而它能触发的前提，就是之前曾经注册过定时器、并且现在已经到了触发时间。注册定时器的功能，是通过上下文中提供的“定时服务”来实现的。</p>
<p>定时服务与当前运行的环境有关。前面已经介绍过，ProcessFunction的上下文（Context）中提供了.timerService()方法，可以直接返回一个TimerService对象。TimerService是Flink关于时间和定时器的基础服务接口，包含以下六个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前的处理时间</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">currentProcessingTime</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前的水位线（事件时间）</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">currentWatermark</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册处理时间定时器，当处理时间超过time时触发</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">registerProcessingTimeTimer</span><span class="params">(<span class="type">long</span> time)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件时间定时器，当水位线超过time时触发</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">registerEventTimeTimer</span><span class="params">(<span class="type">long</span> time)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除触发时间为time的处理时间定时器</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteProcessingTimeTimer</span><span class="params">(<span class="type">long</span> time)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除触发时间为time的处理时间定时器</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteEventTimeTimer</span><span class="params">(<span class="type">long</span> time)</span>;</span><br></pre></td></tr></table></figure>
<p>分为两大类：基于处理时间和基于事件时间<br>对应操作有三个：获取当前时间、注册定时器、删除定时器</p>
<blockquote>
<p>尽管处理函数中都可以直接访问TimerService，不过只有基于KeyedStream的处理函数，才能去调用注册和删除定时器的方法；未作按键分区的DataStream不支持定时器操作，只能获取当前时间。</p>
</blockquote>
<p>TimerService会以键（key）和时间戳为标准，对定时器进行去重；也就是说对于每个key和时间戳，最多只有一个定时器，如果注册了多次，onTimer()方法也将只被调用一次。</p>
<h3 id="6-2-2-KeyedProcessFunction案例"><a href="#6-2-2-KeyedProcessFunction案例" class="headerlink" title="6.2.2 KeyedProcessFunction案例"></a>6.2.2 KeyedProcessFunction案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.process;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.bean.WaterSensor;  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.functions.WaterSensorMapFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateFormatUtils;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkStrategy;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.TimerService;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.KeyedStream;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.KeyedProcessFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.windowing.ProcessWindowFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.TimeWindow;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.time.Duration;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KeyedProcessTimerDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;WaterSensor&gt; sensorDS = env  </span><br><span class="line">                .socketTextStream(<span class="string">&quot;hadoop102&quot;</span>, <span class="number">7777</span>)  </span><br><span class="line">                .map(<span class="keyword">new</span> <span class="title class_">WaterSensorMapFunction</span>())  </span><br><span class="line">                .assignTimestampsAndWatermarks(  </span><br><span class="line">                        WatermarkStrategy  </span><br><span class="line">                                .&lt;WaterSensor&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">3</span>))  </span><br><span class="line">                                .withTimestampAssigner((element, ts) -&gt; element.getTs() * <span class="number">1000L</span>)  </span><br><span class="line">                );  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        KeyedStream&lt;WaterSensor, String&gt; sensorKS = sensorDS.keyBy(sensor -&gt; sensor.getId());  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// TODO Process:keyed  </span></span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; process = sensorKS.process(  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">KeyedProcessFunction</span>&lt;String, WaterSensor, String&gt;() &#123;  </span><br><span class="line">                    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">                     * 来一条数据调用一次  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> value  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> ctx  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> out  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Exception  </span></span><br><span class="line"><span class="comment">                     */</span>  </span><br><span class="line">                    <span class="meta">@Override</span>  </span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElement</span><span class="params">(WaterSensor value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                        <span class="comment">//获取当前数据的key  </span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">currentKey</span> <span class="operator">=</span> ctx.getCurrentKey();  </span><br><span class="line">  </span><br><span class="line">                        <span class="comment">// TODO 1.定时器注册  </span></span><br><span class="line">                        <span class="type">TimerService</span> <span class="variable">timerService</span> <span class="operator">=</span> ctx.timerService();  </span><br><span class="line">  </span><br><span class="line">                        <span class="comment">// 1、事件时间的案例  </span></span><br><span class="line">                        <span class="type">Long</span> <span class="variable">currentEventTime</span> <span class="operator">=</span> ctx.timestamp(); <span class="comment">// 数据中提取出来的事件时间  </span></span><br><span class="line">                        timerService.registerEventTimeTimer(<span class="number">5000L</span>);  </span><br><span class="line">                        System.out.println(<span class="string">&quot;当前key=&quot;</span> + currentKey + <span class="string">&quot;,当前时间=&quot;</span> + currentEventTime + <span class="string">&quot;,注册了一个5s的定时器&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">                        <span class="comment">// 2、处理时间的案例  </span></span><br><span class="line"><span class="comment">//                        long currentTs = timerService.currentProcessingTime();  </span></span><br><span class="line"><span class="comment">//                        timerService.registerProcessingTimeTimer(currentTs + 5000L);  </span></span><br><span class="line"><span class="comment">//                        System.out.println(&quot;当前key=&quot; + currentKey + &quot;,当前时间=&quot; + currentTs + &quot;,注册了一个5s后的定时器&quot;);  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">                        <span class="comment">// 3、获取 process的 当前watermark  </span></span><br><span class="line"><span class="comment">//                        long currentWatermark = timerService.currentWatermark();  </span></span><br><span class="line"><span class="comment">//                        System.out.println(&quot;当前数据=&quot; + value + &quot;,当前watermark=&quot; + currentWatermark);  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">                        <span class="comment">// 注册定时器： 处理时间、事件时间  </span></span><br><span class="line"><span class="comment">//                        timerService.registerProcessingTimeTimer();  </span></span><br><span class="line"><span class="comment">//                        timerService.registerEventTimeTimer();  </span></span><br><span class="line">                        <span class="comment">// 删除定时器： 处理时间、事件时间  </span></span><br><span class="line"><span class="comment">//                        timerService.deleteEventTimeTimer();  </span></span><br><span class="line"><span class="comment">//                        timerService.deleteProcessingTimeTimer();  </span></span><br><span class="line">  </span><br><span class="line">                        <span class="comment">// 获取当前时间进展： 处理时间-当前系统时间，  事件时间-当前watermark  </span></span><br><span class="line"><span class="comment">//                        long currentTs = timerService.currentProcessingTime();  </span></span><br><span class="line"><span class="comment">//                        long wm = timerService.currentWatermark();  </span></span><br><span class="line">                    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">                    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">                     * TODO 2.时间进展到定时器注册的时间，调用该方法  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> timestamp 当前时间进展，就是定时器被触发时的时间  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> ctx       上下文  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> out       采集器  </span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Exception  </span></span><br><span class="line"><span class="comment">                     */</span>  </span><br><span class="line">                    <span class="meta">@Override</span>  </span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTimer</span><span class="params">(<span class="type">long</span> timestamp, OnTimerContext ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                        <span class="built_in">super</span>.onTimer(timestamp, ctx, out);  </span><br><span class="line">                        <span class="type">String</span> <span class="variable">currentKey</span> <span class="operator">=</span> ctx.getCurrentKey();  </span><br><span class="line">  </span><br><span class="line">                        System.out.println(<span class="string">&quot;key=&quot;</span> + currentKey + <span class="string">&quot;现在时间是&quot;</span> + timestamp + <span class="string">&quot;定时器触发&quot;</span>);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        process.print();  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在process中获取当前watermark，显示的是上一次的watermark</li>
<li>事件时间定时器，通过watermark来触发的</li>
</ol>
<h2 id="6-3-窗口处理函数"><a href="#6-3-窗口处理函数" class="headerlink" title="6.3 窗口处理函数"></a>6.3 窗口处理函数</h2><p>进行窗口计算，我们可以直接调用现成的简单聚合方法（sum&#x2F;max&#x2F;min），也可以通过调用.reduce()或.aggregate()来自定义一般的增量聚合函数（ReduceFunction&#x2F;AggregateFucntion）；而对于更加复杂、需要窗口信息和额外状态的一些场景，我们还可以直接使用全窗口函数、把数据全部收集保存在窗口内，等到触发窗口计算时再统一处理。窗口处理函数就是一种典型的全窗口函数。</p>
<p>窗口处理函数ProcessWindowFunction的使用与其他窗口函数类似，也是基于WindowedStream直接调用方法就可以，只不过这时调用的是.process()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy( t -&gt; t.f0 )</span><br><span class="line">        .window( TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)) )</span><br><span class="line">        .process(<span class="keyword">new</span> <span class="title class_">MyProcessWindowFunction</span>())</span><br></pre></td></tr></table></figure>
<p>ProcessWindowFunction既是处理函数又是全窗口函数。从名字上也可以推测出，它的本质似乎更倾向于“窗口函数”一些。事实上它的用法也确实跟其他处理函数有很大不同。我们可以从源码中的定义看到这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ProcessWindowFunction</span>&lt;IN, OUT, KEY, W <span class="keyword">extends</span> <span class="title class_">Window</span>&gt; <span class="keyword">extends</span> <span class="title class_">AbstractRichFunction</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(</span></span><br><span class="line"><span class="params">            KEY key, Context context, Iterable&lt;IN&gt; elements, Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Context</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProcessWindowFunction依然是一个继承了AbstractRichFunction的抽象类，它有四个类型参数：</p>
<ul>
<li>IN：input，数据流中窗口任务的输入数据类型。</li>
<li>OUT：output，窗口任务进行计算之后的输出数据类型。</li>
<li>KEY：数据中键key的类型。</li>
<li>W：窗口的类型，是Window的子类型。一般情况下我们定义时间窗口，W就是TimeWindow。</li>
</ul>
<p>ProcessWindowFunction里面处理数据的核心方法.process()。方法包含四个参数。</p>
<ul>
<li>key：窗口做统计计算基于的键，也就是之前keyBy用来分区的字段。</li>
<li>context：当前窗口进行计算的上下文，它的类型就是ProcessWindowFunction内部定义的抽象类Context。</li>
<li>elements：窗口收集到用来计算的所有数据，这是一个可迭代的集合类型。</li>
<li>out：用来发送数据输出计算结果的收集器，类型为Collector。</li>
</ul>
<p>这里的参数不再是一个输入数据，而是窗口中所有数据的集合。而上下文context所包含的内容也跟其他处理函数有所差别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Context</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> W <span class="title function_">window</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">long</span> <span class="title function_">currentProcessingTime</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">long</span> <span class="title function_">currentWatermark</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title function_">windowState</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title function_">globalState</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;X&gt; <span class="keyword">void</span> <span class="title function_">output</span><span class="params">(OutputTag&lt;X&gt; outputTag, X value)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了可以通过.output()方法定义侧输出流不变外，其他部分都有所变化。这里不再持有TimerService对象，只能通过currentProcessingTime()和currentWatermark()来获取当前时间，所以失去了设置定时器的功能；另外由于当前不是只处理一个数据，所以也不再提供.timestamp()方法。与此同时，也增加了一些获取其他信息的方法：比如可以通过.window()直接获取到当前的窗口对象，也可以通过.windowState()和.globalState()获取到当前自定义的窗口状态和全局状态。注意这里的“窗口状态”是自定义的，不包括窗口本身已经有的状态，针对当前key、当前窗口有效；而“全局状态”同样是自定义的状态，针对当前key的所有窗口有效。<br>所以我们会发现，ProcessWindowFunction中除了.process()方法外，并没有.onTimer()方法，而是多出了一个.clear()方法。从名字就可以看出，这主要是方便我们进行窗口的清理工作。如果我们自定义了窗口状态，那么必须在.clear()方法中进行显式地清除，避免内存溢出。<br>至于另一种窗口处理函数ProcessAllWindowFunction，它的用法非常类似。区别在于它基于的是AllWindowedStream，相当于对没有keyBy的数据流直接开窗并调用.process()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream.windowAll( TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)) )</span><br><span class="line">    .process(<span class="keyword">new</span> <span class="title class_">MyProcessAllWindowFunction</span>())</span><br></pre></td></tr></table></figure>

<h2 id="6-4-应用案例–TopN"><a href="#6-4-应用案例–TopN" class="headerlink" title="6.4 应用案例–TopN"></a>6.4 应用案例–TopN</h2><h1 id="7-状态管理"><a href="#7-状态管理" class="headerlink" title="7 状态管理"></a>7 状态管理</h1><h2 id="7-1-Flink中的状态"><a href="#7-1-Flink中的状态" class="headerlink" title="7.1 Flink中的状态"></a>7.1 Flink中的状态</h2><h3 id="7-1-1-概述"><a href="#7-1-1-概述" class="headerlink" title="7.1.1 概述"></a>7.1.1 概述</h3><p>算子任务可以分为无状态和有状态两种情况。<br>无状态的算子任务只需要观察每个独立事件，根据当前输入的数据直接转换输出结果。如map、filter、flatMap，计算时不依赖其他数据，都属于无状态的算子。</p>
<p>有状态算子任务，则除当前数据之外，还需要一些其他数据来得到计算结果，“其他数据”就是所谓的状态（state），如聚合算子、窗口算子都属于有状态算子。<br>有状态算子的一般处理流程：</p>
<ol>
<li>算子任务接收到上游发来的数据</li>
<li>获取当前状态</li>
<li>根据业务逻辑进行计算，更新状态</li>
<li>得到计算结果，输出发送到下游的任务<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240110153754.png"></li>
</ol>
<h3 id="7-1-2-状态的分类"><a href="#7-1-2-状态的分类" class="headerlink" title="7.1.2 状态的分类"></a>7.1.2 状态的分类</h3><ol>
<li>托管状态（Managed State）和原始状态（Raw State）</li>
</ol>
<p>Flink的状态有两种：托管状态（Managed State）和原始状态（Raw State）。托管状态就是由Flink统一管理的，状态的存储访问、故障恢复和重组等一系列问题都由Flink实现，我们只要调接口就可以；而原始状态则是自定义的，相当于就是开辟了一块内存，需要我们自己管理，实现状态的序列化和故障恢复。</p>
<ol start="2">
<li>算子状态（Operator State）和按键分区状态（Keyed State）</li>
</ol>
<p>一个算子任务会按照并行度分为多个并行子任务执行，而不同的子任务会占据不同的任务槽（task slot）。由于不同的slot在计算资源上是物理隔离的，所以Flink能管理的状态在并行任务间是无法共享的，每个状态只能针对当前子任务的实例有效。</p>
<p>而很多有状态的操作（比如聚合、窗口）都是要先做keyBy进行按键分区的。按键分区之后，任务所进行的所有计算都应该只针对当前key有效，所以状态也应该按照key彼此隔离。在这种情况下，状态的访问方式又会有所不同。</p>
<p>状态作用范围限定为当前的算子任务实例，也就是只对当前并行子任务实例有效。这就意味着对于一个并行子任务，占据了一个“分区”，它所处理的所有数据都会访问到相同的状态，状态对于同一任务而言是共享的。</p>
<p>状态是根据输入流中定义的键（key）来维护和访问的，所以只能定义在按键分区流（KeyedStream）中，也就keyBy之后才可以使用。</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20240110155542.png"></p>
<p>按键分区状态应用非常广泛。聚合算子必须在keyBy之后才能使用，就是因为聚合的结果是以Keyed State的形式保存的。</p>
<p>也可以通过富函数类（Rich Function）来自定义Keyed State，所以只要提供了富函数类接口的算子，也都可以使用Keyed State。所以即使是map、filter这样无状态的基本转换算子，我们也可以通过富函数类给它们“追加”Keyed State。比如RichMapFunction、RichFilterFunction。在富函数中，我们可以调用.getRuntimeContext()获取当前的运行时上下文（RuntimeContext），进而获取到访问状态的句柄；这种富函数中自定义的状态也是Keyed State。从这个角度讲，Flink中所有的算子都可以是有状态的。</p>
<p>无论是Keyed State还是Operator State，它们都是在本地实例上维护的，也就是说每个并行子任务维护着对应的状态，算子的子任务之间状态不共享。</p>
<h2 id="7-2-按键分区状态（Keyed-State）"><a href="#7-2-按键分区状态（Keyed-State）" class="headerlink" title="7.2 按键分区状态（Keyed State）"></a>7.2 按键分区状态（Keyed State）</h2><h3 id="7-2-1-值状态（ValueState）"><a href="#7-2-1-值状态（ValueState）" class="headerlink" title="7.2.1 值状态（ValueState）"></a>7.2.1 值状态（ValueState）</h3><p>状态中只保存一个“值”（value）。<code>ValueState&lt;T&gt;</code>本身是一个接口，源码中定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ValueState</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    T <span class="title function_">value</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(T value)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的T是泛型，表示状态的数据内容可以是任何具体的数据类型。如果想要保存一个长整型值作为状态，那么类型就是<code>ValueState&lt;Long&gt;</code>。</p>
<ul>
<li>T value()：获取当前状态的值；</li>
<li>update(T value)：对状态进行更新，传入的参数value就是要覆写的状态值。</li>
</ul>
<p>在具体使用时，为了让运行时上下文清楚到底是哪个状态，我们还需要创建一个“状态描述器”（StateDescriptor）来提供状态的基本信息。例如源码中，ValueState的状态描述器构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ValueStateDescriptor</span><span class="params">(String name, Class&lt;T&gt; typeClass)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, typeClass, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码案例：</strong> 检测每种传感器的水位值，如果连续的两个水位值超过10，就输出报警</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.state;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.bean.WaterSensor;  </span><br><span class="line"><span class="keyword">import</span> com.atguigu.functions.WaterSensorMapFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkStrategy;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.ValueState;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.ValueStateDescriptor;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.Types;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.Configuration;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.KeyedProcessFunction;  </span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.time.Duration;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * TODO 检测每种传感器的水位值，如果连续的两个水位值超过10，就输出报警  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cjp  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0  </span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KeyedValueStateDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();  </span><br><span class="line">        env.setParallelism(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">        SingleOutputStreamOperator&lt;WaterSensor&gt; sensorDS = env  </span><br><span class="line">                .socketTextStream(<span class="string">&quot;hadoop102&quot;</span>, <span class="number">7777</span>)  </span><br><span class="line">                .map(<span class="keyword">new</span> <span class="title class_">WaterSensorMapFunction</span>())  </span><br><span class="line">                .assignTimestampsAndWatermarks(  </span><br><span class="line">                        WatermarkStrategy  </span><br><span class="line">                                .&lt;WaterSensor&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">3</span>))  </span><br><span class="line">                                .withTimestampAssigner((element, ts) -&gt; element.getTs() * <span class="number">1000L</span>)  </span><br><span class="line">                );  </span><br><span class="line">  </span><br><span class="line">        sensorDS.keyBy(r -&gt; r.getId())  </span><br><span class="line">                .process(  </span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">KeyedProcessFunction</span>&lt;String, WaterSensor, String&gt;() &#123;  </span><br><span class="line">  </span><br><span class="line">                            <span class="comment">// TODO 1.定义状态  </span></span><br><span class="line">                            ValueState&lt;Integer&gt; lastVcState;  </span><br><span class="line">  </span><br><span class="line">                            <span class="meta">@Override</span>  </span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                                <span class="built_in">super</span>.open(parameters);  </span><br><span class="line">                                <span class="comment">// TODO 2.在open方法中，初始化状态  </span></span><br><span class="line">                                <span class="comment">// 状态描述器两个参数：第一个参数，起个名字，不重复；第二个参数，存储的类型  </span></span><br><span class="line">                                lastVcState = getRuntimeContext().getState(<span class="keyword">new</span> <span class="title class_">ValueStateDescriptor</span>&lt;Integer&gt;(<span class="string">&quot;lastVcState&quot;</span>, Types.INT));  </span><br><span class="line">                            &#125;  </span><br><span class="line">  </span><br><span class="line">                            <span class="meta">@Override</span>  </span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElement</span><span class="params">(WaterSensor value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                                <span class="comment">//lastVcState.value();  // 取出 本组 值状态 的数据  </span></span><br><span class="line">                                <span class="comment">//lastVcState.update(); // 更新 本组 值状态 的数据  </span></span><br><span class="line">                                <span class="comment">//lastVcState.clear();  // 清除 本组 值状态 的数据  </span></span><br><span class="line">  </span><br><span class="line">                                <span class="comment">// 1. 取出上一条数据的水位值(Integer默认值是null，判断)  </span></span><br><span class="line">                                <span class="type">int</span> <span class="variable">lastVc</span> <span class="operator">=</span> lastVcState.value() == <span class="literal">null</span> ? <span class="number">0</span> : lastVcState.value();  </span><br><span class="line">                                <span class="comment">// 2. 求差值的绝对值，判断是否超过10  </span></span><br><span class="line">                                <span class="type">Integer</span> <span class="variable">vc</span> <span class="operator">=</span> value.getVc();  </span><br><span class="line">                                <span class="keyword">if</span> (Math.abs(vc - lastVc) &gt; <span class="number">10</span>) &#123;  </span><br><span class="line">                                    out.collect(<span class="string">&quot;传感器=&quot;</span> + value.getId() + <span class="string">&quot;==&gt;当前水位值=&quot;</span> + vc + <span class="string">&quot;,与上一条水位值=&quot;</span> + lastVc + <span class="string">&quot;,相差超过10！！！！&quot;</span>);  </span><br><span class="line">                                &#125;  </span><br><span class="line">                                <span class="comment">// 3. 更新状态里的水位值  </span></span><br><span class="line">                                lastVcState.update(vc);  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                )  </span><br><span class="line">                .print();  </span><br><span class="line">  </span><br><span class="line">        env.execute();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输入：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1,1,1</span><br><span class="line">s1,20,1</span><br><span class="line">s1,30,30</span><br></pre></td></tr></table></figure>
<p><strong>输出</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">传感器=s1==&gt;当前水位值=30,与上一条水位值=1,相差超过10！！！！</span><br></pre></td></tr></table></figure>

<h3 id="7-2-2-其他状态"><a href="#7-2-2-其他状态" class="headerlink" title="7.2.2 其他状态"></a>7.2.2 其他状态</h3><ol>
<li>列表状态（ListState）</li>
<li>Map状态（MapState）</li>
<li>归约状态（ReducingState）</li>
<li>聚合状态（AggregatingState）</li>
</ol>
<h1 id="8-容错机制"><a href="#8-容错机制" class="headerlink" title="8 容错机制"></a>8 容错机制</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://baihlup.github.io">梦之痕</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://baihlup.github.io/2024/01/04/250%20-%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD&amp;%E5%A4%A7%E6%95%B0%E6%8D%AE/258%20-%20%E5%A4%A7%E6%95%B0%E6%8D%AE/01%20-%20Flink%20%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">https://baihlup.github.io/2024/01/04/250%20-%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD&amp;%E5%A4%A7%E6%95%B0%E6%8D%AE/258%20-%20%E5%A4%A7%E6%95%B0%E6%8D%AE/01%20-%20Flink%20%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Flink/">Flink</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/12/100%20-%20%E6%88%91%E7%9A%84%E7%99%BE%E5%AE%9D%E7%AE%B1/204%20-%20%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/06%20-%20Maven%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/" title="Maven依赖管理项目构建工具"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">Maven依赖管理项目构建工具</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/02/100%20-%20%E6%88%91%E7%9A%84%E7%99%BE%E5%AE%9D%E7%AE%B1/204%20-%20%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/01%20-%20Git%20%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/" title="Git 使用手册"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">Git 使用手册</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">梦之痕</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/BaihlUp"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">个人笔记迁移中ing....</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.</span> <span class="toc-text">0 参考资料</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-1-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99"><span class="toc-number">1.1.</span> <span class="toc-text">0.1 学习资料</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-2-%E6%8E%A8%E8%8D%90%E4%B9%A6%E7%B1%8D"><span class="toc-number">1.2.</span> <span class="toc-text">0.2 推荐书籍</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%88%9D%E8%AF%86-Flink"><span class="toc-number">2.</span> <span class="toc-text">1 初识 Flink</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 大数据开发总体架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Flink-%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 Flink 主要组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Flink-%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.3.</span> <span class="toc-text">1.3 Flink 编程接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-Stateful-Stream-Processing-API"><span class="toc-number">2.3.1.</span> <span class="toc-text">1.3.1 Stateful Stream Processing API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-DataStream-DataSet-API"><span class="toc-number">2.3.2.</span> <span class="toc-text">1.3.2 DataStream&#x2F;DataSet API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-Table-API"><span class="toc-number">2.3.3.</span> <span class="toc-text">1.3.3 Table API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-4-SQL-API"><span class="toc-number">2.3.4.</span> <span class="toc-text">1.3.4 SQL API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Flink-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.</span> <span class="toc-text">1.4 Flink 程序结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Flink-%E8%BF%90%E8%A1%8C%E6%9E%B6%E6%9E%84%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">2 Flink 运行架构和原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Flink-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9E%B6%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 Flink 运行时架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-Flink-Standalone%E6%9E%B6%E6%9E%84"><span class="toc-number">3.1.1.</span> <span class="toc-text">2.1.1 Flink Standalone架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-1-Task"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">2.1.1.1 Task</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-2-Task-Slot"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">2.1.1.2 Task Slot</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-YARN-%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84"><span class="toc-number">3.1.2.</span> <span class="toc-text">2.1.2 YARN 集群架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Flink-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 Flink 任务调度原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E4%BB%BB%E5%8A%A1%E9%93%BE"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.2.1 任务链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E5%B9%B6%E8%A1%8C%E5%BA%A6"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2.2 并行度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E5%85%B1%E4%BA%ABTask-Slot"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.2.3 共享Task Slot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">3.2.4.</span> <span class="toc-text">2.2.4 数据流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-%E6%89%A7%E8%A1%8C%E5%9B%BE"><span class="toc-number">3.2.5.</span> <span class="toc-text">2.2.5 执行图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Flink-DataStream-API"><span class="toc-number">4.</span> <span class="toc-text">3 Flink DataStream API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 执行模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%BD%9C%E4%B8%9A%E6%B5%81%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 作业流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Source-%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 Source 数据源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Transformation-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.4.</span> <span class="toc-text">3.4 Transformation 数据转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E5%9F%BA%E6%9C%AC%E8%BD%AC%E6%8D%A2%E7%AE%97%E5%AD%90"><span class="toc-number">4.4.1.</span> <span class="toc-text">3.4.1 基本转换算子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-1-map-func"><span class="toc-number">4.4.1.1.</span> <span class="toc-text">3.4.1.1 map(func)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-2-flatMap-func"><span class="toc-number">4.4.1.2.</span> <span class="toc-text">3.4.1.2 flatMap(func)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-3-filter"><span class="toc-number">4.4.1.3.</span> <span class="toc-text">3.4.1.3 filter</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E8%81%9A%E5%90%88%E7%AE%97%E5%AD%90"><span class="toc-number">4.4.2.</span> <span class="toc-text">3.4.2 聚合算子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-1-%E7%AE%80%E5%8D%95%E8%81%9A%E5%90%88%EF%BC%88sum-min-max-minBy-maxBy%EF%BC%89"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">3.4.2.1 简单聚合（sum&#x2F;min&#x2F;max&#x2F;minBy&#x2F;maxBy）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-2-reduce"><span class="toc-number">4.4.2.2.</span> <span class="toc-text">3.4.2.2 reduce</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.3.</span> <span class="toc-text">3.4.3 用户自定义函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-1-%E5%87%BD%E6%95%B0%E7%B1%BB"><span class="toc-number">4.4.3.1.</span> <span class="toc-text">3.4.3.1 函数类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-2-%E5%AF%8C%E5%87%BD%E6%95%B0%E7%B1%BB"><span class="toc-number">4.4.3.2.</span> <span class="toc-text">3.4.3.2 富函数类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-%E7%89%A9%E7%90%86%E5%88%86%E5%8C%BA%E7%AE%97%E5%AD%90"><span class="toc-number">4.4.4.</span> <span class="toc-text">3.4.4 物理分区算子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4-1-%E9%9A%8F%E6%9C%BA%E5%88%86%E5%8C%BA"><span class="toc-number">4.4.4.1.</span> <span class="toc-text">3.4.4.1 随机分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4-2-%E8%BD%AE%E8%AF%A2%E5%88%86%E5%8C%BA"><span class="toc-number">4.4.4.2.</span> <span class="toc-text">3.4.4.2 轮询分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4-3-%E9%87%8D%E7%BC%A9%E6%94%BE%E5%88%86%E5%8C%BA"><span class="toc-number">4.4.4.3.</span> <span class="toc-text">3.4.4.3 重缩放分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4-4-%E5%B9%BF%E6%92%AD-%E5%85%A8%E5%B1%80%E5%88%86%E5%8C%BA"><span class="toc-number">4.4.4.4.</span> <span class="toc-text">3.4.4.4 广播&#x2F;全局分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4-5-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E5%8C%BA"><span class="toc-number">4.4.4.5.</span> <span class="toc-text">3.4.4.5 自定义分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4-6-%E6%80%BB%E7%BB%93"><span class="toc-number">4.4.4.6.</span> <span class="toc-text">3.4.4.6 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-5-%E4%BE%A7%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">4.4.5.</span> <span class="toc-text">3.4.5 侧输出流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-6-%E5%90%88%E6%B5%81"><span class="toc-number">4.4.6.</span> <span class="toc-text">3.4.6 合流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-6-1-%E8%81%94%E5%90%88"><span class="toc-number">4.4.6.1.</span> <span class="toc-text">3.4.6.1 联合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-6-2-%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.4.6.2.</span> <span class="toc-text">3.4.6.2 连接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Sink-%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA"><span class="toc-number">4.5.</span> <span class="toc-text">3.5 Sink 数据输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-%E8%BF%9E%E6%8E%A5%E5%88%B0%E5%A4%96%E9%83%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.5.1.</span> <span class="toc-text">3.5.1 连接到外部系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E8%BE%93%E5%87%BA%E5%88%B0%E6%96%87%E4%BB%B6"><span class="toc-number">4.5.2.</span> <span class="toc-text">3.5.2 输出到文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-3-%E8%BE%93%E5%87%BA%E5%88%B0Kafka"><span class="toc-number">4.5.3.</span> <span class="toc-text">3.5.3 输出到Kafka</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-4-%E8%BE%93%E5%87%BA%E5%88%B0-MySQL%EF%BC%88JDBC%EF%BC%89"><span class="toc-number">4.5.4.</span> <span class="toc-text">3.5.4 输出到 MySQL（JDBC）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-5-%E8%87%AA%E5%AE%9A%E4%B9%89-Sink-%E8%BE%93%E5%87%BA"><span class="toc-number">4.5.5.</span> <span class="toc-text">3.5.5 自定义 Sink 输出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Flink-%E4%B8%AD%E7%9A%84%E7%AA%97%E5%8F%A3"><span class="toc-number">5.</span> <span class="toc-text">4 Flink 中的窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E7%AA%97%E5%8F%A3"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%AA%97%E5%8F%A3%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.1.</span> <span class="toc-text">4.2 窗口分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E6%8C%89%E7%85%A7%E9%A9%B1%E5%8A%A8%E7%B1%BB%E5%9E%8B%E5%88%92%E5%88%86"><span class="toc-number">5.1.2.</span> <span class="toc-text">4.2.1 按照驱动类型划分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-2-2-%E6%8C%89%E7%85%A7%E7%AA%97%E5%8F%A3%E5%88%86%E9%85%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A7%84%E5%88%99%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">3.6.2.2 按照窗口分配数据的规则分类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E7%AA%97%E5%8F%A3API"><span class="toc-number">5.2.</span> <span class="toc-text">4.3 窗口API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.</span> <span class="toc-text">4.4 窗口函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E5%A2%9E%E9%87%8F%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%EF%BC%88ReduceFunction-AggregateFunction%EF%BC%89"><span class="toc-number">5.3.1.</span> <span class="toc-text">4.4.1 增量聚合函数（ReduceFunction&#x2F;AggregateFunction）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E5%85%A8%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%EF%BC%88WindowFunction-ProcessWindowFunction%EF%BC%89"><span class="toc-number">5.3.2.</span> <span class="toc-text">4.4.2 全窗口函数（WindowFunction&#x2F;ProcessWindowFunction）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-3-%E5%A2%9E%E9%87%8F%E8%81%9A%E5%90%88%E5%92%8C%E5%85%A8%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E7%BB%93%E5%90%88"><span class="toc-number">5.3.3.</span> <span class="toc-text">4.4.3 增量聚合和全窗口函数结合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%85%B6%E4%BB%96-API"><span class="toc-number">5.4.</span> <span class="toc-text">4.5 其他 API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%88Trigger%EF%BC%89"><span class="toc-number">5.4.0.1.</span> <span class="toc-text">4.5.1 触发器（Trigger）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-%E7%A7%BB%E9%99%A4%E5%99%A8%EF%BC%88Evictor%EF%BC%89"><span class="toc-number">5.4.1.</span> <span class="toc-text">4.5.2 移除器（Evictor）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E6%B0%B4%E4%BD%8D%E7%BA%BF%EF%BC%88Watermark%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">5 水位线（Watermark）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%97%B6%E9%97%B4%E8%AF%AD%E4%B9%89"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 时间语义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%B0%B4%E4%BD%8D%E7%BA%BF%EF%BC%88Watermark%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">5.2 水位线（Watermark）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E4%BA%8B%E4%BB%B6%E6%97%B6%E9%97%B4%E5%92%8C%E7%AA%97%E5%8F%A3"><span class="toc-number">6.2.1.</span> <span class="toc-text">5.2.1 事件时间和窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B0%B4%E4%BD%8D%E7%BA%BF"><span class="toc-number">6.2.2.</span> <span class="toc-text">5.2.2 什么是水位线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-%E6%B0%B4%E4%BD%8D%E7%BA%BF%E5%92%8C%E7%AA%97%E5%8F%A3%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">6.2.3.</span> <span class="toc-text">5.2.3 水位线和窗口的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-4-%E7%94%9F%E6%88%90%E6%B0%B4%E4%BD%8D%E7%BA%BF"><span class="toc-number">6.2.4.</span> <span class="toc-text">5.2.4 生成水位线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-5-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B0%B4%E4%BD%8D%E7%BA%BF%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">6.2.5.</span> <span class="toc-text">5.2.5 自定义水位线生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-6-%E6%B0%B4%E4%BD%8D%E7%BA%BF%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-number">6.2.6.</span> <span class="toc-text">5.2.6 水位线的传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-7-%E8%BF%9F%E5%88%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">6.2.7.</span> <span class="toc-text">5.2.7 迟到数据的处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E5%90%88%E6%B5%81%EF%BC%88%E5%8F%8C%E6%B5%81%E8%81%94%E7%BB%93join%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">5.3 基于时间的合流（双流联结join）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E7%AA%97%E5%8F%A3%E8%81%94%E7%BB%93%EF%BC%88Window-Join%EF%BC%89"><span class="toc-number">6.3.1.</span> <span class="toc-text">5.3.1 窗口联结（Window Join）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E9%97%B4%E9%9A%94%E8%81%94%E7%BB%93%EF%BC%88Interval-Join%EF%BC%89"><span class="toc-number">6.3.2.</span> <span class="toc-text">5.3.2 间隔联结（Interval Join）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">6 处理函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%9F%BA%E6%9C%AC%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%EF%BC%88ProcessFunction%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">6.1 基本处理函数（ProcessFunction）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="toc-number">7.1.1.</span> <span class="toc-text">6.1.1 处理函数的功能和作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-ProcessFunction%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.1.2.</span> <span class="toc-text">6.1.2 ProcessFunction介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">7.1.3.</span> <span class="toc-text">6.1.3 处理函数的分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E6%8C%89%E9%94%AE%E5%88%86%E5%8C%BA%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 按键分区处理函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%88Timer%EF%BC%89%E5%92%8C%E5%AE%9A%E6%97%B6%E6%9C%8D%E5%8A%A1%EF%BC%88TimerService%EF%BC%89"><span class="toc-number">7.2.1.</span> <span class="toc-text">6.2.1 定时器（Timer）和定时服务（TimerService）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-KeyedProcessFunction%E6%A1%88%E4%BE%8B"><span class="toc-number">7.2.2.</span> <span class="toc-text">6.2.2 KeyedProcessFunction案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E7%AA%97%E5%8F%A3%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.</span> <span class="toc-text">6.3 窗口处理函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B%E2%80%93TopN"><span class="toc-number">7.4.</span> <span class="toc-text">6.4 应用案例–TopN</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">7 状态管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-Flink%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">8.1.</span> <span class="toc-text">7.1 Flink中的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">8.1.1.</span> <span class="toc-text">7.1.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">8.1.2.</span> <span class="toc-text">7.1.2 状态的分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%8C%89%E9%94%AE%E5%88%86%E5%8C%BA%E7%8A%B6%E6%80%81%EF%BC%88Keyed-State%EF%BC%89"><span class="toc-number">8.2.</span> <span class="toc-text">7.2 按键分区状态（Keyed State）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-%E5%80%BC%E7%8A%B6%E6%80%81%EF%BC%88ValueState%EF%BC%89"><span class="toc-number">8.2.1.</span> <span class="toc-text">7.2.1 值状态（ValueState）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-%E5%85%B6%E4%BB%96%E7%8A%B6%E6%80%81"><span class="toc-number">8.2.2.</span> <span class="toc-text">7.2.2 其他状态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%AE%B9%E9%94%99%E6%9C%BA%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">8 容错机制</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/26/260%20-%20%E5%90%8E%E7%AB%AF&amp;%E6%9E%B6%E6%9E%84/261%20-%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02%20-%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/" title="Untitled">Untitled</a><time datetime="2024-10-26T14:27:27.269Z" title="Created 2024-10-26 14:27:27">2024-10-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/28/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/279%20-%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/02%20-%20%E8%AE%B0%E5%BD%95%E8%AE%BF%E9%97%AE%20HTTPS%20%E7%BD%91%E7%AB%99%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/" title="记录访问 HTTPS 网站报错问题">记录访问 HTTPS 网站报错问题</a><time datetime="2024-09-28T00:00:00.000Z" title="Created 2024-09-28 00:00:00">2024-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/29/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/279%20-%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/06%20-%20%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%94%A8%E5%8F%8C%E5%8D%81%E4%B8%80%E7%9A%84%E6%95%85%E4%BA%8B%E4%B8%B2%E8%B5%B7%E7%A2%8E%E7%89%87%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%AD%EF%BC%89/" title="Untitled">Untitled</a><time datetime="2024-08-29T08:17:15.548Z" title="Created 2024-08-29 08:17:15">2024-08-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/29/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/279%20-%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/05%20-%20%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%94%A8%E5%8F%8C%E5%8D%81%E4%B8%80%E7%9A%84%E6%95%85%E4%BA%8B%E4%B8%B2%E8%B5%B7%E7%A2%8E%E7%89%87%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8A%EF%BC%89/" title="Untitled">Untitled</a><time datetime="2024-08-29T08:17:15.544Z" title="Created 2024-08-29 08:17:15">2024-08-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/29/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/279%20-%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/07%20-%20%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%94%A8%E5%8F%8C%E5%8D%81%E4%B8%80%E7%9A%84%E6%95%85%E4%BA%8B%E4%B8%B2%E8%B5%B7%E7%A2%8E%E7%89%87%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8B%EF%BC%89/" title="Untitled">Untitled</a><time datetime="2024-08-29T08:17:15.540Z" title="Created 2024-08-29 08:17:15">2024-08-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 梦之痕</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>