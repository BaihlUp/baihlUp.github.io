<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>深入理解Nginx：模块开发与架构解析 | 梦之痕</title><meta name="author" content="梦之痕"><meta name="copyright" content="梦之痕"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="0 参考资料书中示例代码 Nginx 源码注释：https:&#x2F;&#x2F;github.com&#x2F;chronolaw&#x2F;annotated_nginx 2 如何编写HTTP模块2.7 Nginx提供的高级数据结构12345- ngx_queue_t 双向链表- ngx_array_t 动态数组- ngx_list_t 单向链表- ngx_rbtree_t 红黑树- ngx_radix_tree_t 基数树  第">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Nginx：模块开发与架构解析">
<meta property="og:url" content="https://baihlup.github.io/2024/02/04/260%20-%20%E5%90%8E%E7%AB%AF&%E6%9E%B6%E6%9E%84/263%20-%20%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/05%20-%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Nginx%EF%BC%9A%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="梦之痕">
<meta property="og:description" content="0 参考资料书中示例代码 Nginx 源码注释：https:&#x2F;&#x2F;github.com&#x2F;chronolaw&#x2F;annotated_nginx 2 如何编写HTTP模块2.7 Nginx提供的高级数据结构12345- ngx_queue_t 双向链表- ngx_array_t 动态数组- ngx_list_t 单向链表- ngx_rbtree_t 红黑树- ngx_radix_tree_t 基数树  第">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg">
<meta property="article:published_time" content="2024-02-04T00:00:00.000Z">
<meta property="article:modified_time" content="2024-10-15T08:56:21.449Z">
<meta property="article:author" content="梦之痕">
<meta property="article:tag" content="Nginx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://baihlup.github.io/2024/02/04/260%20-%20%E5%90%8E%E7%AB%AF&amp;%E6%9E%B6%E6%9E%84/263%20-%20%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/05%20-%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Nginx%EF%BC%9A%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '深入理解Nginx：模块开发与架构解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-15 08:56:21'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="梦之痕"><span class="site-name">梦之痕</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">深入理解Nginx：模块开发与架构解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-02-04T00:00:00.000Z" title="Created 2024-02-04 00:00:00">2024-02-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-10-15T08:56:21.449Z" title="Updated 2024-10-15 08:56:21">2024-10-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF-%E6%9E%B6%E6%9E%84/">后端&amp;架构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="深入理解Nginx：模块开发与架构解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="0-参考资料"><a href="#0-参考资料" class="headerlink" title="0 参考资料"></a>0 参考资料</h1><p><a target="_blank" rel="noopener" href="https://github.com/russelltao/diveintonginx">书中示例代码</a></p>
<p>Nginx 源码注释：<a target="_blank" rel="noopener" href="https://github.com/chronolaw/annotated_nginx">https://github.com/chronolaw/annotated_nginx</a></p>
<h1 id="2-如何编写HTTP模块"><a href="#2-如何编写HTTP模块" class="headerlink" title="2 如何编写HTTP模块"></a>2 如何编写HTTP模块</h1><h2 id="2-7-Nginx提供的高级数据结构"><a href="#2-7-Nginx提供的高级数据结构" class="headerlink" title="2.7 Nginx提供的高级数据结构"></a>2.7 Nginx提供的高级数据结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- <span class="type">ngx_queue_t</span> 双向链表</span><br><span class="line">- <span class="type">ngx_array_t</span> 动态数组</span><br><span class="line">- <span class="type">ngx_list_t</span> 单向链表</span><br><span class="line">- <span class="type">ngx_rbtree_t</span> 红黑树</span><br><span class="line">- <span class="type">ngx_radix_tree_t</span> 基数树</span><br></pre></td></tr></table></figure>

<h1 id="第3部分-深入Nginx"><a href="#第3部分-深入Nginx" class="headerlink" title="第3部分 深入Nginx"></a>第3部分 深入Nginx</h1><h2 id="8-Nginx-基础架构"><a href="#8-Nginx-基础架构" class="headerlink" title="8 Nginx 基础架构"></a>8 Nginx 基础架构</h2><h3 id="8-2-1-Nginx的模块化设计"><a href="#8-2-1-Nginx的模块化设计" class="headerlink" title="8.2.1 Nginx的模块化设计"></a>8.2.1 Nginx的模块化设计</h3><p>ngx_module_t接口及其对核心、事件、HTTP、mail等4类模块ctx上下文成员的具体化：</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/FDBDFFA5-CDE7-4CAA-9A0B-7E35BD5DA170.png"></p>
<p>官方Nginx共有五大类模块：核心模块、配置模块、事件模块、HTTP模块、mail模块。<br>这五类模块中，配置模块与核心模块是与Nginx框架密切相关的，是其他模块的基础。而事件模块是HTTP模块和mial模块的基础。HTTP模块和mail模块的“地位”相似，都更关注于应用层面。在事件模块中，ngx_event_core_module事件模块是其他有事件模块的基础；在HTTP模块中，ngx_module_core_module模块是其他所有HTTP模块的基础；在mail模块中，ngx_mail_core_module模块是其他所有mail模块的基础。<br>Nginx常用模块及其之间的关系：</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/7CE15B43-34D8-4D18-90FA-FD56ED2F69B3.png"></p>
<h3 id="8-2-2-事件驱动框架"><a href="#8-2-2-事件驱动框架" class="headerlink" title="8.2.2 事件驱动框架"></a>8.2.2 事件驱动框架</h3><p>传统的Web服务器是进程或线程做为事件的消费者，一个请求产生的事件被进程处理，直到这个请求处理结束，才会释放进程资源。<br>传统Web服务器事件处理模型：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/5A035685-7855-4CB5-B518-FC13467723EB.png"></p>
<p>nginx通过事件驱动的方式处理，事件的消费者是某个模块，没有事件只会交给对应的模块处理：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/4C8C9827-FA91-4552-8D1B-622724B6A8F0.png"><br>以上的模型要求每个模块不能有导致进程阻塞的行为。否则会使进程休眠，大大影响并发性能。</p>
<h3 id="8-2-3-请求的多阶段异步处理"><a href="#8-2-3-请求的多阶段异步处理" class="headerlink" title="8.2.3 请求的多阶段异步处理"></a>8.2.3 请求的多阶段异步处理</h3><p>多阶段异步处理和事件驱动架构是密切相关的。以下示例，获取一个静态文件的HTTP请求可以分为如下阶段：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/79064433-500E-4391-BED2-C19D54DCF686.png"><br>这7个阶段可以重复发生。每个阶段都由事件分发器触发，然后继续调用事件消费者处理请求。通过划分阶段可以避免某个处理事件过长导致进程的延迟或者阻塞。</p>
<ul>
<li>划分阶段的原则：一般是找到请求处理流程中的阻塞方法，在阻塞代码段上按照下边的4种方式划分阶段：</li>
</ul>
<ol>
<li>讲阻塞进程的方法按照相关的触发事件分解为两个阶段</li>
</ol>
<p>把阻塞方法改为调用非阻塞方法，调用非阻塞方法后将进程归还给事件分发器这就是第一个阶段，然后增加第二阶段处理非阻塞方法返回的结果。<br>示例：<br>例如，在使用send调用发送数据给用户时，如果使用阻塞socket句柄，那么send调用在向操作系统内核发出数据包后就必须把当前进程休眠，直到成功发出数据才能“醒来”。这时的send调用发送数据并等待结果。我们需要把send调用分解为两个阶段:发送且不等待结果阶段send结果返回阶段。因此，可以使用非阻塞socket句柄，这样调用send发送数据后，进程是不会进入休眠的，这就是发送且不等待结果阶段;再把socket句柄加入到事件收集器中就可以等待相应的事件触发下一个阶段，send发送的数据被对方收到后这个事件就会触发send结果返回阶段。这个send调用就是请求的划分阶段点。</p>
<ol start="2">
<li>将阻塞方法调用按照时间分解为多个阶段的方法调用</li>
</ol>
<p>例如读取文件，因为nginx使用的事件模块没有打开对异步I&#x2F;O的支持，所以还是需要用调用阻塞的方式读取（可以使用内核的异步I&#x2F;O，但不是所有平台都提供）。可以把读取文件的操作划分成多次，比如每次读取10KB，这样减少了每次占用进程的时间，每次读取操作完之后，如果要进入下个阶段，可以考虑使用定时器出发，或者把读取到的内容发出去，然后由网络时间触发进入下一个阶段。</p>
<ol start="3">
<li>使用定时器时间触发划分阶段</li>
<li>如果无法避免要调用阻塞方法，可以考虑使用独立的进程执行，然后进程执行完后触发事件。<blockquote>
<p>比如有些模块实现的不合理，使用了阻塞方法，如果要使用这些模块，在执行阻塞方法时，可以使用独立的进程调用。</p>
</blockquote>
</li>
</ol>
<h2 id="11-HTTP框架的执行流程"><a href="#11-HTTP框架的执行流程" class="headerlink" title="11 HTTP框架的执行流程"></a>11 HTTP框架的执行流程</h2><h3 id="11-1-HTTP处理流程"><a href="#11-1-HTTP处理流程" class="headerlink" title="11.1 HTTP处理流程"></a>11.1 HTTP处理流程</h3><p>HTTP框架在初始化时就会将每个监听ngx_listening_t结构体的handler方法设为ngx_http_init_connection方法。<br>ngx_http_init_connection方法的执行流程：</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230412112221.png"></p>
<p>第一次可读事件到来会执行ngx_http_init_request，流程如下：</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230412112351.png"><br>为了提升性能，Nginx并不会在创建连接时就分配内存，只有在第一个可读事件到来后，开始创建ngx_http_request_t，并进行初始化。<br>ngx_http_request_t结构体保存了很多整个请求的信息和处理过程中的数据。<br>ngx_http_init_request执行到最后会调用ngx_http_process_request_line方法开始接收、解析HTTP请求行，请求行的处理至少会调用一次，根据网络分包情况，会出现多次调用，流程如下：</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230412112841.png"><br>解析请求行后，就会把解析的一些内容保存到ngx_http_request_t结构中特定变量下。<br>下边开始在ngx_http_process_request_headers中接收HTTP头部：</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230412113214.png"></p>
<p>下边调用ngx_http_process_request开始处理请求：</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230412113314.png"></p>
<p>处理请求的过程中，会执行HTTP各阶段，并且调用阶段里要执行的各模块。<br>执行各阶段的模块，由ngx_http_core_run_phases调用各阶段的checker方法执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动引擎数组处理请求</span></span><br><span class="line"><span class="comment">// 从phase_handler的位置开始调用模块处理</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ngx_http_core_run_phases</span><span class="params">(<span class="type">ngx_http_request_t</span> *r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_int_t</span>                   rc;</span><br><span class="line">    <span class="type">ngx_http_phase_handler_t</span>   *ph;</span><br><span class="line">    <span class="type">ngx_http_core_main_conf_t</span>  *cmcf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到core main配置</span></span><br><span class="line">    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取引擎里的handler数组</span></span><br><span class="line">    ph = cmcf-&gt;phase_engine.handlers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从phase_handler的位置开始调用模块处理</span></span><br><span class="line">    <span class="comment">// 外部请求的引擎数组起始序号是0，从头执行引擎数组,即先从Post read开始</span></span><br><span class="line">    <span class="comment">// 内部请求，即子请求.跳过post read，直接从server rewrite开始执行，即查找server</span></span><br><span class="line">    <span class="keyword">while</span> (ph[r-&gt;phase_handler].checker) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用引擎数组里的checker</span></span><br><span class="line">        rc = ph[r-&gt;phase_handler].checker(r, &amp;ph[r-&gt;phase_handler]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// checker会检查handler的返回值</span></span><br><span class="line">        <span class="comment">// 如果handler返回again/done那么就返回ok</span></span><br><span class="line">        <span class="comment">// 退出引擎数组的处理</span></span><br><span class="line">        <span class="comment">// 由于r-&gt;write_event_handler = ngx_http_core_run_phases</span></span><br><span class="line">        <span class="comment">// 当再有写事件时会继续从之前的模块执行</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 如果checker返回again，那么继续在引擎数组里执行</span></span><br><span class="line">        <span class="comment">// 模块由r-&gt;phase_handler指定，可能会有阶段的跳跃</span></span><br><span class="line">        <span class="keyword">if</span> (rc == NGX_OK) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模块的处理函数都是通过框架给的checker函数调用，不同阶段的checker函数存在差异，所以不同阶段也可以在调用模块处理时做一些操作。</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230412141549.png"><br>一个请求多半需要Nginx事件模块多次地调度HTTP模块处理， 这时就要看在ngx_http_process_request处理请求的第2步设置的读写事件的回调方法ngx_http_request_handler的功能了。<br>请求在处理的时候，第一次调用的是ngx_http_process_request，后边再次处理则使用ngx_http_request_handler，处理流程如下：</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230412141951.png"><br>通常来说， 在接收完HTTP头部后， 是无法在一次Nginx框架的调度中处理完一个请求的。 在第一次接收完HTTP头部后， HTTP框架将调度ngx_http_process_request方法开始处理请求， 这时 如果某个checker方法返回了NGX_OK， 则将会把控制权交还给Nginx框架。 当这个请求上对应的事件再次触发时， HTTP框架将不会再调度ngx_http_process_request方法处理请求， 而是由ngx_http_request_handler方法开始处理请求。 </p>
<h3 id="11-2-读HTTP请求状态机流程"><a href="#11-2-读HTTP请求状态机流程" class="headerlink" title="11.2 读HTTP请求状态机流程"></a>11.2 读HTTP请求状态机流程</h3><p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230414102217.png"></p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://www.codedump.info/post/20190131-nginx-read-http-request/">https://www.codedump.info/post/20190131-nginx-read-http-request/</a></p>
<h3 id="11-3-checker方法"><a href="#11-3-checker方法" class="headerlink" title="11.3 checker方法"></a>11.3 checker方法</h3><p>ngx_http_core_run_phases函数中会遍历handlers数组，handlers数组是包含所有模块的处理函数，在ngx_http_init_phase_handlers函数中初始化所有HTTP阶段的模块时填充。不同的阶段会指定checker函数，每个阶段里又包括多个模块，每个模块都有自己的handler处理方法，如果当前阶段顺序调用模块处理时，如果不想处理剩下模块，可以直接通过next，跳到下一个阶段。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230412181514.png"></p>
<p>下边是ngx_http_core_generic_phase的checker方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NGX_HTTP_POST_READ_PHASE/NGX_HTTP_PREACCESS_PHASE</span></span><br><span class="line"><span class="comment">// post read/pre-access只有一个模块会执行，之后的就跳过</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ok:模块已经处理成功，直接跳过本阶段</span></span><br><span class="line"><span class="comment">// decline:表示不处理,继续在本阶段（rewrite）里查找下一个模块</span></span><br><span class="line"><span class="comment">// again/done:暂时中断ngx_http_core_run_phases</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 由于r-&gt;write_event_handler = ngx_http_core_run_phases</span></span><br><span class="line"><span class="comment">// 当再有写事件时会继续从之前的模块执行</span></span><br><span class="line"><span class="comment">// 其他的错误，结束请求</span></span><br><span class="line"><span class="comment">// 但如果count&gt;1，则不会真正结束</span></span><br><span class="line"><span class="type">ngx_int_t</span></span><br><span class="line"><span class="title function_">ngx_http_core_generic_phase</span><span class="params">(<span class="type">ngx_http_request_t</span> *r, <span class="type">ngx_http_phase_handler_t</span> *ph)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_int_t</span>  rc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * generic phase checker,</span></span><br><span class="line"><span class="comment">     * used by the post read and pre-access phases</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="string">&quot;generic phase: %ui&quot;</span>, r-&gt;phase_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用每个模块自己的处理函数</span></span><br><span class="line">    rc = ph-&gt;handler(r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模块已经处理成功，直接跳过本阶段</span></span><br><span class="line">    <span class="comment">// 注意不是++，而是next</span></span><br><span class="line">    <span class="comment">// 意味着post read/pre-access只有一个模块会执行，之后的就跳过</span></span><br><span class="line">    <span class="keyword">if</span> (rc == NGX_OK) &#123;</span><br><span class="line">        r-&gt;phase_handler = ph-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// again继续引擎数组的循环</span></span><br><span class="line">        <span class="keyword">return</span> NGX_AGAIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模块handler返回decline，表示不处理</span></span><br><span class="line">    <span class="keyword">if</span> (rc == NGX_DECLINED) &#123;</span><br><span class="line">        <span class="comment">// 继续在本阶段（rewrite）里查找下一个模块</span></span><br><span class="line">        <span class="comment">// 索引加1</span></span><br><span class="line">        r-&gt;phase_handler++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// again继续引擎数组的循环</span></span><br><span class="line">        <span class="keyword">return</span> NGX_AGAIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// again/done，暂时中断ngx_http_core_run_phases</span></span><br><span class="line">    <span class="comment">// 由于r-&gt;write_event_handler = ngx_http_core_run_phases</span></span><br><span class="line">    <span class="comment">// 当再有写事件时会继续从之前的模块执行</span></span><br><span class="line">    <span class="keyword">if</span> (rc == NGX_AGAIN || rc == NGX_DONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* rc == NGX_ERROR || rc == NGX_HTTP_...  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他的错误，见上nginx注释</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束请求</span></span><br><span class="line">    <span class="comment">// 但如果count&gt;1，则不会真正结束</span></span><br><span class="line">    ngx_http_finalize_request(r, rc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上方法中，如果模块处理方法返回NGX_OK，则跳过本阶段剩下的模块，直接跳到下一个阶段。如果返回NGX_DECLINED，则继续在本阶段查找下一个模块，NGX_AGAIN&#x2F;NGX_DONE则暂时中断ngx_http_core_run_phases方法，等待下次写事件到来后被epoll再次调用。</p>
<h3 id="11-4-subrequest与post请求"><a href="#11-4-subrequest与post请求" class="headerlink" title="11.4 subrequest与post请求"></a>11.4 subrequest与post请求</h3><p>Nginx使用的完全无阻塞的事件驱动框架是难以编写功能复杂的模块的， 可以想见， 一个请求在处理一个TCP连接时， 将需要处理这个连接上的可读、 可写以及定时器事件， 而可读事件中又包含连接建立成功、 连接关闭事件， 正常的可读事件在接收到HTTP的不同部分时又要做不同的处理， 这就比较复杂了。 如果一个请求同时需要与多个上游服务器打交道， 同时处理多个TCP连接， 那么它需要处理的事件就太多了， 这种复杂度会使得模块难以维护。 Nginx解决这个问题的手段就是第5章中介绍过的subrequest机制。</p>
<h3 id="11-5-处理HTTP包体"><a href="#11-5-处理HTTP包体" class="headerlink" title="11.5 处理HTTP包体"></a>11.5 处理HTTP包体</h3><p>在ngx_http_request_t结构体中的count引用计数标识，因为HTTP模块在处理请求时，接受包体的同时可能还需要处理其他业务，如使用upstream机制与另一台服务器通信。所以在销毁请求时需要通过这个计数判断，否则可能引发严重错误，在为一个请求添加新的事件，或者把一些已经由定时器、epoll中移除的事件重新加入其中，都需要把这个请求的引用计数加1。通过这个标识可以让HTTP框架知道，HTTP模块对于该请求有独立的异步处理机制。<br>调用ngx_http_read_client_request_body方法相当于启动了接收包体这个动作。<br>读取请求包体的重要结构为ngx_http_request_body_t</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求体的数据结构，用于读取或丢弃请求体数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">ngx_temp_file_t</span>                  *temp_file;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收到的数据都存在这个链表里</span></span><br><span class="line">    <span class="comment">// 最后一个节点b-&gt;last_buf = 1</span></span><br><span class="line">    <span class="type">ngx_chain_t</span>                      *bufs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前使用的缓冲区</span></span><br><span class="line">    <span class="type">ngx_buf_t</span>                        *buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩余要读取的字节数</span></span><br><span class="line">    <span class="comment">// 对于确定长度（有content length）的就是r-&gt;headers_in.content_length_n</span></span><br><span class="line">    <span class="comment">// 在读取过程中会不断变化，最终为0</span></span><br><span class="line">    <span class="type">off_t</span>                             rest;</span><br><span class="line"></span><br><span class="line">    <span class="type">off_t</span>                             received;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空闲节点链表，优化用，避免再向内存池要节点</span></span><br><span class="line">    <span class="type">ngx_chain_t</span>                      *<span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">ngx_chain_t</span>                      *busy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取chunk数据的结构体，用于ngx_http_parse_chunked()</span></span><br><span class="line">    <span class="type">ngx_http_chunked_t</span>               *chunked;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当读取完毕后的回调函数</span></span><br><span class="line">    <span class="comment">// 即ngx_http_read_client_request_body的第二个参数</span></span><br><span class="line">    ngx_http_client_body_handler_pt   post_handler;</span><br><span class="line">    <span class="type">unsigned</span>                          filter_need_buffering:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span>                          last_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span>                          last_saved:<span class="number">1</span>;</span><br><span class="line">&#125; <span class="type">ngx_http_request_body_t</span>;</span><br></pre></td></tr></table></figure>
<p>此结构存放在ngx_http_request_t结构体的request_body成员中。<br>ngx_http_read_client_request_body方法的流程图如下：</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230414103330.png"><br>如果下次再次触发可读事件，则变为调用ngx_http_do_read_client_request_body方法接收包体：</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230414103620.png"><br>在接收包体时需要根据配置文件中关于client_body_timeout配置项，配置相应的操作。</p>
<ul>
<li>放弃接收包体</li>
</ul>
<p>ngx_http_discard_request_body调用ngx_http_discarded_request_body_handler，nginx放弃接收包体，是会在接收完后再丢弃。</p>
<h3 id="11-6-发送HTTP响应"><a href="#11-6-发送HTTP响应" class="headerlink" title="11.6 发送HTTP响应"></a>11.6 发送HTTP响应</h3><p>ngx_http_send_header：发送响应头<br>ngx_http_output_filter方法用于发送响应包体， 它的第2个参数就是用于存放响应包体的缓冲区。<br>ngx_http_write_filter中会计算发送速率和根据sendfile_max_chunk进行处理。</p>
<p>ngx_http_send_header和ngx_http_output_filter都会调用所有模块注册在过滤链表上的处理方法，然后链表末尾都会调用ngx_http_write_filter函数真正发送数据。</p>
<p>Nginx执行的时候是怎么按照次序依次来执行各个过滤模块呢？它采用了一种很隐晦的方法，即通过局部的全局变量。比如，在每个filter模块，很可能看到如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> ngx_http_output_header_filter_pt  ngx_http_next_header_filter;</span><br><span class="line"><span class="type">static</span> ngx_http_output_body_filter_pt    ngx_http_next_body_filter;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ngx_http_next_header_filter = ngx_http_top_header_filter;</span><br><span class="line">ngx_http_top_header_filter = ngx_http_example_header_filter;</span><br><span class="line"></span><br><span class="line">ngx_http_next_body_filter = ngx_http_top_body_filter;</span><br><span class="line">ngx_http_top_body_filter = ngx_http_example_body_filter;</span><br></pre></td></tr></table></figure>
<p>ngx_http_top_header_filter是一个全局变量。当编译进一个filter模块的时候，就被赋值为当前filter模块的处理函数。而ngx_http_next_header_filter是一个局部全局变量，它保存了编译前上一个filter模块的处理函数。所以整体看来，就像用全局变量组成的一条单向链表。<br>每个模块想执行下一个过滤函数，只要调用一下ngx_http_next_header_filter这个局部变量。而整个过滤模块链的入口，需要调用ngx_http_top_header_filter这个全局变量。ngx_http_top_body_filter的行为与header fitler类似。</p>
<p>响应头和响应体过滤函数的执行顺序如下所示：</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230414143010.png"></p>
<p>这图只表示了head_filter和body_filter之间的执行顺序，在header_filter和body_filter处理函数之间，在body_filter处理函数之间，可能还有其他执行代码。<br>nginx在发送数据时使用单链表，单链表负载的就是ngx_buf_t</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示一个单块的缓冲区，既可以是内存也可以是文件</span></span><br><span class="line"><span class="comment">// start和end两个成员变量标记了数据所在内存块的边界</span></span><br><span class="line"><span class="comment">// 如果内存块是可以修改的，在操作时必须参考这两个成员防止越界</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_buf_s</span> &#123;</span></span><br><span class="line">    u_char          *pos;           <span class="comment">//内存数据的起始位置</span></span><br><span class="line">    u_char          *last;          <span class="comment">//内存数据的结束位置</span></span><br><span class="line"></span><br><span class="line">    <span class="type">off_t</span>            file_pos;      <span class="comment">//文件数据的起始偏移量</span></span><br><span class="line">    <span class="type">off_t</span>            file_last;     <span class="comment">//文件数据的结束偏移量</span></span><br><span class="line"></span><br><span class="line">    u_char          *start;         <span class="comment">/* start of buffer */</span>   <span class="comment">//内存数据的上界</span></span><br><span class="line">    u_char          *end;           <span class="comment">/* end of buffer */</span>     <span class="comment">//内存数据的下界</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ngx_buf_tag_t</span>    tag;           <span class="comment">//void*指针，可以是任意数据</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ngx_file_t</span>      *file;          <span class="comment">//存储数据的文件对象</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ngx_buf_t</span>       *shadow;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the buf&#x27;s content could be changed */</span></span><br><span class="line">    <span class="type">unsigned</span>         temporary:<span class="number">1</span>;   <span class="comment">//内存块临时数据，可以修改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * the buf&#x27;s content is in a memory cache or in a read only memory</span></span><br><span class="line"><span class="comment">     * and must not be changed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span>         memory:<span class="number">1</span>;      <span class="comment">//内存块数据，不允许修改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the buf&#x27;s content is mmap()ed and must not be changed */</span></span><br><span class="line">    <span class="type">unsigned</span>         mmap:<span class="number">1</span>;        <span class="comment">//内存映射数据，不允许修改</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span>         recycled:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span>         in_file:<span class="number">1</span>;     <span class="comment">//缓冲区在文件里</span></span><br><span class="line">    <span class="type">unsigned</span>         flush:<span class="number">1</span>;       <span class="comment">//要求Nginx立即输出本缓冲区</span></span><br><span class="line">    <span class="type">unsigned</span>         sync:<span class="number">1</span>;        <span class="comment">//要求Nginx同步操作本缓冲区</span></span><br><span class="line">    <span class="type">unsigned</span>         last_buf:<span class="number">1</span>;    <span class="comment">//最后一块缓冲区</span></span><br><span class="line">    <span class="type">unsigned</span>         last_in_chain:<span class="number">1</span>;   <span class="comment">//链里的最后一块缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span>         last_shadow:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span>         temp_file:<span class="number">1</span>;       <span class="comment">//缓冲区在临时文件里</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* STUB */</span> <span class="type">int</span>   num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把缓冲区块简单地组织为一个单向链表</span></span><br><span class="line"><span class="comment">// 如果节点是链表的尾节点就必须要把next置为nullptr，表示链表结束</span></span><br><span class="line"><span class="comment">// ngx_chain_t (ngx_core.h)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_chain_s</span> &#123;</span></span><br><span class="line">    <span class="type">ngx_buf_t</span>    *buf;      <span class="comment">//缓冲区指针</span></span><br><span class="line">    <span class="type">ngx_chain_t</span>  *next;     <span class="comment">//下一个链表节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一般buffer结构体可以表示一块内存，内存的起始和结束地址分别用start和end表示，pos和last表示实际的内容。如果内容已经处理过了，pos的位置就可以往后移动。如果读取到新的内容，last的位置就会往后移动。所以buffer可以在多次调用过程中使用。如果last等于end，就说明这块内存已经用完了。如果pos等于last，说明内存已经处理完了。下面是一个简单的示意图，说明buffer中指针的用法：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230414143222.png"></p>
<h3 id="11-7-结束HTTP请求"><a href="#11-7-结束HTTP请求" class="headerlink" title="11.7 结束HTTP请求"></a>11.7 结束HTTP请求</h3><h2 id="12-upstream机制的设计与实现"><a href="#12-upstream机制的设计与实现" class="headerlink" title="12 upstream机制的设计与实现"></a>12 upstream机制的设计与实现</h2><h3 id="12-1-upstream机制"><a href="#12-1-upstream机制" class="headerlink" title="12.1 upstream机制"></a>12.1 upstream机制</h3><p>upstream机制的场景示意图：</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230418141020.png"></p>
<p>upstream机制中两个核心结构体ngx_http_upstream_t和ngx_http_upstream_conf_t：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ngx_http_upstream_t</span></span><br><span class="line"><span class="comment">// 定义了upstream机制需要的所有信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_http_upstream_s</span> &#123;</span></span><br><span class="line">    ngx_http_upstream_handler_pt     read_event_handler;</span><br><span class="line">    ngx_http_upstream_handler_pt     write_event_handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接结构体</span></span><br><span class="line">    <span class="type">ngx_peer_connection_t</span>            peer;</span><br><span class="line"></span><br><span class="line">    <span class="type">ngx_event_pipe_t</span>                *pipe;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送的请求数据</span></span><br><span class="line">    <span class="comment">// u-&gt;request_bufs = r-&gt;request_body-&gt;bufs;</span></span><br><span class="line">    <span class="type">ngx_chain_t</span>                     *request_bufs;</span><br><span class="line"></span><br><span class="line">    <span class="type">ngx_output_chain_ctx_t</span>           output;</span><br><span class="line">    <span class="type">ngx_chain_writer_ctx_t</span>           writer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上游的连接参数设置</span></span><br><span class="line">    <span class="type">ngx_http_upstream_conf_t</span>        *conf;</span><br><span class="line">    <span class="type">ngx_http_upstream_srv_conf_t</span>    *upstream;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_HTTP_CACHE)</span></span><br><span class="line">    <span class="type">ngx_array_t</span>                     *caches;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上游的响应头</span></span><br><span class="line">    <span class="type">ngx_http_upstream_headers_in_t</span>   headers_in;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上游服务器的地址</span></span><br><span class="line">    <span class="type">ngx_http_upstream_resolved_t</span>    *resolved;</span><br><span class="line"></span><br><span class="line">    <span class="type">ngx_buf_t</span>                        from_client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据缓冲区</span></span><br><span class="line">    <span class="type">ngx_buf_t</span>                        buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲数据的长度</span></span><br><span class="line">    <span class="type">off_t</span>                            length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从上游接收到的数据</span></span><br><span class="line">    <span class="type">ngx_chain_t</span>                     *out_bufs;</span><br><span class="line"></span><br><span class="line">    <span class="type">ngx_chain_t</span>                     *busy_bufs;</span><br><span class="line">    <span class="type">ngx_chain_t</span>                     *free_bufs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理上游服务器响应数据的回调函数</span></span><br><span class="line">    <span class="type">ngx_int_t</span>                      (*input_filter_init)(<span class="type">void</span> *data);</span><br><span class="line">    <span class="type">ngx_int_t</span>                      (*input_filter)(<span class="type">void</span> *data, <span class="type">ssize_t</span> bytes);</span><br><span class="line">    <span class="type">void</span>                            *input_filter_ctx;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_HTTP_CACHE)</span></span><br><span class="line">    <span class="type">ngx_int_t</span>                      (*create_key)(<span class="type">ngx_http_request_t</span> *r);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送接收请求的回调函数，9个</span></span><br><span class="line">    <span class="type">ngx_int_t</span>                      (*create_request)(<span class="type">ngx_http_request_t</span> *r);</span><br><span class="line">    <span class="type">ngx_int_t</span>                      (*reinit_request)(<span class="type">ngx_http_request_t</span> *r);</span><br><span class="line">    <span class="type">ngx_int_t</span>                      (*process_header)(<span class="type">ngx_http_request_t</span> *r);</span><br><span class="line">    <span class="type">void</span>                           (*abort_request)(<span class="type">ngx_http_request_t</span> *r);</span><br><span class="line">    <span class="type">void</span>                           (*finalize_request)(<span class="type">ngx_http_request_t</span> *r,</span><br><span class="line">                                         <span class="type">ngx_int_t</span> rc);</span><br><span class="line">    <span class="type">ngx_int_t</span>                      (*rewrite_redirect)(<span class="type">ngx_http_request_t</span> *r,</span><br><span class="line">                                         <span class="type">ngx_table_elt_t</span> *h, <span class="type">size_t</span> prefix);</span><br><span class="line">    <span class="type">ngx_int_t</span>                      (*rewrite_cookie)(<span class="type">ngx_http_request_t</span> *r,</span><br><span class="line">                                         <span class="type">ngx_table_elt_t</span> *h);</span><br><span class="line"></span><br><span class="line">    <span class="type">ngx_msec_t</span>                       start_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理的状态信息</span></span><br><span class="line">    <span class="type">ngx_http_upstream_state_t</span>       *state;</span><br><span class="line"></span><br><span class="line">    <span class="type">ngx_str_t</span>                        method;</span><br><span class="line">    <span class="type">ngx_str_t</span>                        schema;</span><br><span class="line">    <span class="type">ngx_str_t</span>                        uri;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_HTTP_SSL || NGX_COMPAT)</span></span><br><span class="line">    <span class="type">ngx_str_t</span>                        ssl_name;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ngx_http_cleanup_pt             *cleanup;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span>                         store:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span>                         cacheable:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span>                         accel:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span>                         ssl:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_HTTP_CACHE)</span></span><br><span class="line">    <span class="type">unsigned</span>                         cache_status:<span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否使用更多的缓冲区来接收上游的数据</span></span><br><span class="line">    <span class="type">unsigned</span>                         buffering:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span>                         keepalive:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span>                         upgrade:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span>                         error:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否已经发送请求</span></span><br><span class="line">    <span class="type">unsigned</span>                         request_sent:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否已经发送请求体数据</span></span><br><span class="line">    <span class="type">unsigned</span>                         request_body_sent:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span>                         request_body_blocked:<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 是否已经发送响应头</span></span><br><span class="line">    <span class="type">unsigned</span>                         header_sent:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="12-2-启动upstream"><a href="#12-2-启动upstream" class="headerlink" title="12.2 启动upstream"></a>12.2 启动upstream</h3><p>通过ngx_http_upstream_create方法创建ngx_http_upstream_t结构体，其中的成员还需要各个http模块自行设置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ngx_int_t</span> <span class="title function_">ngx_http_upstream_create</span><span class="params">(<span class="type">ngx_http_request_t</span> *r)</span></span><br></pre></td></tr></table></figure>
<p>启动upstream机制的ngx_http_upstream_init方法定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动upstream框架，开始与上游服务器异步交互</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ngx_http_upstream_init</span><span class="params">(<span class="type">ngx_http_request_t</span> *r)</span></span><br></pre></td></tr></table></figure>
<p>ngx_http_upstream_init方法的流程如下：</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230418142114.png"></p>
<h3 id="12-3-与上游服务器建立连接"><a href="#12-3-与上游服务器建立连接" class="headerlink" title="12.3 与上游服务器建立连接"></a>12.3 与上游服务器建立连接</h3><p>为了保证建立TCP连接这个操作不会阻塞进程， Nginx使用无阻塞的套接字来连接上游服务器。<br>调用的ngx_http_upstream_connect方法就是用来连接上游服务器的， 由于使用了非阻塞的套接字， 当方法返回时与上游之间的TCP连接未必会成功建立， 可能还需要等待上游服务器返回TCP的SYN&#x2F;ACK包。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试连接后端服务器</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ngx_http_upstream_connect</span><span class="params">(<span class="type">ngx_http_request_t</span> *r, <span class="type">ngx_http_upstream_t</span> *u)</span></span><br></pre></td></tr></table></figure>
<p>流程图如下：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230418143131.png"></p>
<ol>
<li>上边把此连接 ngx_connection_t的读写事件都设置为了ngx_http_upstream_handler</li>
<li>将upstream机制的write_event_handler方法设置为ngx_http_upstream_send_request_handler，此方法会多次触发，实际还是调用ngx_http_upstream_send_request方法发送。</li>
<li>upstream的read_event_handler方法设置为ngx_http_upstream_process_header</li>
<li>连接建立成功后，则调用ngx_http_upstream_send_request方法</li>
</ol>
<p>ngx_http_upstream_send_request方法的流程图：</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230418144312.png"></p>
<h3 id="12-4-接收上游服务器的响应头部"><a href="#12-4-接收上游服务器的响应头部" class="headerlink" title="12.4 接收上游服务器的响应头部"></a>12.4 接收上游服务器的响应头部</h3><p>在上边的ngx_http_upstream_send_request方法中，当请求全部发送给上游服务器时，开始准备接收来自上游服务器的响应。由ngx_http_upstream_process_header方法处理上游服务器的响应，此方法也会多次被调用。<br>Nginx可以代理多种不同的协议，分为两段方式，先处理响应头，然后处理响应体。<br>处理包体分为3种不同的方式：</p>
<ol>
<li>不转发响应：不转发包体是upstream机制最基本的功能， 特别是客户端请求派生出的子请求多半不需要转发包体。</li>
<li>转发响应时下游网速优先</li>
<li>转发响应时上游网速优先</li>
</ol>
<h3 id="12-5-以下游网速优先来转发响应"><a href="#12-5-以下游网速优先来转发响应" class="headerlink" title="12.5 以下游网速优先来转发响应"></a>12.5 以下游网速优先来转发响应</h3><p>转发上游服务器的响应到下游客户端，必然由上游事件来驱动，下游网速优先实际上意味着需要开辟一块固定长度的内存作为缓冲区。</p>
<h4 id="12-5-1-转发响应的包头"><a href="#12-5-1-转发响应的包头" class="headerlink" title="12.5.1 转发响应的包头"></a>12.5.1 转发响应的包头</h4><p>在ngx_http_upstream_send_response方法中完成的，处理流程如下</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230418153127.png"></p>
<p>通过调用ngx_http_send_header方法向客户端发送HTTP包头，会调用header过滤链表，走一下所有模块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送头，调用ngx_http_top_header_filter</span></span><br><span class="line"><span class="comment">// 如果请求处理有错误，修改输出的状态码</span></span><br><span class="line"><span class="comment">// 状态行同时清空</span></span><br><span class="line"><span class="comment">// 走过整个header过滤链表</span></span><br><span class="line"><span class="type">ngx_int_t</span></span><br><span class="line"><span class="title function_">ngx_http_send_header</span><span class="params">(<span class="type">ngx_http_request_t</span> *r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;post_action) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否已经发送过，会出个alert级别的错误，但其实无必要</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;header_sent) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_ALERT, r-&gt;connection-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                      <span class="string">&quot;header already sent&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求处理有错误，修改输出的状态码</span></span><br><span class="line">    <span class="comment">// 状态行同时清空</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;err_status) &#123;</span><br><span class="line">        r-&gt;headers_out.status = r-&gt;err_status;</span><br><span class="line">        r-&gt;headers_out.status_line.len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送头，调用ngx_http_top_header_filter</span></span><br><span class="line">    <span class="comment">// 走过整个header过滤链表</span></span><br><span class="line">    <span class="keyword">return</span> ngx_http_top_header_filter(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法中会判断配置的buffering标志，若为0，表示以下游网速优先，如果为1，则会以上游网速优先，因为上游网速一般比下游网速快很多，所有需要更大的缓冲区保存，如果达到上限，以磁盘文件的形式来缓存来不及向下游转发的响应。</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230418153520.png"></p>
<h4 id="12-5-2-转发响应包体"><a href="#12-5-2-转发响应包体" class="headerlink" title="12.5.2 转发响应包体"></a>12.5.2 转发响应包体</h4><p>如果buffering为0，则后边转发响应包体将会由ngx_http_upstream_process_non_buffered_upstream方法处理连接上的都事件。<br>无论是接收上游服务器的响应， 还是向下游客户端发送响应， 最终调用的方法都是ngx_http_upstream_process_non_buffered_request， 唯一的区别是该方法的第2个参数不同， 当需要读取上游的响应时传递的是0， 当需要向下游发送响应时传递的是1。 </p>
<p>ngx_http_upstream_process_non_buffered_request的流程图：</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230418154143.png"></p>
<p>ngx_http_upstream_process_non_buffered_request方法中调用ngx_http_output_filter方法，走过整个body过滤链表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送响应体，调用ngx_http_top_body_filter</span></span><br><span class="line"><span class="comment">// 走过整个body过滤链表</span></span><br><span class="line"><span class="comment">// 最后由ngx_http_write_filter真正的向客户端发送数据，调用send_chain</span></span><br><span class="line"><span class="comment">// 也由ngx_http_set_write_handler设置epoll的写事件触发</span></span><br><span class="line"><span class="comment">// 如果数据发送不完，就保存在r-&gt;out里，返回again</span></span><br><span class="line"><span class="comment">// 需要再次发生可写事件才能发送</span></span><br><span class="line"><span class="comment">// 不是last、flush，且数据量较小（默认1460）</span></span><br><span class="line"><span class="comment">// 那么这次就不真正调用write发送，减少系统调用的次数，提高性能</span></span><br><span class="line"><span class="type">ngx_int_t</span></span><br><span class="line"><span class="title function_">ngx_http_output_filter</span><span class="params">(<span class="type">ngx_http_request_t</span> *r, <span class="type">ngx_chain_t</span> *in)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_int_t</span>          rc;</span><br><span class="line">    <span class="type">ngx_connection_t</span>  *c;</span><br><span class="line"></span><br><span class="line">    c = r-&gt;connection;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="string">&quot;http output filter \&quot;%V?%V\&quot;&quot;</span>, &amp;r-&gt;uri, &amp;r-&gt;args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送响应体，调用ngx_http_top_body_filter</span></span><br><span class="line">    <span class="comment">// 走过整个body过滤链表</span></span><br><span class="line">    <span class="comment">// 最后由ngx_http_write_filter真正的向客户端发送数据，调用send_chain</span></span><br><span class="line">    rc = ngx_http_top_body_filter(r, in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rc == NGX_ERROR) &#123;</span><br><span class="line">        <span class="comment">/* NGX_ERROR may be returned by any filter */</span></span><br><span class="line">        c-&gt;error = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-6-以上游网速优先来转发响应"><a href="#12-6-以上游网速优先来转发响应" class="headerlink" title="12.6 以上游网速优先来转发响应"></a>12.6 以上游网速优先来转发响应</h3><p>如果将ngx_http_upstream_conf_t配置结构体的buffering标志位设置为1， 那么ngx_event_pipe_t结构体必须要由HTTP模块创建。<br>ngx_event_pipe_t结构体维护着上下游间转发的响应包体， 它相当复杂。 例如， 缓冲区链表ngx_chain_t类型的成员就定义了6个（包括free_raw_bufs、 in、 out、 free、 busy、 preread_bufs） ， 为什么要用如此复杂的数据结构支撑看似简单的转发过程呢？ 这是因为Nginx的宗旨就是高效率， 所以它绝不会把相同内容复制到两块内存中， 而同一块内存如果既要用于接收上游发来的响应， 又要准备向下游发送， 很可能还要准备写入临时文件中， 这就带来了很高的复杂度， ngx_event_pipe_t结构体的任务就在于解决这个问题。</p>
<ul>
<li>转发响应包头</li>
</ul>
<p>转发响应包头还是通过调用ngx_http_upstream_send_response方法，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u-&gt;read_event_handler = ngx_http_upstream_process_upstream;</span><br><span class="line">r-&gt;write_event_handler = ngx_http_upstream_process_downstream;</span><br></pre></td></tr></table></figure>
<p>方法中设置处理上游读事件回调方法为ngx_http_upstream_process_upstream。设置处理下游写事件的回调方法为ngx_http_upstream_process_downstream。</p>
<ul>
<li>转发响应包头</li>
</ul>
<p>处理上游读事件的方法是ngx_http_upstream_process_upstream， 处理下游写事件的方法是ngx_http_upstream_process_downstream， 但它们最终都是通过ngx_event_pipe方法实现缓存转发响应功能的。</p>
<h3 id="12-7-结束upstream请求"><a href="#12-7-结束upstream请求" class="headerlink" title="12.7 结束upstream请求"></a>12.7 结束upstream请求</h3><p>结束upstream请求调用ngx_http_upstream_finalize_request方法完成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结束请求，这时会调用finalize_request回调函数</span></span><br><span class="line"><span class="comment">// 让upstream模块有机会做一些自己的收尾工作</span></span><br><span class="line"><span class="comment">// 最后调用ngx_http_finalize_request</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ngx_http_upstream_finalize_request</span><span class="params">(<span class="type">ngx_http_request_t</span> *r,</span></span><br><span class="line"><span class="params">    <span class="type">ngx_http_upstream_t</span> *u, <span class="type">ngx_int_t</span> rc)</span></span><br></pre></td></tr></table></figure>


<h2 id="14-进程间的通信机制"><a href="#14-进程间的通信机制" class="headerlink" title="14 进程间的通信机制"></a>14 进程间的通信机制</h2><h3 id="14-1-概述"><a href="#14-1-概述" class="headerlink" title="14.1 概述"></a>14.1 概述</h3><p>Nginx框架使用了3种消息传递方式： 共享内存、 套接字、 信号。 </p>
<h3 id="14-2-共享内存"><a href="#14-2-共享内存" class="headerlink" title="14.2 共享内存"></a>14.2 共享内存</h3><h4 id="14-2-1-共享内存创建和销毁"><a href="#14-2-1-共享内存创建和销毁" class="headerlink" title="14.2.1 共享内存创建和销毁"></a>14.2.1 共享内存创建和销毁</h4><p>Linux提供了mmap和shmget系统调用在内存中创建一块连续的线性地址空间，通过munmap或shmdt系统调用释放这块内存。<br>nginx定义了ngx_shm_t结构体描述共享内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正操作共享内存的对象</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 共享内存的开始地址</span></span><br><span class="line">    <span class="comment">// 通常就是ngx_slab_pool_t</span></span><br><span class="line">    u_char      *addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享内存的大小</span></span><br><span class="line">    <span class="type">size_t</span>       size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享内存的名字</span></span><br><span class="line">    <span class="type">ngx_str_t</span>    name;</span><br><span class="line"></span><br><span class="line">    <span class="type">ngx_log_t</span>   *<span class="built_in">log</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否存在，即已经创建过了</span></span><br><span class="line">    <span class="comment">// 依据nginx官方文档，此字段仅用于windows</span></span><br><span class="line">    <span class="type">ngx_uint_t</span>   exists;   <span class="comment">/* unsigned  exists:1;  */</span></span><br><span class="line">&#125; <span class="type">ngx_shm_t</span>;</span><br></pre></td></tr></table></figure>
<p>nginx中使用如下方式创建和释放共享内存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一块共享内存</span></span><br><span class="line"><span class="type">ngx_int_t</span></span><br><span class="line"><span class="title function_">ngx_shm_alloc</span><span class="params">(<span class="type">ngx_shm_t</span> *shm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// MAP_ANON|MAP_SHARED</span></span><br><span class="line">    shm-&gt;addr = (u_char *) mmap(<span class="literal">NULL</span>, shm-&gt;size,</span><br><span class="line">                                PROT_READ|PROT_WRITE,</span><br><span class="line">                                MAP_ANON|MAP_SHARED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shm-&gt;addr == MAP_FAILED) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_ALERT, shm-&gt;<span class="built_in">log</span>, ngx_errno,</span><br><span class="line">                      <span class="string">&quot;mmap(MAP_ANON|MAP_SHARED, %uz) failed&quot;</span>, shm-&gt;size);</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NGX_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁共享内存</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ngx_shm_free</span><span class="params">(<span class="type">ngx_shm_t</span> *shm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (munmap((<span class="type">void</span> *) shm-&gt;addr, shm-&gt;size) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_ALERT, shm-&gt;<span class="built_in">log</span>, ngx_errno,</span><br><span class="line">                      <span class="string">&quot;munmap(%p, %uz) failed&quot;</span>, shm-&gt;addr, shm-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是使用mmap创建，关于mmap的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>
<p>mmap可以将磁盘文件映射到内存中， 直接操作内存时Linux内核将负责同步内存和磁盘文件中的数据， fd参数就指向需要同步的磁盘文件， 而offset则代表从文件的这个偏移量处开始共享， 当然Nginx没有使用这一特性。 当flags参数中加入MAP_ANON或者MAP_ANONYMOUS参数时表示不使用文件映射方式， 这时fd和offset参数就没有意义， 也不需要传递了， 此时的mmap方法和ngx_shm_alloc的功能几乎完全相同。length参数就是将要在内存中开辟的线性地址空间大小， 而prot参数则是操作这段共享内存的方式（如只读或者可读可写） ， start参数说明希望的共享内存起始映射地址， 当然， 通常都会把start设为NULL空指针。</p>
<p>同样创建共享内存nginx中也提供了使用shmget：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ngx_int_t</span></span><br><span class="line"><span class="title function_">ngx_shm_alloc</span><span class="params">(<span class="type">ngx_shm_t</span> *shm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>  id;</span><br><span class="line"></span><br><span class="line">    id = shmget(IPC_PRIVATE, shm-&gt;size, (SHM_R|SHM_W|IPC_CREAT));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">-1</span>) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_ALERT, shm-&gt;<span class="built_in">log</span>, ngx_errno,</span><br><span class="line">                      <span class="string">&quot;shmget(%uz) failed&quot;</span>, shm-&gt;size);</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_CORE, shm-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">&quot;shmget id: %d&quot;</span>, id);</span><br><span class="line"></span><br><span class="line">    shm-&gt;addr = shmat(id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shm-&gt;addr == (<span class="type">void</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_ALERT, shm-&gt;<span class="built_in">log</span>, ngx_errno, <span class="string">&quot;shmat() failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shmctl(id, IPC_RMID, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_ALERT, shm-&gt;<span class="built_in">log</span>, ngx_errno,</span><br><span class="line">                      <span class="string">&quot;shmctl(IPC_RMID) failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (shm-&gt;addr == (<span class="type">void</span> *) <span class="number">-1</span>) ? NGX_ERROR : NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="14-2-2-共享内存使用实战–监控"><a href="#14-2-2-共享内存使用实战–监控" class="headerlink" title="14.2.2 共享内存使用实战–监控"></a>14.2.2 共享内存使用实战–监控</h4><p>ngx_http_stub_status_module模块对连接的状态监控就用到了共享内存，因为连接的状况展示的是多个worker进程的统计情况。</p>
<p>模块中使用共享内存保存各种统计指标，在统计过程中使用原子操作对统计指标进行修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在ngx_init_cycle里调用，fork子进程之前</span></span><br><span class="line"><span class="comment">// 创建共享内存，存放负载均衡锁和统计用的原子变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">ngx_int_t</span></span><br><span class="line"><span class="title function_">ngx_event_module_init</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle)</span></span><br><span class="line">&#123;</span><br><span class="line">........</span><br><span class="line">    <span class="comment">// 分配一块共享内存</span></span><br><span class="line">    <span class="keyword">if</span> (ngx_shm_alloc(&amp;shm) != NGX_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shared是共享内存的地址指针</span></span><br><span class="line">    shared = shm.addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个就是负载均衡锁</span></span><br><span class="line">    ngx_accept_mutex_ptr = (<span class="type">ngx_atomic_t</span> *) shared;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spin是-1则不使用信号量</span></span><br><span class="line">    <span class="comment">// 只会自旋，不会导致进程睡眠等待</span></span><br><span class="line">    <span class="comment">// 这样避免抢accept锁时的性能降低</span></span><br><span class="line">    ngx_accept_mutex.spin = (<span class="type">ngx_uint_t</span>) <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    <span class="comment">// spin是-1则不使用信号量</span></span><br><span class="line">    <span class="comment">// 只会自旋，不会导致进程睡眠等待</span></span><br><span class="line">    <span class="keyword">if</span> (ngx_shmtx_create(&amp;ngx_accept_mutex, (<span class="type">ngx_shmtx_sh_t</span> *) shared,</span><br><span class="line">                         cycle-&gt;lock_file.data)</span><br><span class="line">        != NGX_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接计数器</span></span><br><span class="line">    ngx_connection_counter = (<span class="type">ngx_atomic_t</span> *) (shared + <span class="number">1</span> * cl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器置1</span></span><br><span class="line">    (<span class="type">void</span>) ngx_atomic_cmp_set(ngx_connection_counter, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="string">&quot;counter: %p, %uA&quot;</span>,</span><br><span class="line">                   ngx_connection_counter, *ngx_connection_counter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临时文件用</span></span><br><span class="line">    ngx_temp_number = (<span class="type">ngx_atomic_t</span> *) (shared + <span class="number">2</span> * cl);</span><br><span class="line"></span><br><span class="line">    tp = ngx_timeofday();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机数</span></span><br><span class="line">    <span class="comment">// 每个进程不同</span></span><br><span class="line">    ngx_random_number = (tp-&gt;msec &lt;&lt; <span class="number">16</span>) + ngx_pid;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_STAT_STUB)</span></span><br><span class="line"></span><br><span class="line">    ngx_stat_accepted = (<span class="type">ngx_atomic_t</span> *) (shared + <span class="number">3</span> * cl);</span><br><span class="line">    ngx_stat_handled = (<span class="type">ngx_atomic_t</span> *) (shared + <span class="number">4</span> * cl);</span><br><span class="line">    ngx_stat_requests = (<span class="type">ngx_atomic_t</span> *) (shared + <span class="number">5</span> * cl);</span><br><span class="line">    ngx_stat_active = (<span class="type">ngx_atomic_t</span> *) (shared + <span class="number">6</span> * cl);</span><br><span class="line">    ngx_stat_reading = (<span class="type">ngx_atomic_t</span> *) (shared + <span class="number">7</span> * cl);</span><br><span class="line">    ngx_stat_writing = (<span class="type">ngx_atomic_t</span> *) (shared + <span class="number">8</span> * cl);</span><br><span class="line">    ngx_stat_waiting = (<span class="type">ngx_atomic_t</span> *) (shared + <span class="number">9</span> * cl);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="14-3-原子操作"><a href="#14-3-原子操作" class="headerlink" title="14.3 原子操作"></a>14.3 原子操作</h3><h4 id="14-3-1-原子操作方法"><a href="#14-3-1-原子操作方法" class="headerlink" title="14.3.1 原子操作方法"></a>14.3.1 原子操作方法</h4><p>原子操作在不同的架构下实现方式不同，下边是nginx在x86架构下使用嵌入汇编实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> ngx_inline <span class="type">ngx_atomic_uint_t</span></span><br><span class="line"><span class="title function_">ngx_atomic_cmp_set</span><span class="params">(<span class="type">ngx_atomic_t</span> *lock, <span class="type">ngx_atomic_uint_t</span> old,</span></span><br><span class="line"><span class="params">    <span class="type">ngx_atomic_uint_t</span> <span class="built_in">set</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u_char  res;</span><br><span class="line"></span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">        <span class="comment">//锁住总线</span></span></span><br><span class="line"><span class="params">         NGX_SMP_LOCK</span></span><br><span class="line"><span class="params">    <span class="string">&quot;    cmpxchgl  %3, %1;   &quot;</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;    sete      %0;       &quot;</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">    : <span class="string">&quot;=a&quot;</span> (res) : <span class="string">&quot;m&quot;</span> (*lock), <span class="string">&quot;a&quot;</span> (old), <span class="string">&quot;r&quot;</span> (<span class="built_in">set</span>) : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较lock和old的值，如果相等，则把lock设置为set</span></span><br><span class="line">ngx_atomic_cmp_set(<span class="type">ngx_atomic_t</span> *lock, <span class="type">ngx_atomic_uint_t</span> old,</span><br><span class="line">    <span class="type">ngx_atomic_uint_t</span> <span class="built_in">set</span>)；</span><br><span class="line"><span class="comment">//对value的值加上add</span></span><br><span class="line">ngx_atomic_fetch_add(<span class="type">ngx_atomic_t</span> *value, <span class="type">ngx_atomic_int_t</span> add)；</span><br></pre></td></tr></table></figure>

<h4 id="14-3-2-自旋锁"><a href="#14-3-2-自旋锁" class="headerlink" title="14.3.2 自旋锁"></a>14.3.2 自旋锁</h4><p>nginx中基于原子操作实现了spinlock自旋锁，自旋锁不会导致进程睡眠，当发现锁已经被其他进程获得时，则始终保持进程在可执行状态，每当内核调度到这个进程执行时就持续检查是否可以获取到锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自旋锁，尽量不让出cpu抢锁</span></span><br><span class="line"><span class="comment">// 操作原子变量，设置为值value</span></span><br><span class="line"><span class="comment">// spin通常是2048,即2^11</span></span><br><span class="line"><span class="comment">// 目前仅在线程池里需要使用自旋锁</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ngx_spinlock</span><span class="params">(<span class="type">ngx_atomic_t</span> *lock, <span class="type">ngx_atomic_int_t</span> value, <span class="type">ngx_uint_t</span> spin)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须支持原子操作，否则无法编译</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_HAVE_ATOMIC_OPS)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ngx_uint_t</span>  i, n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ;; ) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查lock值，为0表示没有被锁</span></span><br><span class="line">        <span class="comment">// 使用cas操作赋值，成功则获得锁</span></span><br><span class="line">        <span class="comment">// 不会阻塞,失败则继续后续代码</span></span><br><span class="line">        <span class="comment">// 相当于try_lock</span></span><br><span class="line">        <span class="keyword">if</span> (*lock == <span class="number">0</span> &amp;&amp; ngx_atomic_cmp_set(lock, <span class="number">0</span>, value)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多核cpu，不必让出cpu，等待一下</span></span><br><span class="line">        <span class="keyword">if</span> (ngx_ncpu &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// n按2的幂增加</span></span><br><span class="line">            <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; spin; n &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// cpu等待的时间逐步加长</span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    <span class="comment">// #define ngx_cpu_pause()             __asm__ (&quot;pause&quot;)</span></span><br><span class="line">                    <span class="comment">// 自旋等待，降低功耗，不会引起性能下降</span></span><br><span class="line">                    ngx_cpu_pause();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 再次try_lock</span></span><br><span class="line">                <span class="keyword">if</span> (*lock == <span class="number">0</span> &amp;&amp; ngx_atomic_cmp_set(lock, <span class="number">0</span>, value)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 占用cpu过久，让出cpu</span></span><br><span class="line">        <span class="comment">// 单cpu必须让出cpu让其他进程运行</span></span><br><span class="line">        <span class="comment">// 之后继续try_lock，直至lock成功</span></span><br><span class="line">        <span class="comment">// yield不会进入睡眠</span></span><br><span class="line">        ngx_sched_yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not NGX_HAVE_ATOMIC_OPS</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用了--with-threads开启多线程功能</span></span><br><span class="line"><span class="comment">// 但没有原子操作，则无法通过编译</span></span><br><span class="line"><span class="comment">// 因为线程池需要使用自旋锁</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_THREADS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> ngx_spinlock() or ngx_atomic_cmp_set() are not defined !</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用线程池，则自旋锁是空实现</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-4-Nginx频道"><a href="#14-4-Nginx频道" class="headerlink" title="14.4 Nginx频道"></a>14.4 Nginx频道</h3><p>ngx_channel_t频道是Nginx master进程与worker进程之间通信的常用工具， 它是使用本机套接字实现的。 下面先来看看socketpair方法， 它用于创建父子进程间使用的套接字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socketpair</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> type, <span class="type">int</span> protocol, <span class="type">int</span> sv[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>
<p>这个方法可以创建一对关联的套接字sv[2]。 下面依次介绍它的4个参数： 参数d表示域， 在Linux下通常取值为AF_UNIX； type取值为SOCK_STREAM或者SOCK_DGRAM， 它表示在套接字上使用的是TCP还是UDP； protocol必须传递0； sv[2]是一个含有两个元素的整型数组，实际上就是两个套接字。 当socketpair返回0时， sv[2]这两个套接字创建成功， 否则socketpair返回–1表示失败。<br>nginx中的ngx_channel结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">//传递的tcp消息中的命令</span></span><br><span class="line">    <span class="type">ngx_uint_t</span>  command;</span><br><span class="line">    <span class="comment">//进程PID，一般是发送命令方的进程</span></span><br><span class="line">    <span class="type">ngx_pid_t</span>   pid;</span><br><span class="line">    <span class="comment">//表示发送命令方在ngx_processes进程数组间的进程序号</span></span><br><span class="line">    <span class="type">ngx_int_t</span>   slot;</span><br><span class="line">    <span class="comment">//通信的套接字句柄</span></span><br><span class="line">    <span class="type">ngx_fd_t</span>    fd;</span><br><span class="line">&#125; <span class="type">ngx_channel_t</span>;</span><br></pre></td></tr></table></figure>
<p>在nginx中的master进程中创建worker进程前执行创建channel</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ngx_pid_t</span></span><br><span class="line"><span class="title function_">ngx_spawn_process</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle, ngx_spawn_proc_pt proc, <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">    <span class="type">char</span> *name, <span class="type">ngx_int_t</span> respawn)</span></span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">     <span class="comment">// 创建进程间通信用的channel</span></span><br><span class="line">    <span class="keyword">if</span> (respawn != NGX_PROCESS_DETACHED) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Solaris 9 still has no AF_LOCAL */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建socketpair，进程间通信用</span></span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, ngx_processes[s].channel) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ngx_log_error(NGX_LOG_ALERT, cycle-&gt;<span class="built_in">log</span>, ngx_errno,</span><br><span class="line">                          <span class="string">&quot;socketpair() failed while spawning \&quot;%s\&quot;&quot;</span>, name);</span><br><span class="line">            <span class="keyword">return</span> NGX_INVALID_PID;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ngx_log_debug2(NGX_LOG_DEBUG_CORE, cycle-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                       <span class="string">&quot;channel %d:%d&quot;</span>,</span><br><span class="line">                       ngx_processes[s].channel[<span class="number">0</span>],</span><br><span class="line">                       ngx_processes[s].channel[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进程间通信非阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (ngx_nonblocking(ngx_processes[s].channel[<span class="number">0</span>]) == <span class="number">-1</span>) &#123;</span><br><span class="line">            ngx_log_error(NGX_LOG_ALERT, cycle-&gt;<span class="built_in">log</span>, ngx_errno,</span><br><span class="line">                          ngx_nonblocking_n <span class="string">&quot; failed while spawning \&quot;%s\&quot;&quot;</span>,</span><br><span class="line">                          name);</span><br><span class="line">            ngx_close_channel(ngx_processes[s].channel, cycle-&gt;<span class="built_in">log</span>);</span><br><span class="line">            <span class="keyword">return</span> NGX_INVALID_PID;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nginx中目前只是master向worker进程发送，worker进程接收，其实socketpair是双向通信，但目前nginx没有worker向master进程发送的。</p>
<p>操作channel的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ngx_int_t</span> <span class="title function_">ngx_write_channel</span><span class="params">(<span class="type">ngx_socket_t</span> s, <span class="type">ngx_channel_t</span> *ch, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">    <span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span>;</span><br><span class="line"><span class="type">ngx_int_t</span> <span class="title function_">ngx_read_channel</span><span class="params">(<span class="type">ngx_socket_t</span> s, <span class="type">ngx_channel_t</span> *ch, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">    <span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span>;</span><br><span class="line"><span class="type">ngx_int_t</span> <span class="title function_">ngx_add_channel_event</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle, <span class="type">ngx_fd_t</span> fd,</span></span><br><span class="line"><span class="params">    <span class="type">ngx_int_t</span> event, ngx_event_handler_pt handler)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ngx_close_channel</span><span class="params">(<span class="type">ngx_fd_t</span> *fd, <span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>nginx的master进程通过channel向worker进程发送退出、重新打开进程已经打开过的文件等信号，如果使用channel发送失败，则master进程会提供kill系统调用发送。</p>
<h3 id="14-5-信号"><a href="#14-5-信号" class="headerlink" title="14.5 信号"></a>14.5 信号</h3><p>nginx接收信号，执行不同指令，如接收到SIGUSR1信号就意味着需要重新打开文件。<br>定义信号的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标记unix信号，handler=ngx_signal_handler</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">//需要处理的信号</span></span><br><span class="line">    <span class="type">int</span>     signo;</span><br><span class="line">    <span class="comment">//信号对应的字符串名称</span></span><br><span class="line">    <span class="type">char</span>   *signame;</span><br><span class="line">    <span class="comment">//信号对应的Nginx命令</span></span><br><span class="line">    <span class="type">char</span>   *name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原接口：void  (*handler)(int signo);</span></span><br><span class="line">    <span class="comment">// 1.13.0 变动了函数接口</span></span><br><span class="line">    <span class="comment">// 可以多获取一些信号的信息</span></span><br><span class="line">    <span class="comment">//收到信号后执行的回调函数</span></span><br><span class="line">    <span class="type">void</span>  (*handler)(<span class="type">int</span> signo, <span class="type">siginfo_t</span> *siginfo, <span class="type">void</span> *ucontext);</span><br><span class="line">&#125; <span class="type">ngx_signal_t</span>;</span><br></pre></td></tr></table></figure>

<p>Nginx定义了一个数组，用来定义进程将会处理的所有信号：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令行-s参数关联数组</span></span><br><span class="line"><span class="comment">// 所有信号都用ngx_signal_handler处理</span></span><br><span class="line"><span class="type">ngx_signal_t</span>  signals[] = &#123;</span><br><span class="line">    <span class="comment">// #define NGX_RECONFIGURE_SIGNAL   HUP</span></span><br><span class="line">    <span class="comment">// 即sighup</span></span><br><span class="line">    &#123; ngx_signal_value(NGX_RECONFIGURE_SIGNAL),</span><br><span class="line">      <span class="string">&quot;SIG&quot;</span> ngx_value(NGX_RECONFIGURE_SIGNAL),</span><br><span class="line">      <span class="string">&quot;reload&quot;</span>,</span><br><span class="line">      ngx_signal_handler &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #define NGX_REOPEN_SIGNAL        USR1</span></span><br><span class="line">    <span class="comment">// 即sigusr1</span></span><br><span class="line">    &#123; ngx_signal_value(NGX_REOPEN_SIGNAL),</span><br><span class="line">      <span class="string">&quot;SIG&quot;</span> ngx_value(NGX_REOPEN_SIGNAL),</span><br><span class="line">      <span class="string">&quot;reopen&quot;</span>,</span><br><span class="line">      ngx_signal_handler &#125;,</span><br><span class="line"></span><br><span class="line">    &#123; ngx_signal_value(NGX_NOACCEPT_SIGNAL),</span><br><span class="line">      <span class="string">&quot;SIG&quot;</span> ngx_value(NGX_NOACCEPT_SIGNAL),</span><br><span class="line">      <span class="string">&quot;&quot;</span>,</span><br><span class="line">      ngx_signal_handler &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #define NGX_TERMINATE_SIGNAL     TERM</span></span><br><span class="line">    <span class="comment">// sigterm</span></span><br><span class="line">    &#123; ngx_signal_value(NGX_TERMINATE_SIGNAL),</span><br><span class="line">      <span class="string">&quot;SIG&quot;</span> ngx_value(NGX_TERMINATE_SIGNAL),</span><br><span class="line">      <span class="string">&quot;stop&quot;</span>,</span><br><span class="line">      ngx_signal_handler &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #define NGX_SHUTDOWN_SIGNAL      QUIT</span></span><br><span class="line">    <span class="comment">// sigquit</span></span><br><span class="line">    &#123; ngx_signal_value(NGX_SHUTDOWN_SIGNAL),</span><br><span class="line">      <span class="string">&quot;SIG&quot;</span> ngx_value(NGX_SHUTDOWN_SIGNAL),</span><br><span class="line">      <span class="string">&quot;quit&quot;</span>,</span><br><span class="line">      ngx_signal_handler &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ngx_config.h</span></span><br><span class="line">    <span class="comment">// #define NGX_CHANGEBIN_SIGNAL     USR2</span></span><br><span class="line">    <span class="comment">// hot upgrade, kill -s SIGUSR2 masterpid</span></span><br><span class="line">    &#123; ngx_signal_value(NGX_CHANGEBIN_SIGNAL),</span><br><span class="line">      <span class="string">&quot;SIG&quot;</span> ngx_value(NGX_CHANGEBIN_SIGNAL),</span><br><span class="line">      <span class="string">&quot;&quot;</span>,</span><br><span class="line">      ngx_signal_handler &#125;,</span><br><span class="line"></span><br><span class="line">    &#123; SIGALRM, <span class="string">&quot;SIGALRM&quot;</span>, <span class="string">&quot;&quot;</span>, ngx_signal_handler &#125;,</span><br><span class="line"></span><br><span class="line">    &#123; SIGINT, <span class="string">&quot;SIGINT&quot;</span>, <span class="string">&quot;&quot;</span>, ngx_signal_handler &#125;,</span><br><span class="line"></span><br><span class="line">    &#123; SIGIO, <span class="string">&quot;SIGIO&quot;</span>, <span class="string">&quot;&quot;</span>, ngx_signal_handler &#125;,</span><br><span class="line"></span><br><span class="line">    &#123; SIGCHLD, <span class="string">&quot;SIGCHLD&quot;</span>, <span class="string">&quot;&quot;</span>, ngx_signal_handler &#125;,</span><br><span class="line"></span><br><span class="line">    &#123; SIGSYS, <span class="string">&quot;SIGSYS, SIG_IGN&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">NULL</span> &#125;,</span><br><span class="line"></span><br><span class="line">    &#123; SIGPIPE, <span class="string">&quot;SIGPIPE, SIG_IGN&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">NULL</span> &#125;,</span><br><span class="line"></span><br><span class="line">    &#123; <span class="number">0</span>, <span class="literal">NULL</span>, <span class="string">&quot;&quot;</span>, <span class="literal">NULL</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上的所有信号在ngx_init_signals方法中初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化signals数组</span></span><br><span class="line"><span class="type">ngx_int_t</span> <span class="title function_">ngx_init_signals</span><span class="params">(<span class="type">ngx_log_t</span> *<span class="built_in">log</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="14-6-信号量"><a href="#14-6-信号量" class="headerlink" title="14.6 信号量"></a>14.6 信号量</h3><p>信号量与信号不同，信号用来传递消息，信号量用来保证两个或多个代码段不被并发访问，是一种共享资源有序访问的工具。<br>nginx中创建和销毁信号量的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line"><span class="comment">// spin是-1则不使用信号量</span></span><br><span class="line"><span class="comment">// 只会自旋，不会导致进程睡眠等待</span></span><br><span class="line"><span class="type">ngx_int_t</span> <span class="title function_">ngx_shmtx_create</span><span class="params">(<span class="type">ngx_shmtx_t</span> *mtx, <span class="type">ngx_shmtx_sh_t</span> *addr,</span></span><br><span class="line"><span class="params">    u_char *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁使用的信号量</span></span><br><span class="line"><span class="comment">// spin是-1则不使用信号量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ngx_shmtx_destroy</span><span class="params">(<span class="type">ngx_shmtx_t</span> *mtx)</span>;</span><br></pre></td></tr></table></figure>
<p>信号量是如何实现互斥锁功能的呢？ 例如， 最初的信号量sem值为0， 调用sem_post方法将会把sem值加1， 这个操作不会有任何阻塞； 调用sem_wait方法将会把信号量sem的值减1， 如果sem值已经小于或等于0了， 则阻塞住当前进程（进程会进入睡眠状态） ， 直到其他进程将信号量sem的值改变为正数后， 这时才能继续通过将sem减1而使得当前进程继续向下执行。 因此， sem_post方法可以实现解锁的功能， 而sem_wait方法可以实现加锁的功能。</p>
<p>在ngx_shmtx_lock中可能用到信号量中sem_wait试图获取锁。</p>
<h3 id="14-7-文件锁"><a href="#14-7-文件锁" class="headerlink" title="14.7 文件锁"></a>14.7 文件锁</h3><p>Linux内核提供了基于文件的互斥锁， 而Nginx框架封装了3个方法， 提供给Nginx模块使用文件互斥锁来保护共享数据。 下面首先介绍一下这种基于文件的互斥锁是如何使用的， 其实很简单， 通过fcntl方法就可以实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="keyword">struct</span> flock *lock)</span>;</span><br></pre></td></tr></table></figure>
<p>其中参数fd是打开的文件句柄， 参数cmd表示执行的锁操作， 参数lock描述了这个锁的信息。<br>参数fd必须是已经成功打开的文件句柄。 实际上， nginx.conf文件中的lock_file配置项指定的文件路径， 就是用于文件互斥锁的， 这个文件被打开后得到的句柄， 将会作为fd参数传递给fcntl方法， 提供一种锁机制。<br>这里的cmd参数在Nginx中只会有两个值： F_SETLK和F_SETLKW， 它们都表示试图获得互斥锁， 但使用F_SETLK时如果互斥锁已经被其他进程占用， fcntl方法不会等待其他进程释放锁且自己拿到锁后才返回， 而是立即返回获取互斥锁失败； 使用F_SETLKW时则不同， 锁被占用后fcntl方法会一直等待， 在其他进程没有释放锁时， 当前进程就会阻塞在fcntl方法中， 这种阻塞会导致当前进程由可执行状态转为睡眠状态。</p>
<p>关于文件锁的实现函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx_err_t ngx_trylock_fd(ngx_fd_t fd);</span><br><span class="line">ngx_err_t ngx_lock_fd(ngx_fd_t fd);</span><br><span class="line">ngx_err_t ngx_unlock_fd(ngx_fd_t fd);</span><br></pre></td></tr></table></figure>
<p>在使用文件锁是要注意是否会导致进程睡眠，根据实际情况抉择。</p>
<h3 id="14-8-互斥锁"><a href="#14-8-互斥锁" class="headerlink" title="14.8 互斥锁"></a>14.8 互斥锁</h3><p>基于原子操作、信号量、文件锁，nginx在更高层次封装了一个互斥锁，许多Nginx模块也是更多直接使用它。操作方法如下：</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230410164924.png"></p>
<p>互斥锁接口的内部实现中使用了原子操作、信号量和文件锁，可以通过参数控制使用什么逻辑。<br>以上接口都是通过操作ngx_shmtx_t类型的结构体来实现互斥操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ngx_shmtx_sh_t</span></span><br><span class="line"><span class="comment">// 互斥锁使用的两个原子变量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁变量</span></span><br><span class="line">    <span class="comment">// 使用原子操作实现锁</span></span><br><span class="line">    <span class="type">ngx_atomic_t</span>   lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 信号量等待变量</span></span><br><span class="line">    <span class="comment">// 标记等待的进程数量</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_HAVE_POSIX_SEM)</span></span><br><span class="line">    <span class="type">ngx_atomic_t</span>   wait;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="type">ngx_shmtx_sh_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ngx_shmtx_t</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_HAVE_ATOMIC_OPS)</span></span><br><span class="line">    <span class="comment">// 指向ngx_shmtx_sh_t.lock</span></span><br><span class="line">    <span class="type">ngx_atomic_t</span>  *lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用进程间信号量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (NGX_HAVE_POSIX_SEM)</span></span><br><span class="line">    <span class="comment">// 指向ngx_shmtx_sh_t.wait</span></span><br><span class="line">    <span class="type">ngx_atomic_t</span>  *wait;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否使用信号量的标志</span></span><br><span class="line">    <span class="comment">// 可以手动置0强制不使用信号量</span></span><br><span class="line">    <span class="type">ngx_uint_t</span>     semaphore;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unix信号量对象</span></span><br><span class="line">    <span class="type">sem_t</span>          sem;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不会使用文件锁</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">ngx_fd_t</span>       fd;</span><br><span class="line">    u_char        *name;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类似自旋锁的等待周期</span></span><br><span class="line">    <span class="comment">// spin是-1则不使用信号量</span></span><br><span class="line">    <span class="comment">// 只会自旋，不会导致进程睡眠等待</span></span><br><span class="line">    <span class="comment">// 目前只有accept_mutex使用了-1</span></span><br><span class="line">    <span class="type">ngx_uint_t</span>     spin;</span><br><span class="line">&#125; <span class="type">ngx_shmtx_t</span>;</span><br></pre></td></tr></table></figure>
<p>在函数中Nginx也会判断当前环境是否支持原子操作，信号量、文件锁等。然后执行对应的分支。</p>
<h3 id="14-9-总结"><a href="#14-9-总结" class="headerlink" title="14.9 总结"></a>14.9 总结</h3><p>Nginx是一个能够并发处理几十万甚至几百万个TCP连接的高性能服务器， 因此， 在进行进程间通信时， 必须充分考虑到不能过分影响正常请求的处理。 例如， 使用14.4节介绍的套接字通信时， 套接字都被设为了无阻塞模式， 防止执行时阻塞了进程导致其他请求得不到处理， 又如， Nginx封装的锁都不会直接使用信号量， 因为一旦获取信号量互斥锁失败， 进程就会进入睡眠状态， 这会导致其他请求“饿死”。<br>当用户开发复杂的Nginx模块时， 可能会涉及不同的worker进程间通信， 这时可以从本章介绍的进程间通信方式上进行选择， 从使用上说， ngx_shmtx_t互斥锁和共享内存应当是第三方Nginx模块最常用的进程间通信方式了， ngx_shmtx_t互斥锁在实现中充分考虑了是否引发睡眠的问题， 用户在使用时需要明确地判断出是否会引发进程睡眠。 当然， 如果不使用Nginx封装过的进程间通信方式， 则需要注意跨平台，以及是否会阻塞进程的运行等问题。</p>
<h2 id="16-slab共享内存"><a href="#16-slab共享内存" class="headerlink" title="16 slab共享内存"></a>16 slab共享内存</h2><p>在Nginx中多个Woker进程共享数据，如果是简单的进程间通信，可以使用以上的方式，如果需要共享不同大小的结构对象，如链表、树、图等，可以通过一段共享内存进行共享，为了高效的管理共享内存，Nginx使用了slab内存管理机制。</p>
<h3 id="16-1-操作slab的方法"><a href="#16-1-操作slab的方法" class="headerlink" title="16.1 操作slab的方法"></a>16.1 操作slab的方法</h3><p>slab中只有下边5个接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化新创建的共享内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ngx_slab_init</span><span class="params">(<span class="type">ngx_slab_pool_t</span> *pool)</span>;</span><br><span class="line"><span class="comment">// 加锁保护的内存分配方法</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">ngx_slab_alloc</span><span class="params">(<span class="type">ngx_slab_pool_t</span> *pool, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">// 不加锁保护的内存分配方法</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">ngx_slab_alloc_locked</span><span class="params">(<span class="type">ngx_slab_pool_t</span> *pool, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">// 加锁保护的内存释放方法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ngx_slab_free</span><span class="params">(<span class="type">ngx_slab_pool_t</span> *pool, <span class="type">void</span> *p)</span>;</span><br><span class="line"><span class="comment">// 不加锁保护的内存释放方法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ngx_slab_free_locked</span><span class="params">(<span class="type">ngx_slab_pool_t</span> *pool, <span class="type">void</span> *p)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="16-2-使用slab共享内存示例（未看）"><a href="#16-2-使用slab共享内存示例（未看）" class="headerlink" title="16.2 使用slab共享内存示例（未看）"></a>16.2 使用slab共享内存示例（未看）</h3><h3 id="16-3-slab内存管理实现原理"><a href="#16-3-slab内存管理实现原理" class="headerlink" title="16.3 slab内存管理实现原理"></a>16.3 slab内存管理实现原理</h3><p>slab中把整块内存按4KB分整许多页，每一页只存固定大小的内存块，由于一页上能够分配的内存块数量是有限的，可以在页首用bitmap方式，按二进制位表示页对应位置的内存块是否在使用中。只是遍历bitmap二进制位去寻找页上的空闲内存块， 使得消耗的时间很有限， 例如bitmap占用的内存空间小导致CPU缓存命中率高， 可以按32或64位这样的总线长度去寻找空闲位以减少访问次数等。<br>关于对页的管理，分为空闲页、半满页和全满页，不同的页通过链表维护。<br>slab会把一页分成不同的内存块大小，内存块分为8，16，32，64.。。。字节。当申请的字节数大于8小于等于16时， 就会使用16字节的内存块， 以此类推。<br>按照不同页中含有的内存块大小分类，然后包含相同内存块大小的页组成页链表，并且页的首部放在slots数组中，slots数组也是按序排列，比如开始元素存放的地址是8字节内存块所属页的链表，依次递增。</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230411111313.png"></p>
<p>上图包含了空闲页、半满页、全满页的链表和分别存在两个slot中。</p>
<p>slab中使用ngx_slab_pool_t结构管理共享内存，在常见slab后，ngx_slab_pool_t结构存储在共享内存开始位置，并且通过初始化结构中的属性管理后边的内存。结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ngx_slab_pool_t</span></span><br><span class="line"><span class="comment">// 管理共享内存的池</span></span><br><span class="line"><span class="comment">// 存放page管理信息、空闲页数量、共享内存的开始地址等</span></span><br><span class="line"><span class="comment">// 64位系统上占用200个字节</span></span><br><span class="line"><span class="comment">// 使用best fit算法</span></span><br><span class="line"><span class="comment">// 分成8/16/32...2k/4k的多个slot，找最合适的分配</span></span><br><span class="line"><span class="comment">// 但也可以直接管理内部的非共享内存</span></span><br><span class="line"><span class="comment">// 不使用锁即可</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 互斥锁使用的两个原子变量</span></span><br><span class="line">    <span class="type">ngx_shmtx_sh_t</span>    lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最小分配数量，通常是8字节</span></span><br><span class="line">    <span class="type">size_t</span>            min_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最小左移，通常是3，即2^3=8</span></span><br><span class="line">    <span class="comment">// ngx_init_zone_pool里设置</span></span><br><span class="line">    <span class="comment">// 在shm_zone[i].init之前，不能自己修改</span></span><br><span class="line">    <span class="type">size_t</span>            min_shift;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页数组</span></span><br><span class="line">    <span class="comment">// 4k大小，对齐管理内存</span></span><br><span class="line">    <span class="type">ngx_slab_page_t</span>  *pages;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页链表指针，最后一页</span></span><br><span class="line">    <span class="comment">// 用于合并空闲页的末尾计算</span></span><br><span class="line">    <span class="type">ngx_slab_page_t</span>  *last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空闲页链表头节点</span></span><br><span class="line">    <span class="comment">// 也作为链表的尾节点哨兵</span></span><br><span class="line">    <span class="comment">// 注意不是指针</span></span><br><span class="line">    <span class="type">ngx_slab_page_t</span>   <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计信息数组</span></span><br><span class="line">    <span class="comment">// 在slots之后</span></span><br><span class="line">    <span class="comment">// 目前供商业模块ngx_api来调用</span></span><br><span class="line">    <span class="comment">// 目前暂无公开接口使用</span></span><br><span class="line">    <span class="comment">// 只能自己定位获取信息</span></span><br><span class="line">    <span class="type">ngx_slab_stat_t</span>  *stats;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空闲页数量</span></span><br><span class="line">    <span class="type">ngx_uint_t</span>        pfree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享内存的开始地址</span></span><br><span class="line">    <span class="comment">// 经过了多次计算，前面有很多管理信息</span></span><br><span class="line">    u_char           *start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享内存的末尾地址</span></span><br><span class="line">    <span class="comment">// 使用start和end来判断指针是否属于本内存</span></span><br><span class="line">    u_char           *end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 互斥锁</span></span><br><span class="line">    <span class="comment">// mtx.lock指向sh.lock</span></span><br><span class="line">    <span class="comment">// ngx_shmtx_create():mtx-&gt;lock = &amp;addr-&gt;lock;</span></span><br><span class="line">    <span class="type">ngx_shmtx_t</span>       mutex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录日志的额外字符串，用户可以指定</span></span><br><span class="line">    <span class="comment">// 共享内存错误记录日志时区分不同的共享内存</span></span><br><span class="line">    <span class="comment">// 不指定则指向zero，即无特殊字符串</span></span><br><span class="line">    <span class="comment">// 被ngx_slab_error使用，外界不能用</span></span><br><span class="line">    u_char           *log_ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#x27;\0&#x27;字符</span></span><br><span class="line">    u_char            zero;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否记录无内存异常</span></span><br><span class="line">    <span class="comment">// 可以置为0,减少记录日志的操作</span></span><br><span class="line">    <span class="type">unsigned</span>          log_nomem:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 供用户使用，关联任意数据</span></span><br><span class="line">    <span class="comment">// 方便使用本内存里最常用的数据</span></span><br><span class="line">    <span class="comment">// 例如红黑树指针</span></span><br><span class="line">    <span class="type">void</span>             *data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存的起始地址</span></span><br><span class="line">    <span class="comment">// 在ngx_init_zone_pool时检测内存是否正确</span></span><br><span class="line">    <span class="type">void</span>             *addr;</span><br><span class="line">&#125; <span class="type">ngx_slab_pool_t</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230411111607.png"></p>
<p>下边是一个页的结构ngx_slab_page_t</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ngx_slab_page_t</span></span><br><span class="line"><span class="comment">// slab页信息</span></span><br><span class="line"><span class="comment">// 管理每个内存页</span></span><br><span class="line"><span class="comment">// 只有三个指针大小，64位系统上是3*8=24字节</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_slab_page_s</span> &#123;</span></span><br><span class="line">    <span class="comment">// 有多种含义：</span></span><br><span class="line">    <span class="comment">// 指示连续空闲页的数量,NGX_SLAB_PAGE</span></span><br><span class="line">    <span class="comment">// 标记页面的状态：busy</span></span><br><span class="line">    <span class="comment">// 位图方式标记页面内部的使用情况</span></span><br><span class="line">    <span class="type">uintptr_t</span>         slab;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后链表指针，串联多个可分配内存页</span></span><br><span class="line">    <span class="comment">// 全满页的next是null</span></span><br><span class="line">    <span class="type">ngx_slab_page_t</span>  *next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 半满页指向管理头节点</span></span><br><span class="line">    <span class="comment">// prev的后两位标记页类型</span></span><br><span class="line">    <span class="comment">// 全满页低位作为页标记</span></span><br><span class="line">    <span class="comment">// ngx_slab_page_prev计算</span></span><br><span class="line">    <span class="type">uintptr_t</span>         prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果页链表中有多个连续页空闲，则可以进行合并，合并后页的数量计入slab中，然后修改页的next指针，指向后边的页。</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230411111950.png"><br>上边有5个页，其中有连续的页，如上边slab&#x3D;2，全满页会脱离链表，所以next和prev指针为0。</p>
<p>ngx_slab_max_size指定了最大内存块的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大slab，是page的一半</span></span><br><span class="line"><span class="comment">// 超过此大小则直接分配整页</span></span><br><span class="line"><span class="comment">// ngx_pagesize是4k</span></span><br><span class="line">ngx_slab_max_size = ngx_pagesize / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>分配内存流程：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20230411112227.png"></p>
<blockquote>
<p>通过slots数组管理包含相同类型内存块大小的页面，slots数组有序，通过线性偏移，则可以直接找到需要的内存块大小所属页面链表地址，然后在页链表中找能满足的页，如果分配的内存大于了ngx_slab_max_size，则直接分配空闲页，如果小于则看看有没有半满页能满足，在页内部包含多个内存块，通过bitmap管理，标识内存块是否可用。如果bitmap全部可用，则表示当前页为全满页，则加入全满页链表。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://baihlup.github.io">梦之痕</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://baihlup.github.io/2024/02/04/260%20-%20%E5%90%8E%E7%AB%AF&amp;%E6%9E%B6%E6%9E%84/263%20-%20%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/05%20-%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Nginx%EF%BC%9A%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/">https://baihlup.github.io/2024/02/04/260%20-%20%E5%90%8E%E7%AB%AF&amp;%E6%9E%B6%E6%9E%84/263%20-%20%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/05%20-%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Nginx%EF%BC%9A%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Nginx/">Nginx</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/02/05/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/279%20-%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/01%20-%20REUSEADDR%20%E5%92%8CREUSEPORT%20%E5%AF%B9TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%8E%A7%E5%88%B6/" title="REUSEADDR 和REUSEPORT 对TCP连接的控制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">REUSEADDR 和REUSEPORT 对TCP连接的控制</div></div></a></div><div class="next-post pull-right"><a href="/2024/02/04/260%20-%20%E5%90%8E%E7%AB%AF&amp;%E6%9E%B6%E6%9E%84/269%20-%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/01%20-%20%E9%83%A8%E7%BD%B2Nginx%E6%90%AD%E5%BB%BAHTTPS%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="部署Nginx搭建HTTPS服务器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">部署Nginx搭建HTTPS服务器</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/02/04/260%20-%20%E5%90%8E%E7%AB%AF&%E6%9E%B6%E6%9E%84/269%20-%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/01%20-%20%E9%83%A8%E7%BD%B2Nginx%E6%90%AD%E5%BB%BAHTTPS%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="部署Nginx搭建HTTPS服务器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-04</div><div class="title">部署Nginx搭建HTTPS服务器</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">梦之痕</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/BaihlUp"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">个人笔记迁移中ing....</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.</span> <span class="toc-text">0 参考资料</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99HTTP%E6%A8%A1%E5%9D%97"><span class="toc-number">2.</span> <span class="toc-text">2 如何编写HTTP模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-Nginx%E6%8F%90%E4%BE%9B%E7%9A%84%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">2.7 Nginx提供的高级数据结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E9%83%A8%E5%88%86-%E6%B7%B1%E5%85%A5Nginx"><span class="toc-number">3.</span> <span class="toc-text">第3部分 深入Nginx</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Nginx-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">8 Nginx 基础架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-Nginx%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.1.1.</span> <span class="toc-text">8.2.1 Nginx的模块化设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6"><span class="toc-number">3.1.2.</span> <span class="toc-text">8.2.2 事件驱动框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-3-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%A4%9A%E9%98%B6%E6%AE%B5%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86"><span class="toc-number">3.1.3.</span> <span class="toc-text">8.2.3 请求的多阶段异步处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-HTTP%E6%A1%86%E6%9E%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">11 HTTP框架的执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-HTTP%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">11.1 HTTP处理流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E8%AF%BBHTTP%E8%AF%B7%E6%B1%82%E7%8A%B6%E6%80%81%E6%9C%BA%E6%B5%81%E7%A8%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">11.2 读HTTP请求状态机流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-checker%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.3.</span> <span class="toc-text">11.3 checker方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-subrequest%E4%B8%8Epost%E8%AF%B7%E6%B1%82"><span class="toc-number">3.2.4.</span> <span class="toc-text">11.4 subrequest与post请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-%E5%A4%84%E7%90%86HTTP%E5%8C%85%E4%BD%93"><span class="toc-number">3.2.5.</span> <span class="toc-text">11.5 处理HTTP包体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6-%E5%8F%91%E9%80%81HTTP%E5%93%8D%E5%BA%94"><span class="toc-number">3.2.6.</span> <span class="toc-text">11.6 发送HTTP响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-7-%E7%BB%93%E6%9D%9FHTTP%E8%AF%B7%E6%B1%82"><span class="toc-number">3.2.7.</span> <span class="toc-text">11.7 结束HTTP请求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-upstream%E6%9C%BA%E5%88%B6%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.</span> <span class="toc-text">12 upstream机制的设计与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-upstream%E6%9C%BA%E5%88%B6"><span class="toc-number">3.3.1.</span> <span class="toc-text">12.1 upstream机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E5%90%AF%E5%8A%A8upstream"><span class="toc-number">3.3.2.</span> <span class="toc-text">12.2 启动upstream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-%E4%B8%8E%E4%B8%8A%E6%B8%B8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.3.3.</span> <span class="toc-text">12.3 与上游服务器建立连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-%E6%8E%A5%E6%94%B6%E4%B8%8A%E6%B8%B8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%93%8D%E5%BA%94%E5%A4%B4%E9%83%A8"><span class="toc-number">3.3.4.</span> <span class="toc-text">12.4 接收上游服务器的响应头部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-%E4%BB%A5%E4%B8%8B%E6%B8%B8%E7%BD%91%E9%80%9F%E4%BC%98%E5%85%88%E6%9D%A5%E8%BD%AC%E5%8F%91%E5%93%8D%E5%BA%94"><span class="toc-number">3.3.5.</span> <span class="toc-text">12.5 以下游网速优先来转发响应</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-5-1-%E8%BD%AC%E5%8F%91%E5%93%8D%E5%BA%94%E7%9A%84%E5%8C%85%E5%A4%B4"><span class="toc-number">3.3.5.1.</span> <span class="toc-text">12.5.1 转发响应的包头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-5-2-%E8%BD%AC%E5%8F%91%E5%93%8D%E5%BA%94%E5%8C%85%E4%BD%93"><span class="toc-number">3.3.5.2.</span> <span class="toc-text">12.5.2 转发响应包体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-6-%E4%BB%A5%E4%B8%8A%E6%B8%B8%E7%BD%91%E9%80%9F%E4%BC%98%E5%85%88%E6%9D%A5%E8%BD%AC%E5%8F%91%E5%93%8D%E5%BA%94"><span class="toc-number">3.3.6.</span> <span class="toc-text">12.6 以上游网速优先来转发响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-7-%E7%BB%93%E6%9D%9Fupstream%E8%AF%B7%E6%B1%82"><span class="toc-number">3.3.7.</span> <span class="toc-text">12.7 结束upstream请求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">3.4.</span> <span class="toc-text">14 进程间的通信机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">3.4.1.</span> <span class="toc-text">14.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">3.4.2.</span> <span class="toc-text">14.2 共享内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-1-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">14.2.1 共享内存创建和销毁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-2-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E5%AE%9E%E6%88%98%E2%80%93%E7%9B%91%E6%8E%A7"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">14.2.2 共享内存使用实战–监控</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">3.4.3.</span> <span class="toc-text">14.3 原子操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-1-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">14.3.1 原子操作方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-2-%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">14.3.2 自旋锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-Nginx%E9%A2%91%E9%81%93"><span class="toc-number">3.4.4.</span> <span class="toc-text">14.4 Nginx频道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-%E4%BF%A1%E5%8F%B7"><span class="toc-number">3.4.5.</span> <span class="toc-text">14.5 信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-6-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">3.4.6.</span> <span class="toc-text">14.6 信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-7-%E6%96%87%E4%BB%B6%E9%94%81"><span class="toc-number">3.4.7.</span> <span class="toc-text">14.7 文件锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-8-%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">3.4.8.</span> <span class="toc-text">14.8 互斥锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-9-%E6%80%BB%E7%BB%93"><span class="toc-number">3.4.9.</span> <span class="toc-text">14.9 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-slab%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">3.5.</span> <span class="toc-text">16 slab共享内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-%E6%93%8D%E4%BD%9Cslab%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.1.</span> <span class="toc-text">16.1 操作slab的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-%E4%BD%BF%E7%94%A8slab%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%A4%BA%E4%BE%8B%EF%BC%88%E6%9C%AA%E7%9C%8B%EF%BC%89"><span class="toc-number">3.5.2.</span> <span class="toc-text">16.2 使用slab共享内存示例（未看）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-slab%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.5.3.</span> <span class="toc-text">16.3 slab内存管理实现原理</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/15/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/279%20-%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/05%20-%20%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%94%A8%E5%8F%8C%E5%8D%81%E4%B8%80%E7%9A%84%E6%95%85%E4%BA%8B%E4%B8%B2%E8%B5%B7%E7%A2%8E%E7%89%87%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8A%EF%BC%89/" title="Untitled">Untitled</a><time datetime="2024-10-15T08:56:21.453Z" title="Created 2024-10-15 08:56:21">2024-10-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/15/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/279%20-%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/06%20-%20%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%94%A8%E5%8F%8C%E5%8D%81%E4%B8%80%E7%9A%84%E6%95%85%E4%BA%8B%E4%B8%B2%E8%B5%B7%E7%A2%8E%E7%89%87%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%AD%EF%BC%89/" title="Untitled">Untitled</a><time datetime="2024-10-15T08:56:21.453Z" title="Created 2024-10-15 08:56:21">2024-10-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/15/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/279%20-%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/07%20-%20%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%94%A8%E5%8F%8C%E5%8D%81%E4%B8%80%E7%9A%84%E6%95%85%E4%BA%8B%E4%B8%B2%E8%B5%B7%E7%A2%8E%E7%89%87%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8B%EF%BC%89/" title="Untitled">Untitled</a><time datetime="2024-10-15T08:56:21.453Z" title="Created 2024-10-15 08:56:21">2024-10-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/15/260%20-%20%E5%90%8E%E7%AB%AF&amp;%E6%9E%B6%E6%9E%84/261%20-%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02%20-%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/" title="Untitled">Untitled</a><time datetime="2024-10-15T08:56:21.449Z" title="Created 2024-10-15 08:56:21">2024-10-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/28/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/279%20-%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/02%20-%20%E8%AE%B0%E5%BD%95%E8%AE%BF%E9%97%AE%20HTTPS%20%E7%BD%91%E7%AB%99%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/" title="记录访问 HTTPS 网站报错问题">记录访问 HTTPS 网站报错问题</a><time datetime="2024-09-28T00:00:00.000Z" title="Created 2024-09-28 00:00:00">2024-09-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 梦之痕</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>