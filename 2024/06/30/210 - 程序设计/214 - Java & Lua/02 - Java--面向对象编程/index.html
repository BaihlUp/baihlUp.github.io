<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java--面向对象编程 | 梦之痕</title><meta name="author" content="梦之痕"><meta name="copyright" content="梦之痕"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1 类和对象1.1 类的定义 是用来描述同一类事物的 可以在内部定义任意数量的、不同类型的变量，作为这一类事物的属性。这种属性叫做成员变量 ( member variable )。 如果一个Java文件中定义了一个public类，则文件名必须与该类的名称相同，包括大小写。 如果一个Java文件中定义了多个类，则只能有一个public类，该类的名称必须与文件名相同。 就好像文件路径+文件名不能重复一">
<meta property="og:type" content="article">
<meta property="og:title" content="Java--面向对象编程">
<meta property="og:url" content="https://baihlup.github.io/2024/06/30/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/214%20-%20Java%20&%20Lua/02%20-%20Java--%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="梦之痕">
<meta property="og:description" content="1 类和对象1.1 类的定义 是用来描述同一类事物的 可以在内部定义任意数量的、不同类型的变量，作为这一类事物的属性。这种属性叫做成员变量 ( member variable )。 如果一个Java文件中定义了一个public类，则文件名必须与该类的名称相同，包括大小写。 如果一个Java文件中定义了多个类，则只能有一个public类，该类的名称必须与文件名相同。 就好像文件路径+文件名不能重复一">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg">
<meta property="article:published_time" content="2024-06-30T00:00:00.000Z">
<meta property="article:modified_time" content="2025-03-11T01:00:27.629Z">
<meta property="article:author" content="梦之痕">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="程序设计">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://baihlup.github.io/2024/06/30/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/214%20-%20Java%20&amp;%20Lua/02%20-%20Java--%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java--面向对象编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-11 01:00:27'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">44</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="梦之痕"><span class="site-name">梦之痕</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java--面向对象编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-06-30T00:00:00.000Z" title="Created 2024-06-30 00:00:00">2024-06-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-03-11T01:00:27.629Z" title="Updated 2025-03-11 01:00:27">2025-03-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java-Lua/">Java &amp; Lua</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java--面向对象编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1 类和对象"></a>1 类和对象</h1><h2 id="1-1-类的定义"><a href="#1-1-类的定义" class="headerlink" title="1.1 类的定义"></a>1.1 类的定义</h2><ol>
<li>是用来描述同一类事物的</li>
<li>可以在内部定义任意数量的、不同类型的变量，作为这一类事物的属性。这种属性叫做成员变量 ( member variable )。</li>
<li>如果一个Java文件中定义了一个public类，则文件名必须与该类的名称相同，包括大小写。</li>
<li>如果一个Java文件中定义了多个类，则只能有一个public类，该类的名称必须与文件名相同。</li>
<li>就好像文件路径+文件名不能重复一样，一个Java程序中相同名字的类只能有一个</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt; TODO 一个类以public class开头，public class代表这个类是公共类，类名必须和文件名相同。</span></span><br><span class="line"><span class="comment">// &gt;&gt; TODO public class后面紧跟类名，然后是一对打括号的类体</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Merchandise</span> &#123;</span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 类体中可以定义描述这个类的属性的变量。我们称之为成员变量（member variable）</span></span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 每个成员变量的定义以;结束</span></span><br><span class="line">    String name;</span><br><span class="line">    String id;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt;&gt; TODO 上面这整个类，其实就是创建了一个模版。描述了一种我们需要的数据类型。</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-匿名对象"><a href="#1-2-匿名对象" class="headerlink" title="1.2 匿名对象"></a>1.2 匿名对象</h2><p>可以不定义对象的句柄，而直接调用这个对象的方法，如下：<code>new Person().shout();</code><br>使用情况：</p>
<ul>
<li>如果一个对象只需要执行一次方法调用，那么就可以使用匿名对象</li>
<li>将匿名对象作为实参传递给一个方法调用</li>
</ul>
<h2 id="1-3-引用类型"><a href="#1-3-引用类型" class="headerlink" title="1.3 引用类型"></a>1.3 引用类型</h2><p>Java中的数据类型分为基本数据类型和引用数据类型</p>
<ul>
<li><strong>引用数据类型和基本数据类型的相同点</strong></li>
</ul>
<ol>
<li>都可以用来创建变量，可以赋值和使用其值</li>
<li>本身都是一个地址</li>
</ol>
<ul>
<li><strong>引用数据类型和基本数据类型的不同点</strong></li>
</ul>
<ol>
<li>基本类型变量的值，就是地址对应的值。引用数据类型的值还是一个地址，需要通过“二级跳”找到实例</li>
<li>引用数据类型是Java的一种内部类型，是对所有自定义类型和数组引用的统称，并非特指某种类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Merchandise</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String id;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Merchandise</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String id;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceAndPrimaryDataType</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt; TODO m1是一个Merchandise类型的引用，只能指向Merchandise类型的实例</span></span><br><span class="line">        <span class="comment">// &gt;&gt; TODO 引用数据类型变量包含两部分信息：类型和实例。也就是说，</span></span><br><span class="line">        <span class="comment">//    TODO 每一个引用数据类型的变量（简称引用），都是指向某个类（ class /自定义类型）</span></span><br><span class="line">        <span class="comment">//    TODO 的一个实例/对象（instance / object）。不同类型的引用在Java的世界里都是引用。</span></span><br><span class="line">        <span class="comment">// &gt;&gt; TODO 引用的类型信息在创建时就已经确定，可以通过给引用赋值，让其指向不同的实例.</span></span><br><span class="line">        <span class="comment">//         比如 m1 就是Merchandise类型，只能指向Merchandise的实例。</span></span><br><span class="line">        Merchandise m1;</span><br><span class="line">        m1 = <span class="keyword">new</span> <span class="title class_">Merchandise</span>();</span><br><span class="line">        <span class="type">Merchandise</span> <span class="variable">m2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Merchandise</span>();</span><br><span class="line">        <span class="type">Merchandise</span> <span class="variable">m3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Merchandise</span>();</span><br><span class="line">        <span class="type">Merchandise</span> <span class="variable">m4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Merchandise</span>();</span><br><span class="line">        <span class="type">Merchandise</span> <span class="variable">m5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Merchandise</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt; TODO 给一个引用赋值，则两者的类型必须一样。m5可以给m1赋值，因为他们类型是一样的</span></span><br><span class="line">        m1 = m5;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;m1=&quot;</span> + m1);</span><br><span class="line">        System.out.println(<span class="string">&quot;m2=&quot;</span> + m2);</span><br><span class="line">        System.out.println(<span class="string">&quot;m3=&quot;</span> + m3);</span><br><span class="line">        System.out.println(<span class="string">&quot;m4=&quot;</span> + m4);</span><br><span class="line">        System.out.println(<span class="string">&quot;m5=&quot;</span> + m5);</span><br><span class="line"></span><br><span class="line">        <span class="type">Merchandise</span> <span class="variable">m6</span> <span class="operator">=</span> m1;</span><br><span class="line">        System.out.println(<span class="string">&quot;m6=&quot;</span> + m6);</span><br><span class="line">        m6 = m5;</span><br><span class="line">        System.out.println(<span class="string">&quot;m6=&quot;</span> + m6);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;m1=&quot;</span> + m1);</span><br><span class="line">        System.out.println(<span class="string">&quot;m2=&quot;</span> + m2);</span><br><span class="line">        System.out.println(<span class="string">&quot;m3=&quot;</span> + m3);</span><br><span class="line">        System.out.println(<span class="string">&quot;m4=&quot;</span> + m4);</span><br><span class="line">        System.out.println(<span class="string">&quot;m5=&quot;</span> + m5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">m1=Merchandise@1b6d3586</span><br><span class="line">m2=Merchandise@4554617c</span><br><span class="line">m3=Merchandise@74a14482</span><br><span class="line">m4=Merchandise@1540e19d</span><br><span class="line">m5=Merchandise@1b6d3586</span><br><span class="line">m6=Merchandise@1b6d3586</span><br><span class="line">m6=Merchandise@1b6d3586</span><br><span class="line">m1=Merchandise@1b6d3586</span><br><span class="line">m2=Merchandise@4554617c</span><br><span class="line">m3=Merchandise@74a14482</span><br><span class="line">m4=Merchandise@1540e19d</span><br><span class="line">m5=Merchandise@1b6d3586</span><br></pre></td></tr></table></figure>
<p>以上的m1 &#x3D;&#x3D; m5 &#x3D;&#x3D; m6，引用的地址一样。</p>
<h2 id="1-4-类对象和引用的关系"><a href="#1-4-类对象和引用的关系" class="headerlink" title="1.4 类对象和引用的关系"></a>1.4 类对象和引用的关系</h2><ul>
<li><strong>类和对象的关系</strong></li>
</ul>
<ol>
<li>类是对象的模版，对象是类的一个实例</li>
<li>一个Java程序中类名相同的类只能有一个，也就是类型不会重名</li>
<li>一个类可以有很多对象</li>
<li>一个对象只能根据一个类来创建</li>
</ol>
<ul>
<li><strong>引用和类以及对象的关系</strong></li>
</ul>
<ol>
<li>引用必须是、只能是一个类的引用</li>
<li>引用只能指向其所属的类型的类的对象</li>
<li>相同类型的引用之间可以赋值</li>
<li>只能通过指向一个对象的引用，来操作一个对象，比如访问某个成员变量</li>
</ol>
<ul>
<li><strong>数组是一种特殊的类</strong></li>
</ul>
<ol>
<li>数组的类名就是类型带上中括号</li>
<li>同一类型的数组，每个数组对象的大小可以不一样，也就是<strong>每个数组对象占用的内存可以不一样</strong>，这点和类的对象不同。</li>
<li>可以用引用指向类型相同大小不同的数组，因为他们属于同一种类型</li>
</ol>
<ul>
<li><strong>引用数组</strong></li>
</ul>
<ol>
<li>可以把类名当成自定义类型，定义引用的数组，甚至多维数组</li>
</ol>
<ul>
<li><p>示例1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayIsClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// &gt;&gt; TODO “数组变量”其背后真身就是引用。数组类型就是一种特殊的类。</span></span><br><span class="line">        <span class="comment">// &gt;&gt; TODO 数组的大小不决定数组的类型，数组的类型是只是由元素类型决定的。</span></span><br><span class="line">        <span class="type">int</span>[] intArr;</span><br><span class="line">        intArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        intArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个数组的元素就是二维的double数组，既double[][]</span></span><br><span class="line">        <span class="type">double</span>[][][] double3DArray = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] a1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>];</span><br><span class="line">        <span class="type">int</span>[] a2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        a2 = a1;</span><br><span class="line">        System.out.println(<span class="string">&quot;a2.length=&quot;</span> + a2.length);</span><br><span class="line">        <span class="type">double</span>[] a3 = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">// a3是double[]类型的引用，不可以用int[]类型的引用赋值。</span></span><br><span class="line">        double3DArray[<span class="number">1</span>][<span class="number">2</span>] = a3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a2.length=9</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例2</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefArray</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Merchandise[] merchandises = <span class="keyword">new</span> <span class="title class_">Merchandise</span>[<span class="number">9</span>];</span><br><span class="line">        merchandises[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Merchandise</span>();</span><br><span class="line">        merchandises[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Merchandise</span>();</span><br><span class="line">        merchandises[<span class="number">0</span>].name = <span class="string">&quot;笔记本&quot;</span>;</span><br><span class="line">        System.out.println(merchandises[<span class="number">0</span>].name);</span><br><span class="line"></span><br><span class="line">        System.out.println(merchandises[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">笔记本</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<h2 id="1-5-对象的内存解析"><a href="#1-5-对象的内存解析" class="headerlink" title="1.5 对象的内存解析"></a>1.5 对象的内存解析</h2><h3 id="1-5-1-JVM内存结构划分"><a href="#1-5-1-JVM内存结构划分" class="headerlink" title="1.5.1 JVM内存结构划分"></a>1.5.1 JVM内存结构划分</h3><p>HotSpot Java虚拟机的架构图如下。其中主要关心的是运行时数据区部分（Runtime Data Area）。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/20240701182618.png" alt="image.png"></p>
<p>堆：此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。<br>栈：是指虚拟机栈。虚拟机栈用于存储局部变量等。<br>方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h3 id="1-5-2-对象内存解析"><a href="#1-5-2-对象内存解析" class="headerlink" title="1.5.2 对象内存解析"></a>1.5.2 对象内存解析</h3><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; <span class="comment">//类:人 String name;</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">    <span class="type">boolean</span> isMale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> &#123; <span class="comment">//测试类</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); p1.name = <span class="string">&quot;赵同学&quot;</span>;</span><br><span class="line">		p1.age = <span class="number">20</span>;</span><br><span class="line">		p1.isMale = <span class="literal">true</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">		p2.age = <span class="number">10</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> p1;</span><br><span class="line">		p3.name = <span class="string">&quot;郭同学&quot;</span>; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存解析图：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/20240701183147.png" alt="image.png"></p>
<ul>
<li>堆：凡是new出来的结构（对象、数组）都放在堆空间中。</li>
<li>对象的属性存放在堆空间中</li>
<li>创建一个类的多个对象（比如：p1、p2），则每个对象都拥有当前类的一套“副本”（即属性）。当通过一个对象修改其属性时，不会影响其他对象此属性的值</li>
<li>当声明一个新的变量使用现有的对象进行赋值时（比如p3&#x3D;p1），两个变量会共同指向堆空间中同一个对象</li>
</ul>
<h2 id="1-6-类方法"><a href="#1-6-类方法" class="headerlink" title="1.6 类方法"></a>1.6 类方法</h2><h3 id="1-6-1-构造方法"><a href="#1-6-1-构造方法" class="headerlink" title="1.6.1 构造方法"></a>1.6.1 构造方法</h3><ol>
<li>构造方法（constructor）的方法名必须与类名一样，而且构造方法没有返回值。这样的方法才是构造方法。</li>
<li>构造方法可以有参数，规则和语法于普通方法一样。使用时，参数传递给 new 语句后类名的括号后面。</li>
<li>如果没有显示的添加一个构造方法，Java会给每个类都会默认自带一个无参数的构造方法。</li>
<li>如果我们自己添加类构造方法，Java就不会再添加无参数的构造方法。这时候，就不能直接 new 一个对象不传递参数了（看例子）</li>
<li>所以我们一直都在使用构造方法，这也是为什么创建对象的时候类名后面要有一个括号的原因。</li>
<li>构造方法无法被点操作符调用或者在普通方法里调用，只能通过 new 语句在创建对象的时候，间接调用。</li>
<li>理解一下为什么构造方法不能有返回值，因为有返回值也没有意义，new 语句永远返回的是创建出来的对象的引用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.geekbang.supermarket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MerchandiseV2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String id;</span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 构造方法执行前，会执行给局部变量赋初始值的操作</span></span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 我们说过，所有的代码都必须在方法里，那么这种给成员变赋初始值的代码在哪个方法里？怎么看不到呢？</span></span><br><span class="line">    <span class="comment">//    TODO 原来构造方法在内部变成了&lt;init&gt;方法。学习就是要脑洞大，敢想敢试，刨根问底。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">999</span>;<span class="comment">// 999/0;  在构造方法前赋值变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> soldPrice;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> purchasePrice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 构造方法（constructor）的重载和普通方法一样</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MerchandiseV2</span><span class="params">(String name, String id, <span class="type">int</span> count, <span class="type">double</span> soldPrice, <span class="type">double</span> purchasePrice)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">        <span class="built_in">this</span>.soldPrice = soldPrice;</span><br><span class="line">        <span class="built_in">this</span>.purchasePrice = purchasePrice;</span><br><span class="line"><span class="comment">//        soldPrice = 9/0;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 在构造方法里才能调用重载的构造方法。语法为this(实参列表)</span></span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 构造方法不能自己调用自己，这会是一个死循环</span></span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 在调用重载的构造方法时，不可以使用成员变量。因为用语意上讲，这个对象还没有被初始化完成，处于中间状态。</span></span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 在构造方法里才能调用重载的构造方法时，必须是方法的第一行。后面可以继续有代码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MerchandiseV2</span><span class="params">(String name, String id, <span class="type">int</span> count, <span class="type">double</span> soldPrice)</span> &#123;</span><br><span class="line">         <span class="comment">// double purPrice = soldPrice * 0.8;</span></span><br><span class="line">        <span class="comment">// this(name, id, count, soldPrice, purchasePrice);</span></span><br><span class="line">        <span class="built_in">this</span>(name, id, count, soldPrice, soldPrice * <span class="number">0.8</span>);</span><br><span class="line">        <span class="comment">// double purPrice = soldPrice * 0.8;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 因为我们添加了构造方法之后，Java就不会再添加无参数的构造方法。如果需要的话，我们可以自己添加这样的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MerchandiseV2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;无名&quot;</span>, <span class="string">&quot;000&quot;</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1.1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">describe</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;商品名字叫做&quot;</span> + name + <span class="string">&quot;，id是&quot;</span> + id + <span class="string">&quot;。 商品售价是&quot;</span> + soldPrice</span><br><span class="line">            + <span class="string">&quot;。商品进价是&quot;</span> + purchasePrice + <span class="string">&quot;。商品库存量是&quot;</span> + count +</span><br><span class="line">            <span class="string">&quot;。销售一个的毛利润是&quot;</span> + (soldPrice - purchasePrice));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">buy</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.count &lt; count) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count -= count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>在构造方法里才能调用重载的构造方法。语法为this(实参列表)</li>
<li>构造方法不能自己调用自己，这会是一个死循环</li>
<li>在调用重载的构造方法时，不可以使用成员变量。因为用语意上讲，这个对象还没有被初始化完成，处于中间状态。</li>
<li>在构造方法里才能调用重载的构造方法时，必须是方法的第一行。后面可以继续有代码</li>
</ul>
<h3 id="1-6-2-静态变量和静态方法"><a href="#1-6-2-静态变量和静态方法" class="headerlink" title="1.6.2 静态变量和静态方法"></a>1.6.2 静态变量和静态方法</h3><ol>
<li>静态变量</li>
</ol>
<ul>
<li>静态变量使用 static 修饰符</li>
<li>静态变量如果不赋值，Java也会给它赋以其类型的初始值</li>
<li>静态变量一般使用全大写字母加下划线分割。这是一个习惯用法</li>
<li>所有的代码都可以使用静态变量，只要根据防范控制符的规范，这个静态变量对其可见即可</li>
<li>public 的静态变量，所有的代码都可以使用它</li>
<li>如果没有public修饰符，只能当前包的代码能使用它</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">DISCOUNT_FOR_VIP</span> <span class="operator">=</span> <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">STATIC_VARIABLE_CURR_PACKAGE_ONLY</span> <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>静态方法</li>
</ol>
<ul>
<li>静态方法中不能使用this自引用，其他和成员方法一样。</li>
<li>静态方法不属于某个实例，直接使用类名调用，所以静态方法中不能直接访问成员变量。</li>
<li>在静态方法里边，可以自己创建对象，或者通过参数，获取对象的引用调用方法和成员变量。</li>
<li>在当前类中访问静态方法可以省略类名</li>
<li>使用import static引入一个静态方法或静态变量。</li>
<li>静态方法的重载也是一样的，方法签名不同即可：方法名+参数类型</li>
<li>判断调用哪个方法，也是根据调用时参数匹配决定的。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.geekbang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.geekbang.supermarket.MerchandiseV2;</span><br><span class="line"><span class="keyword">import</span>  <span class="keyword">static</span> com.geekbang.supermarket.MerchandiseV2.getVIPDiscount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MerchandiseV2DescAppMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MerchandiseV2</span> <span class="variable">merchandise</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MerchandiseV2</span></span><br><span class="line">            (<span class="string">&quot;书桌&quot;</span>, <span class="string">&quot;DESK9527&quot;</span>, <span class="number">40</span>, <span class="number">999.9</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        merchandise.describe();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt; TODO 使用import static来引入一个静态方法，就可以直接用静态变量名访问了</span></span><br><span class="line">        <span class="comment">//    TODO import static也可以使用通配符*来引入一个类里所有静态变量</span></span><br><span class="line">        System.out.println(getVIPDiscount());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.geekbang.supermarket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MerchandiseV2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String id;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> soldPrice;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> purchasePrice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 静态变量使用 static 修饰符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">DISCOUNT_FOR_VIP</span> <span class="operator">=</span> <span class="number">0.95</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 静态方法使用static修饰符。</span></span><br><span class="line">    <span class="comment">// 静态方法的方法名没有约定俗称全大写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getVIPDiscount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// &gt;&gt; TODO 静态方法可以访问静态变量，包括自己类的静态变量和在访问控制符允许的别的类的静态变量</span></span><br><span class="line">        <span class="keyword">return</span> DISCOUNT_FOR_VIP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 除了没有this，静态方法的定义和成员方法一样，也有方法名，返回值和参数</span></span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 静态方法没有this自引用，它不属于某个实例，调用的时候也无需引用，直接用类名调用，所以它也不能直接访问成员变量</span></span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 当然在静态方法里面，也可以自己创建对象，或者通过参数，获得对象的引用，进而调用方法和访问成员变量</span></span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 静态方法只是没有this自引用的方法而已。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getDiscountOnDiscount</span><span class="params">(LittleSuperMarket littleSuperMarket)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">activityDiscount</span> <span class="operator">=</span> littleSuperMarket.activityDiscount;</span><br><span class="line">        <span class="keyword">return</span> DISCOUNT_FOR_VIP * activityDiscount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MerchandiseV2</span><span class="params">(String name, String id, <span class="type">int</span> count, <span class="type">double</span> soldPrice, <span class="type">double</span> purchasePrice)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">        <span class="built_in">this</span>.soldPrice = soldPrice;</span><br><span class="line">        <span class="built_in">this</span>.purchasePrice = purchasePrice;</span><br><span class="line">        <span class="comment">// soldPrice = 9/0;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MerchandiseV2</span><span class="params">(String name, String id, <span class="type">int</span> count, <span class="type">double</span> soldPrice)</span> &#123;</span><br><span class="line">        <span class="comment">// double purPrice = soldPrice * 0.8;</span></span><br><span class="line">        <span class="comment">// this(name, id, count, soldPrice, purchasePrice);</span></span><br><span class="line">        <span class="built_in">this</span>(name, id, count, soldPrice, soldPrice * <span class="number">0.8</span>);</span><br><span class="line">        <span class="comment">// double purPrice = soldPrice * 0.8;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MerchandiseV2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;无名&quot;</span>, <span class="string">&quot;000&quot;</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1.1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">describe</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;商品名字叫做&quot;</span> + name + <span class="string">&quot;，id是&quot;</span> + id + <span class="string">&quot;。 商品售价是&quot;</span> + soldPrice</span><br><span class="line">            + <span class="string">&quot;。商品进价是&quot;</span> + purchasePrice + <span class="string">&quot;。商品库存量是&quot;</span> + count +</span><br><span class="line">            <span class="string">&quot;。销售一个的毛利润是&quot;</span> + (soldPrice - purchasePrice) + <span class="string">&quot;。折扣为&quot;</span> + DISCOUNT_FOR_VIP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateProfit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">profit</span> <span class="operator">=</span> soldPrice - purchasePrice;</span><br><span class="line"><span class="comment">//        if(profit &lt;= 0)&#123;</span></span><br><span class="line"><span class="comment">//            return 0;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">buy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buy(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">buy</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buy(count, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">buy</span><span class="params">(<span class="type">int</span> count, <span class="type">boolean</span> isVIP)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.count &lt; count) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.count -= count;</span><br><span class="line">        <span class="type">double</span> <span class="variable">totalCost</span> <span class="operator">=</span> count * soldPrice;</span><br><span class="line">        <span class="keyword">if</span> (isVIP) &#123;</span><br><span class="line">            <span class="comment">// &gt;&gt; TODO 静态方法的访问和静态变量一样，可以带上类名，当前类可以省略类名</span></span><br><span class="line">            <span class="keyword">return</span> totalCost * getVIPDiscount();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> totalCost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-3-方法调用内存分析"><a href="#1-6-3-方法调用内存分析" class="headerlink" title="1.6.3 方法调用内存分析"></a>1.6.3 方法调用内存分析</h3><ul>
<li>方法没有被调用的时候，都在方法区中的字节码文件(.class)中存储。</li>
<li>方法被调用的时候，需要进入到栈内存中运行。方法每调用一次就会在栈中有一个入栈操作</li>
<li>当方法执行结束后，会释放该内存，称为出栈</li>
</ul>
<h3 id="1-6-4-方法的重载"><a href="#1-6-4-方法的重载" class="headerlink" title="1.6.4 方法的重载"></a>1.6.4 方法的重载</h3><ul>
<li>方法签名 : 方法名+依次参数类型。注意，返回值不属于方法签名。方法签名是一个方法在一个类中的唯一标识</li>
<li>同一个类中方法可以重名，但是签名不可以重复。一个类中如果定义了名字相同，签名不同的方法，就叫做方法的重载</li>
</ul>
<ol>
<li>重载的参数匹配规则</li>
</ol>
<p>如果有如下重载方法，在java中的自动类型转换匹配逻辑为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">buy</span><span class="params">(<span class="type">int</span> count)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">buy</span><span class="params">(<span class="type">double</span> count)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果传的参数是 byte, short, int,类型会调用buy(int count)方法，如果是long, float, double 类型会调用buy(double count)方法。</p>
<ul>
<li>无论是否重载参数类型可以不完全匹配的规则是”实参数可以自动类型转换成形参类型”</li>
<li>重载的特殊之处是，参数满足自动类型转换的方法有好几个，重载的规则是选择最”近”的去调用</li>
</ul>
<h3 id="1-6-5-可变个数的形参"><a href="#1-6-5-可变个数的形参" class="headerlink" title="1.6.5 可变个数的形参"></a>1.6.5 可变个数的形参</h3><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK5.0:采用可变个数形参来定义方法，传入多个同一类型变量 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a ,String...books)</span>;</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ol>
<li>方法的参数部分有可变形参，需要放在形参声明的最后</li>
<li>在一个方法的形参中，最多只能声明一个可变个数的形参</li>
<li>可变参数方法的使用与方法参数部分使用数组是一致的，二者不能同时声明，否则报错</li>
</ol>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTools</span> &#123;</span><br><span class="line">    String <span class="title function_">concat</span><span class="params">(<span class="type">char</span> seperator, String... args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                str += args[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                str += seperator + args[i];</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> str; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-6-参数传递机制：值传递"><a href="#1-6-6-参数传递机制：值传递" class="headerlink" title="1.6.6 参数传递机制：值传递"></a>1.6.6 参数传递机制：值传递</h3><p>Java里方法的参数传递方式只有一种：值传递。</p>
<ul>
<li>形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参</li>
<li>形参是引用数据类型：将实参应用数据类型变量的“地址值”传递给形参</li>
</ul>
<h1 id="2-包和访问修饰符"><a href="#2-包和访问修饰符" class="headerlink" title="2 包和访问修饰符"></a>2 包和访问修饰符</h1><h2 id="2-1-package（包）"><a href="#2-1-package（包）" class="headerlink" title="2.1 package（包）"></a>2.1 package（包）</h2><ul>
<li>package语句作为Java源文件的第一条语句出现。若缺省该语句，则指定为无名包。</li>
<li>不同的包里可以有相同名字的类</li>
<li>一个类只能有一个 package 语句，如果有 package 语句，则必须是类的第一行有效代码</li>
<li>包通常使用所在公司域名的倒置：<code>com.atguigu.xxx</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 顶层包名.子包名 ;</span><br></pre></td></tr></table></figure>

<p><strong>JDK中主要的包介绍：</strong></p>
<ol>
<li><code>java.lang</code> 包含一些Java语言的核心类，如 String、Math、Integer、System和Thread，提供常用功能</li>
<li><code>java.net</code> 包含执行与网络相关的操作的类和接口</li>
<li><code>java.io</code> 包含能提供多种输入、输出功能的类</li>
<li><code>java.util</code> 包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数</li>
<li><code>java.text</code> 包含一些java格式化相关的类</li>
<li><code>java.sql</code> 包含了java 进行JDBC数据库编程的相关类、接口</li>
<li><code>java.awt</code> 包含了构成抽象窗口工具类的多个类，这些类被用来构建和管理应用程序的图形用户界面（GUI）</li>
</ol>
<h2 id="2-2-import（导入）"><a href="#2-2-import（导入）" class="headerlink" title="2.2 import（导入）"></a>2.2 import（导入）</h2><ol>
<li>使用import</li>
</ol>
<p>每次使用都带包名很繁琐， 可以在使用的类的上面使用 import 语句， 一次性解决问题， 就可以直接使用类了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.geekbang.supermarket.LittleSuperMarket;</span><br><span class="line"><span class="keyword">import</span> com.geekbang.supermarket.MerchandiseV2;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果使用 <code>a.*</code> 导入结构，表示可以导入a包下的所有的结构。举例:可以使用<code>java.util.*</code>的方式，一 次性导入util包下所有的类或接口。</li>
<li>如果导入的类或接口是<code>java.lang</code>包下的，或者是当前包下的，则可以省略此import语句。</li>
<li>如果已经导入java.a包下的类，那么如果需要使用a包的子包下的类的话，仍然需要导入。</li>
<li>如果在代码中使用不同包下的同名的类，那么就需要使用类的全类名的方式指明调用的是哪个类。</li>
<li><code>import static</code> 组合的使用:调用指定类或接口下的静态的属性或方法</li>
</ul>
<h2 id="2-2-访问修饰符"><a href="#2-2-访问修饰符" class="headerlink" title="2.2 访问修饰符"></a>2.2 访问修饰符</h2><ol>
<li>属性访问修饰符：public</li>
</ol>
<ul>
<li>被 public 修饰的属性，可以被任意包中的类访问</li>
<li>没有访问修饰符的属性，称作缺省的访问修饰符，可以被本包内的其他类和自己的对象</li>
<li>访问修饰符是一种限制或者允许属性访问的修饰符</li>
</ul>
<ol start="2">
<li>属性访问修饰符：protected</li>
</ol>
<ul>
<li>被protected修饰，可以在本类使用</li>
<li>可以在本包子类和非子类使用</li>
<li>在其他包中仅限子类可见</li>
</ul>
<ol start="3">
<li>属性访问修饰符：priviate，仅可在本类可见</li>
<li>属性访问修饰符：缺省，可在本类和本包子类非子类可见，其他包不可见</li>
</ol>
<p>实现封装就是控制类或成员的可见性范围。这就需要依赖访问控制修饰符，也称为权限修饰符来控制。</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>本类</th>
<th>本包</th>
<th>其他包子类</th>
<th>其他包非子类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>缺省</td>
<td>√</td>
<td>√（本包子类非子类都可见）</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√（本包子类非子类都可见）</td>
<td>√（其他包仅限于子类中可见）</td>
<td>×</td>
</tr>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>6. 类的全限定名</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>包名 + 类名 &#x3D; 类的全限定名。也可以简称为类的全名</li>
<li>同一个 Java 程序中全限定名字不可重复</li>
</ul>
<h1 id="3-关键字：this"><a href="#3-关键字：this" class="headerlink" title="3 关键字：this"></a>3 关键字：this</h1><h2 id="3-1-实例方法或构造器中使用当前对象的成员"><a href="#3-1-实例方法或构造器中使用当前对象的成员" class="headerlink" title="3.1 实例方法或构造器中使用当前对象的成员"></a>3.1 实例方法或构造器中使用当前对象的成员</h2><p>当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量。即：我们可以用this来区分<code>成员变量</code>和<code>局部变量</code>。比如：</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/20240702144938.png" alt="image.png"></p>
<blockquote>
<p>使用this访问属性和方法时，如果在本类中未找到，会从父类中查找。</p>
</blockquote>
<h2 id="3-2-同一个类中构造器互相调用"><a href="#3-2-同一个类中构造器互相调用" class="headerlink" title="3.2 同一个类中构造器互相调用"></a>3.2 同一个类中构造器互相调用</h2><ul>
<li>this()：调用本类的无参构造器</li>
<li>this(实参列表)：调用本类的有参构造器</li>
<li>this()和this(实参列表)只能声明在构造器首行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        this(&quot;&quot;,18);//调用本类有参构造器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();<span class="comment">//调用本类无参构造器</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(name);<span class="comment">//调用本类中有一个String参数的构造器</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + name +<span class="string">&quot;，年龄：&quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="4-继承"><a href="#4-继承" class="headerlink" title="4 继承"></a>4 继承</h1><h2 id="4-1-继承的语法"><a href="#4-1-继承的语法" class="headerlink" title="4.1 继承的语法"></a>4.1 继承的语法</h2><p>通过 <code>extends</code> 关键字，可以声明一个类B继承另外一个类A，定义格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类A &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[修饰符] class 类B extends 类A &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-继承中的基本概念"><a href="#4-2-继承中的基本概念" class="headerlink" title="4.2 继承中的基本概念"></a>4.2 继承中的基本概念</h2><p>类B，称为子类、派生类(derived class)、SubClass<br>类A，称为父类、超类、基类(base class)、SuperClass</p>
<h2 id="4-3-继承性的细节"><a href="#4-3-继承性的细节" class="headerlink" title="4.3 继承性的细节"></a>4.3 继承性的细节</h2><ul>
<li>子类继承了父类的方法和属性</li>
<li>使用子类的引用可以调用父类的公有方法</li>
<li>使用子类的引用可以访问父类的公有属性</li>
<li>子类不能直接访问父类中私有的(private)的成员变量和方法，可通过继承的get&#x2F;set方法进行访问。如图所示：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/20240702150117.png" alt="image.png"></p>
<ul>
<li>Java只支持单继承，不支持多重继承</li>
</ul>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/20240702150258.png" alt="image.png"></p>
<h2 id="4-4-方法的重写（override-overwrite）"><a href="#4-4-方法的重写（override-overwrite）" class="headerlink" title="4.4 方法的重写（override&#x2F;overwrite）"></a>4.4 方法的重写（override&#x2F;overwrite）</h2><p>子类可以对从父类中继承来的方法进行改造，我们称为方法的<code>重写 (override、overwrite)</code>。也称为方法的<code>重置</code>、<code>覆盖</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.inherited.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showNum</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来电显示号码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.inherited.method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SmartPhone：智能手机</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmartPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="comment">//重写父类的来电显示功能的方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showNum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//来电显示姓名和图片功能</span></span><br><span class="line">        System.out.println(<span class="string">&quot;显示来电姓名&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;显示头像&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写父类的通话功能的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;语音通话 或 视频通话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@Override使用说明：<br>写在方法上面，用来检测是不是满足重写方法的要求。这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。建议保留，这样编译器可以帮助我们检查格式，另外也可以让阅读源代码的程序员清晰的知道这是一个重写的方法。</p>
</blockquote>
<ol>
<li>子类重写的方法<code>必须</code>和父类被重写的方法具有相同的<code>方法名称</code>、<code>参数列表</code>。</li>
<li>子类重写的方法的返回值类型<code>不能大于</code>父类被重写的方法的返回值类型。（例如：Student &lt; Person）。<blockquote>
<p>注意：如果返回值类型是基本数据类型和void，那么必须是相同</p>
</blockquote>
</li>
<li>子类重写的方法使用的访问权限<code>不能小于</code>父类被重写的方法的访问权限。（public &gt; protected &gt; 缺省 &gt; private）<blockquote>
<p>注意：① 父类私有方法不能重写 ② 跨包的父类缺省的方法也不能重写</p>
</blockquote>
</li>
<li>子类方法抛出的异常不能大于父类被重写方法的异常<br>此外，子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。</li>
</ol>
<h2 id="4-5-关键字：super"><a href="#4-5-关键字：super" class="headerlink" title="4.5 关键字：super"></a>4.5 关键字：super</h2><p>在Java类中使用super来调用父类中的指定操作：</p>
<ul>
<li>super可用于访问父类中定义的属性</li>
<li>super可用于调用父类中定义的成员方法</li>
<li>super可用于在子类构造器中调用父类的构造器</li>
</ul>
<p>注意：</p>
<ul>
<li>尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员</li>
<li>super的追溯不仅限于直接父类</li>
<li>super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识</li>
</ul>
<h3 id="4-5-1-子类中调用父类被重写的方法"><a href="#4-5-1-子类中调用父类被重写的方法" class="headerlink" title="4.5.1 子类中调用父类被重写的方法"></a>4.5.1 子类中调用父类被重写的方法</h3><ul>
<li>如果子类没有重写父类的方法，只要权限修饰符允许，在子类中完全可以直接调用父类的方法；</li>
<li>如果子类重写了父类的方法，在子类中需要通过<code>super.</code>才能调用父类被重写的方法，否则默认调用的子类重写的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.inherited.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showNum</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来电显示号码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//smartphone：智能手机</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmartPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="comment">//重写父类的来电显示功能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showNum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//来电显示姓名和图片功能</span></span><br><span class="line">        System.out.println(<span class="string">&quot;显示来电姓名&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;显示头像&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保留父类来电显示号码的功能</span></span><br><span class="line">        <span class="built_in">super</span>.showNum();<span class="comment">//此处必须加super.，否则就是无限递归，那么就会栈内存溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li><strong>方法前面没有super.和this.</strong><ul>
<li>先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上追溯</li>
</ul>
</li>
<li><strong>方法前面有this.</strong><ul>
<li>先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上追溯</li>
</ul>
</li>
<li><strong>方法前面有super.</strong><ul>
<li>从当前子类的直接父类找，如果没有，继续往上追溯</li>
</ul>
</li>
</ul>
<h3 id="4-5-2-子类中调用父类中同名的成员变量"><a href="#4-5-2-子类中调用父类中同名的成员变量" class="headerlink" title="4.5.2 子类中调用父类中同名的成员变量"></a>4.5.2 子类中调用父类中同名的成员变量</h3><ul>
<li>如果实例变量与局部变量重名，可以在实例变量前面加this.进行区别</li>
<li>如果子类实例变量和父类实例变量重名，并且父类的该实例变量在子类仍然可见，在子类中要访问父类声明的实例变量需要在父类实例变量前加super.，否则默认访问的是子类自己声明的实例变量</li>
<li>如果父子类实例变量没有重名，只要权限修饰符允许，在子类中完全可以直接访问父类中声明的实例变量，也可以用this.实例访问，也可以用super.实例变量访问</li>
</ul>
<h3 id="4-5-3-子类构造器中调用父类构造器"><a href="#4-5-3-子类构造器中调用父类构造器" class="headerlink" title="4.5.3 子类构造器中调用父类构造器"></a>4.5.3 子类构造器中调用父类构造器</h3><p>① 子类继承父类时，不会继承父类的构造器。只能通过“super(形参列表)”的方式调用父类指定的构造器。<br>② 规定：“super(形参列表)”，必须声明在构造器的首行。<br>③ 我们前面讲过，在构造器的首行可以使用”this(形参列表)”，调用本类中重载的构造器，<br>结合②，结论：在构造器的首行，”this(形参列表)” 和 “super(形参列表)”只能二选一。<br>④ 如果在子类构造器的首行既没有显示调用”this(形参列表)”，也没有显式调用”super(形参列表)”，<br>​ 则子类此构造器默认调用”super()”，即调用父类中空参的构造器。<br>⑤ 由③和④得到结论：子类的任何一个构造器中，要么会调用本类中重载的构造器，要么会调用父类的构造器。<br>只能是这两种情况之一。<br>⑥ 由⑤得到：一个类中声明有n个构造器，最多有n-1个构造器中使用了”this(形参列表)”，则剩下的那个一定使用”super(形参列表)”。</p>
<blockquote>
<p>开发中常见错误：<br>如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有空参的构造器，则<code>编译出错</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	A(<span class="type">int</span> a)&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;A类有参构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	B()&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;B类无参构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test05</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="comment">//A类显示声明一个有参构造，没有写无参构造，那么A类就没有无参构造了</span></span><br><span class="line">		<span class="comment">//B类显示声明一个无参构造，        </span></span><br><span class="line">		<span class="comment">//B类的无参构造没有写super(...)，表示默认调用A类的无参构造</span></span><br><span class="line">        <span class="comment">//编译报错，因为A类没有无参构造</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/20240702152842.png" alt="image.png"></p>
<h2 id="4-6-继承里的静态方法："><a href="#4-6-继承里的静态方法：" class="headerlink" title="4. 6 继承里的静态方法："></a>4. 6 继承里的静态方法：</h2><p>静态方法可以被继承，静态方法不支持多态逻辑，建议在使用静态方法时直接使用类名调用静态方法，如果此类下没有这个方法，则会调用其父类下的静态方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.geekbang.supermarket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">extends</span> <span class="title class_">MerchandiseV2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给Phone增加新的属性和方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> screenSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> cpuHZ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> memoryG;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> storageG;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String os;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_BUY_ONE_ORDER</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 使用super可以调用父类的方法和属性（当然必须满足访问控制符的控制）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">buy</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; MAX_BUY_ONE_ORDER) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;购买失败，手机一次最多只能买&quot;</span> + MAX_BUY_ONE_ORDER + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.buy(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.brand + <span class="string">&quot;:&quot;</span> + <span class="built_in">this</span>.os + <span class="string">&quot;:&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">describe</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;此手机商品属性如下&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.describe();</span><br><span class="line">        System.out.println(<span class="string">&quot;手机厂商为&quot;</span> + brand + <span class="string">&quot;；系统为&quot;</span> + os + <span class="string">&quot;；硬件配置如下：\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;屏幕：&quot;</span> + screenSize + <span class="string">&quot;寸\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;cpu主频&quot;</span> + cpuHZ + <span class="string">&quot; GHz\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;内存&quot;</span> + memoryG + <span class="string">&quot;Gb\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;存储空间&quot;</span> + storageG + <span class="string">&quot;Gb&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt; TODO super是子类和父类交流的桥梁，但是并不是父类的引用</span></span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 所以，super和this自引用不一样，不是简单可以模拟的（可以模拟的话不就成了组合了吗）</span></span><br><span class="line"><span class="comment">//    public MerchandiseV2 getParent()&#123;</span></span><br><span class="line"><span class="comment">//        return super;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">getThisPhone</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 使用super可以调用父类的public属性，但是super不是一个引用。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accessParentProps</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类里的name属性：&quot;</span> + <span class="built_in">super</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useSuper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// &gt;&gt; TODO super的用法就像是一个父类的引用。它是继承的一部分，像组合的那部分，但不是全部</span></span><br><span class="line">        <span class="built_in">super</span>.describe();</span><br><span class="line">        <span class="built_in">super</span>.buy(<span class="number">66</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;父类里的count属性：&quot;</span> + <span class="built_in">super</span>.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Phone</span><span class="params">(</span></span><br><span class="line"><span class="params">        String name, String id, <span class="type">int</span> count, <span class="type">double</span> soldPrice, <span class="type">double</span> purchasePrice,</span></span><br><span class="line"><span class="params">        <span class="type">double</span> screenSize, <span class="type">double</span> cpuHZ, <span class="type">int</span> memoryG, <span class="type">int</span> storageG, String brand, String os</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        <span class="comment">// &gt;&gt; TODO 可以认为，创建子类对象的时候，也就同时创建了一个隐藏的父类对象</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.screenSize = screenSize;</span><br><span class="line">        <span class="built_in">this</span>.cpuHZ = cpuHZ;</span><br><span class="line">        <span class="built_in">this</span>.memoryG = memoryG;</span><br><span class="line">        <span class="built_in">this</span>.storageG = storageG;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">        <span class="built_in">this</span>.os = os;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt; TODO 所以，才能够setName，对name属性进行操作。</span></span><br><span class="line">        <span class="built_in">this</span>.setName(name);</span><br><span class="line">        <span class="built_in">this</span>.setId(id);</span><br><span class="line">        <span class="built_in">this</span>.setCount(count);</span><br><span class="line">        <span class="built_in">this</span>.setSoldPrice(soldPrice);</span><br><span class="line">        <span class="built_in">this</span>.setPurchasePrice(purchasePrice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">meetCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getScreenSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> screenSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScreenSize</span><span class="params">(<span class="type">double</span> screenSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.screenSize = screenSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCpuHZ</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cpuHZ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCpuHZ</span><span class="params">(<span class="type">double</span> cpuHZ)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpuHZ = cpuHZ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMemoryG</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memoryG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemoryG</span><span class="params">(<span class="type">int</span> memoryG)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memoryG = memoryG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStorageG</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> storageG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStorageG</span><span class="params">(<span class="type">int</span> storageG)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.storageG = storageG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBrand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBrand</span><span class="params">(String brand)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOs</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOs</span><span class="params">(String os)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.os = os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-7-父类和子类的引用赋值关系"><a href="#4-7-父类和子类的引用赋值关系" class="headerlink" title="4.7 父类和子类的引用赋值关系"></a>4.7 父类和子类的引用赋值关系</h2><ul>
<li>父类引用可以指向子类对象，子类引用不可以指向父类的对象</li>
<li>可以进行强制类型转换，如果类型不对，会报错</li>
<li>可以调用的方法，是受引用类型决定的</li>
</ul>
<ul>
<li>因为子类继承了父类的方法和属性，所以父类的对象能做到的，子类的对象肯定能做到</li>
<li>如果确定一个父类的引用指向的对象，实际上就是一个子类的对象（或者子类的子类的对象），可以强制类型转换，如果不是，则编译报错</li>
</ul>
<p><strong>如下示例：</strong><br>类之间的关系为：LittleSuperMarket -&gt; MerchandiseV2 -&gt; Phone -&gt; ShellColorChangePhone</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.geekbang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.geekbang.supermarket.MerchandiseV2;</span><br><span class="line"><span class="keyword">import</span> com.geekbang.supermarket.Phone;</span><br><span class="line"><span class="keyword">import</span> com.geekbang.supermarket.ShellColorChangePhone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceAssign</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">ph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>(</span><br><span class="line">            <span class="string">&quot;手机001&quot;</span>, <span class="string">&quot;Phone001&quot;</span>, <span class="number">100</span>, <span class="number">1999</span>, <span class="number">999</span>,</span><br><span class="line">            <span class="number">4.5</span>, <span class="number">3.5</span>, <span class="number">4</span>, <span class="number">128</span>, <span class="string">&quot;索尼&quot;</span>, <span class="string">&quot;安卓&quot;</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt; TODO 可以用子类的引用给父类的引用赋值，也就是说，父类的引用可以指向子类的对象</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MerchandiseV2</span> <span class="variable">m</span> <span class="operator">=</span> ph;</span><br><span class="line">        <span class="type">MerchandiseV2</span> <span class="variable">m2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>(</span><br><span class="line">            <span class="string">&quot;手机002&quot;</span>, <span class="string">&quot;Phone002&quot;</span>, <span class="number">100</span>, <span class="number">1999</span>, <span class="number">999</span>,</span><br><span class="line">            <span class="number">4.5</span>, <span class="number">3.5</span>, <span class="number">4</span>, <span class="number">128</span>, <span class="string">&quot;索尼&quot;</span>, <span class="string">&quot;安卓&quot;</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt; TODO 但是反之则不行，不能让子类的引用指向父类的对象。因为父类并没有子类的属性和方法呀</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         Phone notDoable = new MerchandiseV2();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt; TODO                          重点</span></span><br><span class="line">        <span class="comment">// &gt;&gt; TODO 因为子类继承了父类的方法和属性，所以父类的对象能做到的，子类的对象肯定能做到</span></span><br><span class="line">        <span class="comment">//    TODO 换句话说，我们可以在子类的对象上，执行父类的方法</span></span><br><span class="line">        <span class="comment">// &gt;&gt; TODO 当父类的引用指向子类的实例（或者父类的实例），只能通过父类的引用，像父类一样操作子类的对象</span></span><br><span class="line">        <span class="comment">//    TODO 也就是说&quot;名&quot;的类型，决定了能执行哪些操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt; TODO ph和m都指向同一个对象，通过ph可以调用getBrand方法</span></span><br><span class="line">        <span class="comment">//    TODO 因为ph的类型是Phone，Phone里定义了getBrand方法</span></span><br><span class="line">        ph.getBrand();</span><br><span class="line">        <span class="comment">// &gt;&gt; TODO ph和m都指向同一个对象，但是通过m就不可以调用getBrand方法</span></span><br><span class="line">        <span class="comment">//    TODO 因为m的类型是MerchandiseV2，MerchandiseV2里没有你定义getBrand方法</span></span><br><span class="line">        <span class="comment">// m.getBrand();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 如果确定一个父类的引用指向的对象，实际上就是一个子类的对象（或者子类的子类的对象），可以强制类型转换</span></span><br><span class="line">        <span class="type">Phone</span> <span class="variable">aPhone</span> <span class="operator">=</span> (Phone) m2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// MerchandiseV2是Phone的父类，Phone是shellColorChangePhone的父类</span></span><br><span class="line">        <span class="type">ShellColorChangePhone</span> <span class="variable">shellColorChangePhone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShellColorChangePhone</span>(</span><br><span class="line">            <span class="string">&quot;手机002&quot;</span>, <span class="string">&quot;Phone002&quot;</span>, <span class="number">100</span>, <span class="number">1999</span>, <span class="number">999</span>,</span><br><span class="line">            <span class="number">4.5</span>, <span class="number">3.5</span>, <span class="number">4</span>, <span class="number">128</span>, <span class="string">&quot;索尼&quot;</span>, <span class="string">&quot;安卓&quot;</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 父类的引用，可以指向子类的对象，即可以用子类（以及子类的子类）的引用给父类的引用赋值</span></span><br><span class="line">        <span class="type">MerchandiseV2</span> <span class="variable">ccm</span> <span class="operator">=</span> shellColorChangePhone;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 父类的引用，可以指向子类的对象。</span></span><br><span class="line">        <span class="comment">// TODO 确定MerchandiseV2的引用ccm是指向的是Phone或者Phone的子类对象，那么可以强制类型转换</span></span><br><span class="line">        <span class="type">Phone</span> <span class="variable">ccp</span> <span class="operator">=</span> (Phone) ccm;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 确定MerchandiseV2的引用ccm是指向的是ShellColorChangePhone或者ShellColorChangePhone的子类对象</span></span><br><span class="line">        <span class="comment">// TODO 那么可以强制类型转换</span></span><br><span class="line">        <span class="type">ShellColorChangePhone</span> <span class="variable">scp</span> <span class="operator">=</span> (ShellColorChangePhone) ccm;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 会出错，因为m2指向的是一个Phone类型的对象，不是ShellColorChangePhone的对象</span></span><br><span class="line">        <span class="type">ShellColorChangePhone</span> <span class="variable">notCCP</span> <span class="operator">=</span> (ShellColorChangePhone) m2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="5-多态性"><a href="#5-多态性" class="headerlink" title="5 多态性"></a>5 多态性</h1><h2 id="5-1-多态的形式和体现"><a href="#5-1-多态的形式和体现" class="headerlink" title="5.1 多态的形式和体现"></a>5.1 多态的形式和体现</h2><p>对象的多态：在Java中，子类的对象可以替代父类的对象使用。所以，一个引用类型变量可能指向(引用)多种不同类型的对象</p>
<p>Java引用变量有两个类型：<code>编译时类型</code>和<code>运行时类型</code>。编译时类型由<code>声明</code>该变量时使用的类型决定，运行时类型由<code>实际赋给该变量的对象</code>决定。简称：<strong>编译时，看左边；运行时，看右边。</strong></p>
<ul>
<li>若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)</li>
<li>多态情况下，“看左边”：看的是父类的引用（父类中不具备子类特有的方法）<br>  “看右边”：看的是子类的对象（实际运行的是子类重写父类的方法）</li>
</ul>
<p>多态的使用前提：1. 类的继承关系 2. 方法的重写</p>
<p><strong>举例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String nickname; <span class="comment">//昵称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getNickname</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNickname</span><span class="params">(String nickname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(nickname + <span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="comment">//子类重写父类的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫咪&quot;</span> + getNickname() + <span class="string">&quot;吃鱼仔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类扩展的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抓老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="comment">//子类重写父类的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗子&quot;</span> + getNickname() + <span class="string">&quot;啃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类扩展的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watchHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;看家&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、方法内局部变量的赋值体现多态</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//多态引用</span></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">pet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        pet.setNickname(<span class="string">&quot;小白&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//多态的表现形式</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        编译时看父类：只能调用父类声明的方法，不能调用子类扩展的方法；</span></span><br><span class="line"><span class="comment">        运行时，看“子类”，如果子类重写了方法，一定是执行子类重写的方法体；</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pet.eat();<span class="comment">//运行时执行子类Dog重写的方法</span></span><br><span class="line"><span class="comment">//      pet.watchHouse();//不能调用Dog子类扩展的方法</span></span><br><span class="line"></span><br><span class="line">        pet = <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        pet.setNickname(<span class="string">&quot;雪球&quot;</span>);</span><br><span class="line">        pet.eat();<span class="comment">//运行时执行子类Cat重写的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、方法的形参声明体现多态</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adopt</span><span class="params">(Pet pet)</span> &#123;<span class="comment">//形参是父类类型，实参是子类对象</span></span><br><span class="line">        <span class="built_in">this</span>.pet = pet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">()</span>&#123;</span><br><span class="line">        pet.eat();<span class="comment">//pet实际引用的对象类型不同，执行的eat方法也不同</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPerson</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog.setNickname(<span class="string">&quot;小白&quot;</span>);</span><br><span class="line">        person.adopt(dog);<span class="comment">//实参是dog子类对象，形参是父类Pet类型</span></span><br><span class="line">        person.feed();</span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.setNickname(<span class="string">&quot;雪球&quot;</span>);</span><br><span class="line">        person.adopt(cat);<span class="comment">//实参是cat子类对象，形参是父类Pet类型</span></span><br><span class="line">        person.feed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、方法返回值类型体现多态</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PetShop</span> &#123;</span><br><span class="line">    <span class="comment">//返回值类型是父类类型，实际返回的是子类对象</span></span><br><span class="line">    <span class="keyword">public</span> Pet <span class="title function_">sale</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Dog&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Cat&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.polymorphism.grammar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPetShop</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PetShop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PetShop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">dog</span> <span class="operator">=</span> shop.sale(<span class="string">&quot;Dog&quot;</span>);</span><br><span class="line">        dog.setNickname(<span class="string">&quot;小白&quot;</span>);</span><br><span class="line">        dog.eat();</span><br><span class="line"></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">cat</span> <span class="operator">=</span> shop.sale(<span class="string">&quot;Cat&quot;</span>);</span><br><span class="line">        cat.setNickname(<span class="string">&quot;雪球&quot;</span>);</span><br><span class="line">        cat.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-多态的好处和弊端"><a href="#5-2-多态的好处和弊端" class="headerlink" title="5.2 多态的好处和弊端"></a>5.2 多态的好处和弊端</h2><p><strong>好处</strong>：变量引用的子类对象不同，执行的方法就不同，实现动态绑定。代码编写更灵活、功能更强大，可维护性和扩展性更好了。<br><strong>弊端</strong>：一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();  </span><br><span class="line">m.school = <span class="string">&quot;pku&quot;</span>; <span class="comment">//合法,Student类有school成员变量  </span></span><br><span class="line"><span class="type">Person</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();   </span><br><span class="line">e.school = <span class="string">&quot;pku&quot;</span>; <span class="comment">//非法,Person类没有school成员变量  </span></span><br><span class="line">​  </span><br><span class="line"><span class="comment">// 属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误。</span></span><br></pre></td></tr></table></figure>

<p>开发中：使用父类做方法的形参，是多态使用最多的场合。即使增加了新的子类，方法也无需改变，提高了扩展性，符合开闭原则。</p>
<h2 id="5-3-虚方法调用"><a href="#5-3-虚方法调用" class="headerlink" title="5.3 虚方法调用"></a>5.3 虚方法调用</h2><p>在Java中虚方法是指在编译阶段不能确定方法的调用入口地址，在运行阶段才能确定的方法，即可能被重写的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();  </span><br><span class="line">e.getInfo();  <span class="comment">//调用Student类的getInfo()方法</span></span><br></pre></td></tr></table></figure>
<p>子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/20240702154525.png" alt="image.png"><br>前提：Person类中定义了welcome()方法，各个子类重写了welcome()。</p>
<p>拓展：<br><code>静态链接（或早起绑定）</code>：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。那么调用这样的方法，就称为非虚方法调用。比如调用静态方法、私有方法、final方法、父类构造器、本类重载构造器等。<br><code>动态链接（或晚期绑定）</code>：如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。调用这样的方法，就称为虚方法调用。比如调用重写的方法（针对父类）、实现的方法（针对接口）。</p>
<h2 id="5-5-instanceof操作符"><a href="#5-5-instanceof操作符" class="headerlink" title="5.5 instanceof操作符"></a>5.5 instanceof操作符</h2><p>instanceof 操作符，可以判断一个引用指向的对象是否是某一个类型或者其子类，是则返回true，否则返回false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.geekbang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.geekbang.supermarket.LittleSuperMarket;</span><br><span class="line"><span class="keyword">import</span> com.geekbang.supermarket.MerchandiseV2;</span><br><span class="line"><span class="keyword">import</span> com.geekbang.supermarket.Phone;</span><br><span class="line"><span class="keyword">import</span> com.geekbang.supermarket.ShellColorChangePhone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceOfTestAppMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">merchandiseCount</span> <span class="operator">=</span> <span class="number">600</span>;</span><br><span class="line">        <span class="type">LittleSuperMarket</span> <span class="variable">superMarket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LittleSuperMarket</span>(<span class="string">&quot;大卖场&quot;</span>,</span><br><span class="line">            <span class="string">&quot;世纪大道1号&quot;</span>, <span class="number">500</span>, merchandiseCount, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt; TODO instanceof 操作符，可以判断一个引用指向的对象是否是某一个类型或者其子类</span></span><br><span class="line">        <span class="comment">//    TODO 是则返回true，否则返回false</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;merchandiseCount;i++)&#123;</span><br><span class="line">            <span class="type">MerchandiseV2</span> <span class="variable">m</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">// superMarket.getMerchandiseOf(i);</span></span><br><span class="line">            <span class="keyword">if</span>(m <span class="keyword">instanceof</span> MerchandiseV2)&#123;</span><br><span class="line">                <span class="comment">// TODO 先判断，再强制类型转换，比较安全</span></span><br><span class="line">                <span class="type">MerchandiseV2</span> <span class="variable">ph</span> <span class="operator">=</span> (MerchandiseV2)m;</span><br><span class="line">                System.out.println(ph.getName());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;not an instance&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt; TODO 如果引用是null，则肯定返回false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-Object类的使用"><a href="#6-Object类的使用" class="headerlink" title="6 Object类的使用"></a>6 Object类的使用</h1><h2 id="6-1-根父类"><a href="#6-1-根父类" class="headerlink" title="6.1 根父类"></a>6.1 根父类</h2><p>所有的类，都直接或间接地继承自Object类。<br>Object类的对象可以指向任意类，Object类中没有属性，只有方法，定义的对象如下：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/202308081038318.png"></p>
<h2 id="6-2-Object类中的方法："><a href="#6-2-Object类中的方法：" class="headerlink" title="6.2 Object类中的方法："></a>6.2 Object类中的方法：</h2><h3 id="6-2-1-equals"><a href="#6-2-1-equals" class="headerlink" title="6.2.1 equals"></a>6.2.1 equals</h3><p>在Object类中定义判断两个对象的逻辑如下：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/202308081043733.png"><br>比较两个引用是否指向的是相同的类实例。</p>
<p>equals方法也是所有自定义类中覆盖实现比较多的方法，通过重新实现equals方法的逻辑，比较自定义类的对象。</p>
<ul>
<li><strong>String类中对Object的使用</strong></li>
</ul>
<p><strong>程序示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.geekbang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.geekbang.supermarket.LittleSuperMarket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringEqualsAppMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">LittleSuperMarket</span> <span class="variable">superMarket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LittleSuperMarket</span>(<span class="string">&quot;大卖场&quot;</span>,</span><br><span class="line">            <span class="string">&quot;世纪大道1号&quot;</span>, <span class="number">500</span>, <span class="number">600</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;aaabbb&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span> + <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt; TODO 说好的每次创建一个新的String对象呢？</span></span><br><span class="line">        System.out.println(<span class="string">&quot;s1和s2用==判断结果：&quot;</span>+(s1 == s2));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;s1和s2用 equals 判断结果：&quot;</span>+(s1.equals(s2)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt; TODO 打乱Java对String的的优化，再试试看</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入s1&quot;</span>);</span><br><span class="line">        s1 = scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入s2&quot;</span>);</span><br><span class="line">        s2 = scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;s1和s2用==判断结果：&quot;</span>+(s1 == s2));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;s1和s2用 equals 判断结果：&quot;</span>+(s1.equals(s2)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s1和s2用==判断结果：true</span><br><span class="line">s1和s2用 equals 判断结果：true</span><br><span class="line">请输入s1</span><br><span class="line">C:\Users\baihaoliang\.jdks\corretto-1.8.0_382\bin\java.exe -javaagent:D:\JetBrains\apps\IDEA-U\ch-0\231.9225.16\lib\idea_rt.jar=12228:D:\JetBrains\apps\IDEA-U\ch-0\231.9225.16\bin -Dfile.encoding=U</span><br><span class="line">请输入s2</span><br><span class="line">C:\Users\baihaoliang\.jdks\corretto-1.8.0_382\bin\java.exe -javaagent:D:\JetBrains\apps\IDEA-U\ch-0\231.9225.16\lib\idea_rt.jar=12228:D:\JetBrains\apps\IDEA-U\ch-0\231.9225.16\bin -Dfile.encoding=U</span><br><span class="line">s1和s2用==判断结果：false</span><br><span class="line">s1和s2用 equals 判断结果：true</span><br></pre></td></tr></table></figure>

<p>String中定义的字符串是不可变的，所以按说在定义s1和s2时应该是不同的两个引用，但是在使用”=&#x3D;”进行比较时发现是相等的。这是因为在Java中定义字符串时，如果底层有一个相同的字符串，则不会重新定义，会把新的引用指向之前的字符串。<br>但是在定义的字符串很长时，则会突破这个优化，如上，输入了一个很长的字符串，使用<code>&quot;==&quot;</code>比较是不相同的，但是使用equals是相同的，下边看下String类中对equals方法的覆盖实现：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/202308081053010.png"><br>String中重新实现了equals方法按字符进行遍历比较，所以再长的字符串的情况下依然可以比较。</p>
<p><strong>面试题：</strong><code>==</code>和equals的区别</p>
<ul>
<li><code>==</code> 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址</li>
<li>equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是<code>==</code>;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点。</li>
<li>具体要看自定义类里有没有重写Object的equals方法来判断。</li>
<li>通常情况下，重写equals方法，会比较类中的相应属性是否都相等。</li>
</ul>
<h3 id="6-2-2-hashCode"><a href="#6-2-2-hashCode" class="headerlink" title="6.2.2 hashCode"></a>6.2.2 hashCode</h3><p>hashCode可以翻译为哈希码，或者散列码。应该是一个表示对象的特征的int整数。<br>自定义类中可以进行覆盖实现，来表示依次来表示类的唯一标识。</p>
<blockquote>
<p>equals和hashCode是最常覆盖的两个方法，实现逻辑为，equals方法为true，则hashCode就相等，但hashCode相等，equals不一定为true。</p>
</blockquote>
<h3 id="6-2-3-toString"><a href="#6-2-3-toString" class="headerlink" title="6.2.3 toString"></a>6.2.3 toString</h3><p>方法签名：public String toString()<br>① 默认情况下，toString()返回的是“对象的运行时类型 @ 对象的hashCode值的十六进制形式”<br>② 在进行String与其它类型数据的连接操作时，自动调用toString()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date now=<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(“now=”+now);  <span class="comment">//相当于</span></span><br><span class="line">System.out.println(“now=”+now.toString()); </span><br></pre></td></tr></table></figure>

<p>③ 如果我们直接System.out.println(对象)，默认会自动调用这个对象的toString()</p>
<blockquote>
<p>因为Java的引用数据类型的变量中存储的实际上时对象的内存地址，但是Java对程序员隐藏内存地址信息，所以不能直接将内存地址显示出来，所以当你打印对象时，JVM帮你调用了对象的toString()。</p>
</blockquote>
<p>④ 可以根据需要在用户自定义类型中重写toString()方法<br>    如String 类重写了toString()方法，返回字符串的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s1);<span class="comment">//相当于System.out.println(s1.toString());</span></span><br></pre></td></tr></table></figure>

<p>例如自定义的Person类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-4-finalize"><a href="#6-2-4-finalize" class="headerlink" title="6.2.4 finalize()"></a>6.2.4 finalize()</h3><ul>
<li>当对象被回收时，系统自动调用该对象的 finalize() 方法。（不是垃圾回收器调用的，是本类对象调用的）<ul>
<li>永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。</li>
</ul>
</li>
<li>什么时候被回收：当某个对象没有任何引用时，JVM就认为这个对象是垃圾对象，就会在之后不确定的时间使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用 finalize()方法。 </li>
<li>子类可以重写该方法，目的是在对象被清理之前执行必要的清理操作。比如，在方法内断开相关连接资源。<ul>
<li>如果重写该方法，让一个新的引用变量重新引用该对象，则会重新激活对象。</li>
</ul>
</li>
<li>在JDK 9中此方法已经被<code>标记为过时</code>的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Peter&quot;</span>, <span class="number">12</span>);</span><br><span class="line">		System.out.println(p);</span><br><span class="line">		p = <span class="literal">null</span>;<span class="comment">//此时对象实体就是垃圾对象，等待被回收。但时间不确定。</span></span><br><span class="line">		System.gc();<span class="comment">//强制性释放空间</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//子类重写此方法，可在释放对象前进行某些操作</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;对象被释放---&gt;&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-5-getClass"><a href="#6-2-5-getClass" class="headerlink" title="6.2.5 getClass()"></a>6.2.5 getClass()</h3><p><code>public final Class&lt;?&gt; getClass()</code>：获取对象的运行时类型</p>
<blockquote>
<p>因为Java有多态现象，所以一个引用数据类型的变量的编译时类型与运行时类型可能不一致，因此如果需要查看这个变量实际指向的对象的类型，需要用getClass()方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">	System.out.println(obj.getClass());<span class="comment">//运行时类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">com</span>.atguigu.java.Person</span><br></pre></td></tr></table></figure>

<h1 id="7-关键字：static"><a href="#7-关键字：static" class="headerlink" title="7 关键字：static"></a>7 关键字：static</h1><h2 id="7-1-static-关键字"><a href="#7-1-static-关键字" class="headerlink" title="7.1 static 关键字"></a>7.1 static 关键字</h2><ul>
<li>使用范围：<ul>
<li>在Java类中，可用static修饰属性、方法、代码块、内部类</li>
</ul>
</li>
<li>被修饰后的成员具备以下特点：<ul>
<li>随着类的加载而加载</li>
<li>优先于对象存在</li>
<li>修饰的成员，被所有对象所共享</li>
<li>访问权限允许时，可不创建对象，直接被类调用</li>
</ul>
</li>
</ul>
<h2 id="7-2-静态变量"><a href="#7-2-静态变量" class="headerlink" title="7.2 静态变量"></a>7.2 静态变量</h2><ul>
<li>静态变量的默认值规则和实例变量一样。</li>
<li>静态变量值是所有对象共享。</li>
<li>静态变量在本类中，可以在任意方法、代码块、构造器中直接使用。</li>
<li>如果权限修饰符允许，在其他类中可以通过“<code>类名.静态变量</code>”直接访问，也可以通过“<code>对象.静态变量</code>”的方式访问（但是更推荐使用类名.静态变量的方式）。</li>
<li>静态变量的get&#x2F;set方法也静态的，当局部变量与静态变量<code>重名时</code>，使用“<code>类名.静态变量</code>”进行区分。</li>
</ul>
<h2 id="7-3-静态方法"><a href="#7-3-静态方法" class="headerlink" title="7.3 静态方法"></a>7.3 静态方法</h2><ul>
<li>静态方法在本类的任意方法、代码块、构造器中都可以直接被调用。</li>
<li>只要权限修饰符允许，静态方法在其他类中可以通过“类名.静态方法“的方式调用。也可以通过”对象.静态方法“的方式调用（但是更推荐使用类名.静态方法的方式）。</li>
<li>在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构。</li>
<li>静态方法可以被子类继承，但不能被子类重写。</li>
<li>静态方法的调用都只看编译时类型。</li>
<li>因为不需要实例就可以访问static方法，因此static方法内部不能有this，也不能有super。如果有重名问题，使用“类名.”进行区别。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father.method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father.fun&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="comment">//    @Override //尝试重写静态方法，加上@Override编译报错，去掉Override不报错，但是也不是重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son.fun&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStaticMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Father.method();</span><br><span class="line">        Son.method();<span class="comment">//继承静态方法</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        f.method();<span class="comment">//执行Father类中的method</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-代码块"><a href="#8-代码块" class="headerlink" title="8 代码块"></a>8 代码块</h1><h2 id="8-1-静态代码块"><a href="#8-1-静态代码块" class="headerlink" title="8.1 静态代码块"></a>8.1 静态代码块</h2><ol>
<li>可以有输出语句。</li>
<li>可以对类的属性、类的声明进行初始化操作。</li>
<li>不可以对非静态的属性初始化。即：<strong>不可以调用非静态的属性和方法</strong>。</li>
<li>若有多个静态的代码块，那么按照从上到下的顺序依次执行。</li>
<li>静态代码块的执行要先于非静态代码块。</li>
<li>静态代码块随着类的加载而加载，且只执行一次。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.keyword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chinese</span> &#123;</span><br><span class="line"><span class="comment">//    private static String country = &quot;中国&quot;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String country;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;非静态代码块，country = &quot;</span> + country);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        country = <span class="string">&quot;中国&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chinese</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-2-非静态代码块"><a href="#8-2-非静态代码块" class="headerlink" title="8.2 非静态代码块"></a>8.2 非静态代码块</h2><p>如果多个重载的构造器有公共代码，并且这些代码都是先于构造器其他代码执行的，那么可以将这部分代码抽取到非静态代码块中，减少冗余代码。</p>
<ol>
<li>可以有输出语句。</li>
<li>可以对类的属性、类的声明进行初始化操作。</li>
<li>除了调用非静态的结构外，还可以调用静态的变量或方法。</li>
<li>若有多个非静态的代码块，那么按照从上到下的顺序依次执行。</li>
<li>每次创建对象的时候，都会执行一次。且先于构造器执行。</li>
</ol>
<h1 id="9-final-修饰符"><a href="#9-final-修饰符" class="headerlink" title="9 final 修饰符"></a>9 final 修饰符</h1><h2 id="9-1-final修饰类：不可被继承"><a href="#9-1-final修饰类：不可被继承" class="headerlink" title="9.1 final修饰类：不可被继承"></a>9.1 final修饰类：不可被继承</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Eunuch</span>&#123;<span class="comment">//太监类</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Eunuch</span>&#123;<span class="comment">//错误</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-2-final修饰方法：不可被子类覆盖"><a href="#9-2-final修饰方法：不可被子类覆盖" class="headerlink" title="9.2 final修饰方法：不可被子类覆盖"></a>9.2 final修饰方法：不可被子类覆盖</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;father&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;<span class="comment">//错误</span></span><br><span class="line">		System.out.println(<span class="string">&quot;son&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-3-final-修饰变量"><a href="#9-3-final-修饰变量" class="headerlink" title="9.3 final 修饰变量"></a>9.3 final 修饰变量</h2><p>final修饰某个变量（成员变量或局部变量），一旦赋值，它的值就不能被修改，即常量，常量名建议使用大写字母。<br>例如：<code>final double MY_PI = 3.14;</code></p>
<ol>
<li><p>构造方法不能用final修饰</p>
</li>
<li><p>使用final修饰方法的形参后，则无法在方法内修改形参变量</p>
</li>
<li><p>修饰静态变量：需要初始化，或者在static块中初始化，并且初始化后无法修改。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_BUY_ONE_ORDER</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"><span class="comment">//或   选其一</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    MAX_BUY_ONE_ORDER = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>修饰属性：只能在定义时初始化或者构造方法中初始化，初始化后无法修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">totalNumber</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> ID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">        ID = ++totalNumber; <span class="comment">// 可在构造器中给final修饰的“变量”赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        System.out.println(t.ID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰引用：引用类型本身初始化后无法修改，但可以通过引用修改引用的对象内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">array = array1;  <span class="comment">//报错，无法修改final变量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> b : array) &#123;  <span class="comment">//for循环的一种新形式</span></span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修饰局部变量：只能初始化一次，后边不能再次修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFinal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> MIN_SCORE ;</span><br><span class="line">        MIN_SCORE = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SCORE</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        MAX_SCORE = <span class="number">200</span>; <span class="comment">//非法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="10-抽象类与抽象方法"><a href="#10-抽象类与抽象方法" class="headerlink" title="10 抽象类与抽象方法"></a>10 抽象类与抽象方法</h1><h2 id="10-1-语法格式"><a href="#10-1-语法格式" class="headerlink" title="10.1 语法格式"></a>10.1 语法格式</h2><ul>
<li><strong>抽象类</strong>：被abstract修饰的类。</li>
<li><strong>抽象方法</strong>：被abstract修饰没有方法体的方法。</li>
</ul>
<p>抽象类的语法格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[权限修饰符] <span class="keyword">abstract</span> class 类名&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">[权限修饰符] <span class="keyword">abstract</span> class 类名 extends 父类&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象方法的语法格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[其他修饰符] <span class="keyword">abstract</span> 返回值类型 方法名([形参列表]);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：抽象方法没有方法体</p>
</blockquote>
<p>代码举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span> <span class="params">()</span>&#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;小猫吃鱼和猫粮&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CatTest</span> &#123;</span><br><span class="line"> 	 <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建子类对象</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(); </span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 调用eat方法</span></span><br><span class="line">        c.eat();</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做<strong>实现方法</strong>。</p>
<h2 id="10-2-使用说明"><a href="#10-2-使用说明" class="headerlink" title="10.2 使用说明"></a>10.2 使用说明</h2><ol>
<li>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。<blockquote>
<p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。<br>抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。</p>
</blockquote>
</li>
<li>抽象类中，也有构造方法，是供子类创建对象时，初始化父类成员变量使用的。<blockquote>
<p>理解：子类的构造方法中，有默认的super()或手动的super(实参列表)，需要访问父类构造方法。</p>
</blockquote>
</li>
<li>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。<blockquote>
<p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p>
</blockquote>
</li>
<li>抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。 <blockquote>
<p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p>
</blockquote>
</li>
</ol>
<h2 id="10-3-注意事项"><a href="#10-3-注意事项" class="headerlink" title="10.3 注意事项"></a>10.3 注意事项</h2><ul>
<li>不能用abstract修饰变量、代码块、构造器；</li>
<li>不能用abstract修饰私有方法、静态方法、final的方法、final的类。</li>
</ul>
<h1 id="11-接口（interface）"><a href="#11-接口（interface）" class="headerlink" title="11 接口（interface）"></a>11 接口（interface）</h1><h2 id="11-1-接口的声明格式"><a href="#11-1-接口的声明格式" class="headerlink" title="11.1 接口的声明格式"></a>11.1 接口的声明格式</h2><p>接口的定义，它与定义类方式相似，但是使用 <code>interface</code> 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。</p>
<blockquote>
<p>引用数据类型：数组，类，枚举，接口，注解。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] interface 接口名&#123;</span><br><span class="line">    <span class="comment">//接口的成员列表：</span></span><br><span class="line">    <span class="comment">// 公共的静态常量</span></span><br><span class="line">    <span class="comment">// 公共的抽象方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公共的默认方法（JDK1.8以上）</span></span><br><span class="line">    <span class="comment">// 公共的静态方法（JDK1.8以上）</span></span><br><span class="line">    <span class="comment">// 私有方法（JDK1.9以上）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">USB3</span>&#123;</span><br><span class="line">    <span class="comment">//静态常量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">MAX_SPEED</span> <span class="operator">=</span> <span class="number">500</span>*<span class="number">1024</span>*<span class="number">1024</span>;<span class="comment">//500MB/s</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;USB 3.0可以同步全速地进行读写操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-2-接口的使用规则"><a href="#11-2-接口的使用规则" class="headerlink" title="11.2 接口的使用规则"></a>11.2 接口的使用规则</h2><h3 id="11-2-1-类实现接口"><a href="#11-2-1-类实现接口" class="headerlink" title="11.2.1 类实现接口"></a>11.2.1 类实现接口</h3><p>接口<strong>不能创建对象</strong>，但是可以被类实现（<code>implements</code> ，类似于被继承）。</p>
<p>类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的实现类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 <code>implements</code>关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 class 实现类  implements 接口&#123;</span><br><span class="line">	<span class="comment">// 重写接口中抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写</span></span><br><span class="line">  	<span class="comment">// 重写接口中默认方法【可选】</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】 class 实现类 extends 父类 implements 接口&#123;</span><br><span class="line">    <span class="comment">// 重写接口中抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写</span></span><br><span class="line">  	<span class="comment">// 重写接口中默认方法【可选】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/20240703110522.png" alt="image.png"></p>
<ol>
<li>如果接口的实现类是非抽象类，那么必须<code>重写接口中所有抽象方法</code>。</li>
<li>默认方法可以选择保留，也可以重写。重写时，default单词就不要再写了，它只用于在接口中表示默认方法，到类中就没有默认方法的概念了</li>
<li>接口中的静态方法不能被继承也不能被重写</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span>&#123;		<span class="comment">// </span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> ;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> ;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(USB usb)</span>&#123;	</span><br><span class="line">		usb.start() ;</span><br><span class="line">		System.out.println(<span class="string">&quot;=========== USB 设备工作 ========&quot;</span>) ;</span><br><span class="line">		usb.stop() ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flash</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;	<span class="comment">// 重写方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;U盘开始工作。&quot;</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;		<span class="comment">// 重写方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;U盘停止工作。&quot;</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Print</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;	<span class="comment">// 重写方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;打印机开始工作。&quot;</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;		<span class="comment">// 重写方法</span></span><br><span class="line">		System.out.println(<span class="string">&quot;打印机停止工作。&quot;</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceDemo</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">		Computer.show(<span class="keyword">new</span> <span class="title class_">Flash</span>()) ;</span><br><span class="line">		Computer.show(<span class="keyword">new</span> <span class="title class_">Print</span>()) ;</span><br><span class="line"></span><br><span class="line">		c.show(<span class="keyword">new</span> <span class="title class_">USB</span>()&#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;移动硬盘开始运行&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;移动硬盘停止运行&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="11-2-2-接口的多实现"><a href="#11-2-2-接口的多实现" class="headerlink" title="11.2.2 接口的多实现"></a>11.2.2 接口的多实现</h3><p>在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的<code>多实现</code>。并且，一个类能继承一个父类，同时实现多个接口。<br><strong>实现格式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 class 实现类  implements 接口<span class="number">1</span>，接口<span class="number">2</span>，接口<span class="number">3</span>。。。&#123;</span><br><span class="line">	<span class="comment">// 重写接口中所有抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写</span></span><br><span class="line">  	<span class="comment">// 重写接口中默认方法【可选】</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】 class 实现类 extends 父类 implements 接口<span class="number">1</span>，接口<span class="number">2</span>，接口<span class="number">3</span>。。。&#123;</span><br><span class="line">    <span class="comment">// 重写接口中所有抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写</span></span><br><span class="line">  	<span class="comment">// 重写接口中默认方法【可选】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接口中，有多个抽象方法时，实现类必须重写所有抽象方法。<strong>如果抽象方法有重名的，只需要重写一次</strong>。</p>
</blockquote>
<h3 id="11-2-3-接口的继承"><a href="#11-2-3-接口的继承" class="headerlink" title="11.2.3 接口的继承"></a>11.2.3 接口的继承</h3><p>一个接口能继承另一个或者多个接口，接口的继承也使用 <code>extends</code> 关键字，子接口继承父接口的方法。</p>
<p><strong>Intf1接口：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.geekbang.intf;</span><br><span class="line"></span><br><span class="line">public interface Intf1 &#123;</span><br><span class="line">    void m1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Intf2接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.geekbang.intf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Intf2</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Intf3接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.geekbang.intf;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt;&gt; TODO 接口也可以继承接口。接口可以继承多个接口，接口之间的继承要用extends</span></span><br><span class="line"><span class="comment">// &gt;&gt; TODO 接口不可以继承类</span></span><br><span class="line"><span class="comment">// &gt;&gt; TODO 继承的接口，可以有重复的方法，但是签名相同时，返回值必须完全一样，否则会有编译错误</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Intf3</span> <span class="keyword">extends</span> <span class="title class_">Intf1</span>, Intf2&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>接口不可以继承类</li>
<li>接口不可以声明实例变量</li>
<li>如果一个类继承了两个接口，并且两个接口中的有相同的缺省方法，则编译报错。</li>
<li>接口中可以有静态方法，不需要用default修饰。静态方法可以被实现接口的类继承</li>
<li>接口中的this自引用，this引用的是实现这个接口的类所定义的实例</li>
</ul>
<h3 id="11-2-4-有方法的代码的接口"><a href="#11-2-4-有方法的代码的接口" class="headerlink" title="11.2.4 有方法的代码的接口"></a>11.2.4 有方法的代码的接口</h3><ul>
<li>在Java 8中，接口允许有缺省实现的抽象方法。</li>
<li>缺省的实现方法，用default修饰，可以有方法体</li>
<li>接口中可以有私有方法，不需要用default修饰</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.geekbang.supermarket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExpireDateMerchandise</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 缺省的实现方法，用default修饰，可以有方法体</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">notExpireInDays</span><span class="params">(<span class="type">int</span> days)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> daysBeforeExpire() &gt; days;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 接口中可以有私有方法，不需要用default修饰</span></span><br><span class="line">    <span class="comment">// &gt;&gt; TODO 接口里的私有方法，可以认为是代码直接插入到使用的地方</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">daysBeforeExpire</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">expireMS</span> <span class="operator">=</span> getExpireDate().getTime();</span><br><span class="line">        <span class="type">long</span> <span class="variable">left</span> <span class="operator">=</span> expireMS - System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回值是long，是根据left的类型决定的</span></span><br><span class="line">        <span class="keyword">return</span> left / (<span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>面对有缺省方法的接口，一个类继承时可以有三种选择：</p>
<ol>
<li>默默继承，相当于类具有了这个方法的实现</li>
<li>覆盖，重新实现</li>
<li>把此方法声明为abstract，相当于把这个方法的实现拒之门外，但有abstrace方法的类，此类也就成了抽象类。</li>
</ol>
<h3 id="11-2-5-接口与实现类对象构成多态引用"><a href="#11-2-5-接口与实现类对象构成多态引用" class="headerlink" title="11.2.5 接口与实现类对象构成多态引用"></a>11.2.5 接口与实现类对象构成多态引用</h3><p>实现类实现接口，类似于子类继承父类，因此，接口类型的变量与实现类的对象之间，也可以构成多态引用。通过接口类型的变量调用方法，最终执行的是你new的实现类对象实现的方法体。</p>
<p><strong>接口的不同实现类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">implements</span> <span class="title class_">USB3</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送脉冲信号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不接收信号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KeyBoard</span> <span class="keyword">implements</span> <span class="title class_">USB3</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不接收信号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送按键信号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestComputer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">USB3</span> <span class="variable">usb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mouse</span>();</span><br><span class="line">        computer.setUsb(usb);</span><br><span class="line">        usb.start();</span><br><span class="line">        usb.out();</span><br><span class="line">        usb.in();</span><br><span class="line">        usb.stop();</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        usb = <span class="keyword">new</span> <span class="title class_">KeyBoard</span>();</span><br><span class="line">        computer.setUsb(usb);</span><br><span class="line">        usb.start();</span><br><span class="line">        usb.out();</span><br><span class="line">        usb.in();</span><br><span class="line">        usb.stop();</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        usb = <span class="keyword">new</span> <span class="title class_">MobileHDD</span>();</span><br><span class="line">        computer.setUsb(usb);</span><br><span class="line">        usb.start();</span><br><span class="line">        usb.out();</span><br><span class="line">        usb.in();</span><br><span class="line">        usb.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-2-6-使用接口的静态成员"><a href="#11-2-6-使用接口的静态成员" class="headerlink" title="11.2.6 使用接口的静态成员"></a>11.2.6 使用接口的静态成员</h3><p>接口不能直接创建对象，但是可以通过接口名直接调用接口的静态方法和静态常量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUSB3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//通过“接口名.”调用接口的静态方法 (JDK8.0才能开始使用)</span></span><br><span class="line">        USB3.show();</span><br><span class="line">        <span class="comment">//通过“接口名.”直接使用接口的静态常量</span></span><br><span class="line">        System.out.println(USB3.MAX_SPEED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-2-7-使用接口的非静态方法"><a href="#11-2-7-使用接口的非静态方法" class="headerlink" title="11.2.7 使用接口的非静态方法"></a>11.2.7 使用接口的非静态方法</h3><ul>
<li>对于接口的静态方法，直接使用“<code>接口名.</code>”进行调用即可<ul>
<li>也只能使用“接口名.”进行调用，不能通过实现类的对象进行调用</li>
</ul>
</li>
<li>对于接口的抽象方法、默认方法，只能通过实现类对象才可以调用<ul>
<li>接口不能直接创建对象，只能创建实现类的对象</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.interfacetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMobileHDD</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建实现类对象</span></span><br><span class="line">        <span class="type">MobileHDD</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MobileHDD</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过实现类对象调用重写的抽象方法，以及接口的默认方法，如果实现类重写了就执行重写的默认方法，如果没有重写，就执行接口中的默认方法</span></span><br><span class="line">        b.start();</span><br><span class="line">        b.in();</span><br><span class="line">        b.stop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过接口名调用接口的静态方法</span></span><br><span class="line"><span class="comment">//        MobileHDD.show();</span></span><br><span class="line"><span class="comment">//        b.show();</span></span><br><span class="line">        Usb3.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-3-接口的几种使用方法"><a href="#11-3-接口的几种使用方法" class="headerlink" title="11.3 接口的几种使用方法"></a>11.3 接口的几种使用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">USBTest</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//1.创建接口实现类的对象  </span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Computer</span>();  </span><br><span class="line">        <span class="type">Printer</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Printer</span>();  </span><br><span class="line">  </span><br><span class="line">        computer.transferData(printer);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//2.创建接口实现类的匿名对象  </span></span><br><span class="line">        computer.transferData(<span class="keyword">new</span> <span class="title class_">Camera</span>());  </span><br><span class="line">        System.out.println();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//3.创建接口匿名实现类的对象  </span></span><br><span class="line">        <span class="type">USB</span> <span class="variable">usb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">USB</span>()&#123;  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;U盘开始工作&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;U盘结束工作&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">        computer.transferData(usb1);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//4. 创建接口匿名实现类的匿名对象  </span></span><br><span class="line">  </span><br><span class="line">        computer.transferData(<span class="keyword">new</span> <span class="title class_">USB</span>()&#123;  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;扫描仪开始工作&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;扫描仪结束工作&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-4-接口与抽象类对比"><a href="#11-4-接口与抽象类对比" class="headerlink" title="11.4 接口与抽象类对比"></a>11.4 接口与抽象类对比</h2><p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/20240703111716.png" alt="image.png"></p>
<h1 id="12-内部类（InnerClass）"><a href="#12-内部类（InnerClass）" class="headerlink" title="12 内部类（InnerClass）"></a>12 内部类（InnerClass）</h1><p>将一个类A定义在另一个类B里面，里面的那个类A就称为<code>内部类（InnerClass）</code>，类B则称为<code>外部类（OuterClass）</code>。</p>
<p>根据内部类声明额未知，可以分为：<br> <img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/20240703143623.png" alt="image.png"></p>
<h2 id="12-1-成员内部类"><a href="#12-1-成员内部类" class="headerlink" title="12.1 成员内部类"></a>12.1 成员内部类</h2><h3 id="12-1-1-概述"><a href="#12-1-1-概述" class="headerlink" title="12.1.1 概述"></a>12.1.1 概述</h3><p>如果成员内部类中不使用外部类的非静态成员，那么通常将内部类声明为静态内部类，否则声明为非静态内部类。<br><strong>成员内部类的使用特征：</strong></p>
<ul>
<li>成员内部类作为<code>类的成员的角色</code>：<ul>
<li>和外部类不同，Inner class还可以声明为private或protected；</li>
<li>可以调用外部类的结构。（注意：在静态内部类中不能使用外部类的非静态成员）</li>
<li>Inner class 可以声明为static的，但此时就不能再使用外层类的非static的成员变量；</li>
</ul>
</li>
<li>成员内部类作为<code>类的角色</code>：<ul>
<li>可以在内部定义属性、方法、构造器等结构</li>
<li>可以继承自己的想要继承的父类，实现自己想要实现的父接口们，和外部类的父类和父接口无关</li>
<li>可以声明为abstract类 ，因此可以被其它的内部类继承</li>
<li>可以声明为final的，表示不能被继承</li>
<li>编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式</li>
<li>成员内部类可以直接使用外部类的所有成员，包括私有的数据</li>
<li>当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的</li>
</ol>
<h3 id="12-1-2-创建成员内部类对象"><a href="#12-1-2-创建成员内部类对象" class="headerlink" title="12.1.2 创建成员内部类对象"></a>12.1.2 创建成员内部类对象</h3><ul>
<li><p>实例化静态内部类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外部类名.静态内部类名 变量 = 外部类名.静态内部类名();</span><br><span class="line">变量.非静态方法();</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例化非静态内部类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">外部类名 变量1 = new 外部类();</span><br><span class="line">外部类名.非静态内部类名 变量2 = 变量1.new 非静态内部类名();</span><br><span class="line">变量2.非静态方法();</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMemberInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建静态内部类实例，并调用方法</span></span><br><span class="line">        Outer.<span class="type">StaticInner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticInner();</span><br><span class="line">        inner.inFun();</span><br><span class="line">        <span class="comment">//调用静态内部类静态方法</span></span><br><span class="line">        Outer.StaticInner.inMethod();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建非静态内部类实例（方式1），并调用方法</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">NoStaticInner</span> <span class="variable">inner1</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">NoStaticInner</span>();</span><br><span class="line">        inner1.inFun();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建非静态内部类实例（方式2）</span></span><br><span class="line">        Outer.<span class="type">NoStaticInner</span> <span class="variable">inner2</span> <span class="operator">=</span> outer.getNoStaticInner();</span><br><span class="line">        inner1.inFun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;外部类的静态a&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">b</span>  <span class="operator">=</span> <span class="string">&quot;外部类的静态b&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;外部类对象的非静态c&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;外部类对象的非静态d&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span><span class="string">&quot;静态内部类的静态a&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;静态内部类对象的非静态c&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inMethod</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Inner.a = &quot;</span> + a);</span><br><span class="line">            System.out.println(<span class="string">&quot;Outer.a = &quot;</span> + Outer.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inFun</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Inner.inFun&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Outer.a = &quot;</span> + Outer.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;Inner.a = &quot;</span> + a);</span><br><span class="line">            System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">            System.out.println(<span class="string">&quot;c = &quot;</span> + c);</span><br><span class="line"><span class="comment">//            System.out.println(&quot;d = &quot; + d);//不能访问外部类的非静态成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">NoStaticInner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;非静态内部类对象的非静态a&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;非静态内部类对象的非静态c&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inFun</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;NoStaticInner.inFun&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Outer.a = &quot;</span> + Outer.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">            System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">            System.out.println(<span class="string">&quot;Outer.c = &quot;</span> + Outer.<span class="built_in">this</span>.c);</span><br><span class="line">            System.out.println(<span class="string">&quot;c = &quot;</span> + c);</span><br><span class="line">            System.out.println(<span class="string">&quot;d = &quot;</span> + d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> NoStaticInner <span class="title function_">getNoStaticInner</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NoStaticInner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-2-局部内部类"><a href="#12-2-局部内部类" class="headerlink" title="12.2 局部内部类"></a>12.2 局部内部类</h2><h3 id="12-2-1-非匿名局部内部类"><a href="#12-2-1-非匿名局部内部类" class="headerlink" title="12.2.1 非匿名局部内部类"></a>12.2.1 非匿名局部内部类</h3><p>语法格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 外部类&#123;</span><br><span class="line">    [修饰符] 返回值类型  方法名(形参列表)&#123;</span><br><span class="line">            [<span class="keyword">final</span>/<span class="keyword">abstract</span>] class 内部类&#123;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译后有自己的独立的字节码文件，只不过在内部类名前面冠以外部类名、$符号、编号。<ul>
<li>这里有编号是因为同一个外部类中，不同的方法中存在相同名称的局部内部类</li>
</ul>
</li>
</ul>
<ul>
<li>和成员内部类不同的是，它前面不能有权限修饰符等</li>
<li>局部内部类如同局部变量一样，有作用域</li>
<li>局部内部类中是否能访问外部类的非静态的成员，取决于所在的方法</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName: TestLocalInner</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 尚硅谷-宋红康</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span> 17:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLocalInner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.outMethod();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        out.outTest();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Runner</span> <span class="variable">runner</span> <span class="operator">=</span> Outer.getRunner();</span><br><span class="line">        runner.run();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">outMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Outer.outMethod&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;局部变量c&quot;</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inMethod</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Inner.inMethod&quot;</span>);</span><br><span class="line">                System.out.println(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        in.inMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inMethod1</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Inner.inMethod1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        in.inMethod1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runner <span class="title function_">getRunner</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalRunner</span> <span class="keyword">implements</span> <span class="title class_">Runner</span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;LocalRunner.run&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LocalRunner</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Runner</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-2-2-匿名内部类"><a href="#12-2-2-匿名内部类" class="headerlink" title="12.2.2 匿名内部类"></a>12.2.2 匿名内部类</h3><p>因为考虑到这个子类或实现类是一次性的，那么我们“费尽心机”的给它取名字，就显得多余。那么我们完全可以使用匿名内部类的方式来实现，避免给类命名的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类([实参列表])&#123;</span><br><span class="line">    重写方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父接口()&#123;</span><br><span class="line">    重写方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例1：使用匿名内部类的对象直接调用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    	<span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例2：通过父类或父接口的变量多态引用匿名内部类的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    	<span class="type">A</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;;</span><br><span class="line">    	obj.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例3：匿名内部类的对象作为实参</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(A a)</span>&#123;</span><br><span class="line">    	a.method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    	test(<span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="13-枚举类（enum）"><a href="#13-枚举类（enum）" class="headerlink" title="13 枚举类（enum）"></a>13 枚举类（enum）</h1><h2 id="13-1-枚举的定义"><a href="#13-1-枚举的定义" class="headerlink" title="13.1 枚举的定义"></a>13.1 枚举的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="keyword">enum</span> 枚举类名&#123;</span><br><span class="line">    常量对象列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】 <span class="keyword">enum</span> 枚举类名&#123;</span><br><span class="line">    常量对象列表;</span><br><span class="line">    </span><br><span class="line">    对象的实例变量列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-2-enum方式定义的要求和特点"><a href="#13-2-enum方式定义的要求和特点" class="headerlink" title="13.2 enum方式定义的要求和特点"></a>13.2 enum方式定义的要求和特点</h2><ul>
<li>枚举类的常量对象列表必须在枚举类的首行，因为是常量，所以建议大写。</li>
<li>列出的实例系统会自动添加 public static final 修饰。</li>
<li>如果常量对象列表后面没有其他代码，那么“；”可以省略，否则不可以省略“；”。</li>
<li>编译器给枚举类默认提供的是private的无参构造，如果枚举类需要的是无参构造，就不需要声明，写常量对象列表时也不用加参数</li>
<li>如果枚举类需要的是有参构造，需要手动定义，有参构造的private可以省略，调用有参构造的方法就是在常量对象名后面加(实参列表)就可以。</li>
<li>枚举类默认继承的是java.lang.Enum类，因此不能再继承其他的类型。</li>
<li>switch提供支持枚举类型，case后面可以写枚举常量名，无需添加枚举类作为限定</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> &#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春风又绿江南岸&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;映日荷花别样红&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋水共长天一色&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;窗含西岭千秋雪&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SeasonEnum</span><span class="params">(String seasonName, String seasonDesc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Week</span> &#123;</span><br><span class="line">    MONDAY(<span class="string">&quot;星期一&quot;</span>),</span><br><span class="line">    TUESDAY(<span class="string">&quot;星期二&quot;</span>),</span><br><span class="line">    WEDNESDAY(<span class="string">&quot;星期三&quot;</span>),</span><br><span class="line">    THURSDAY(<span class="string">&quot;星期四&quot;</span>),</span><br><span class="line">    FRIDAY(<span class="string">&quot;星期五&quot;</span>),</span><br><span class="line">    SATURDAY(<span class="string">&quot;星期六&quot;</span>),</span><br><span class="line">    SUNDAY(<span class="string">&quot;星期日&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Week</span><span class="params">(String description)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString() +<span class="string">&quot;:&quot;</span>+ description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-3-enum中常用方法"><a href="#13-3-enum中常用方法" class="headerlink" title="13.3 enum中常用方法"></a>13.3 enum中常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">toString</span><span class="params">()</span>: 默认返回的是常量名（对象名），可以继续手动重写该方法！</span><br><span class="line"><span class="keyword">static</span> 枚举类型[] values():返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值，是一个静态方法</span><br><span class="line"><span class="keyword">static</span> 枚举类型 valueOf(String name)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。</span><br><span class="line">String <span class="title function_">name</span><span class="params">()</span>:得到当前枚举常量的名称。建议优先使用toString()。</span><br><span class="line"><span class="type">int</span> <span class="title function_">ordinal</span><span class="params">()</span>:返回当前枚举常量的次序号，默认从<span class="number">0</span>开始</span><br></pre></td></tr></table></figure>

<h2 id="13-4-实现接口的枚举类"><a href="#13-4-实现接口的枚举类" class="headerlink" title="13.4 实现接口的枚举类"></a>13.4 实现接口的枚举类</h2><ul>
<li>和普通 Java 类一样，枚举类可以实现一个或多个接口</li>
<li>若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。</li>
<li>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法</li>
</ul>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、枚举类可以像普通的类一样，实现接口，并且可以多个，但要求必须实现里面所有的抽象方法！</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">A</span> implements 接口<span class="number">1</span>，接口<span class="number">2</span>&#123;</span><br><span class="line">	<span class="comment">//抽象方法的实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、如果枚举类的常量可以继续重写抽象方法!</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">A</span> implements 接口<span class="number">1</span>，接口<span class="number">2</span>&#123;</span><br><span class="line">    常量名<span class="number">1</span>(参数)&#123;</span><br><span class="line">        <span class="comment">//抽象方法的实现或重写</span></span><br><span class="line">    &#125;,</span><br><span class="line">    常量名<span class="number">2</span>(参数)&#123;</span><br><span class="line">        <span class="comment">//抽象方法的实现或重写</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用enum关键字定义枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">	<span class="comment">//1. 创建枚举类中的对象,声明在enum枚举类的首位</span></span><br><span class="line">	SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;春天在哪里？&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;宁静的夏天&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;秋天是用来分手的季节&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;白雪皑皑&quot;</span>)&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;2002年的第一场雪&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2. 声明每个对象拥有的属性:private final修饰</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String SEASON_NAME;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String SEASON_DESC;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3. 私有化类的构造器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Season1</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.SEASON_NAME = seasonName;</span><br><span class="line">		<span class="built_in">this</span>.SEASON_DESC = seasonDesc;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getSEASON_NAME</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> SEASON_NAME;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getSEASON_DESC</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> SEASON_DESC;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="14-包装类"><a href="#14-包装类" class="headerlink" title="14 包装类"></a>14 包装类</h1><h2 id="14-1-有那些包装类"><a href="#14-1-有那些包装类" class="headerlink" title="14.1 有那些包装类"></a>14.1 有那些包装类</h2><p>Java针对八种基本数据类型定义了相应的引用类型：包装类（封装类）。有了类的特点，就可以调用类中的方法，Java才是真正的面向对象。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/20240703150011.png" alt="image.png"></p>
<p>封装以后的，内存结构对比：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">520</span>;</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">520</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/20240703150026.png" alt="image.png"></p>
<h2 id="14-2-包装类与基本数据类型间的转换"><a href="#14-2-包装类与基本数据类型间的转换" class="headerlink" title="14.2 包装类与基本数据类型间的转换"></a>14.2 包装类与基本数据类型间的转换</h2><h3 id="14-2-1-自动装箱与拆箱"><a href="#14-2-1-自动装箱与拆箱" class="headerlink" title="14.2.1 自动装箱与拆箱"></a>14.2.1 自动装箱与拆箱</h3><p>由于我们经常要做基本类型与包装类之间的转换，从<code>JDK5.0 </code>开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>;<span class="comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span></span><br><span class="line">i = i + <span class="number">5</span>;<span class="comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span></span><br><span class="line"><span class="comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：只能与自己对应的类型之间才能实现自动装箱与拆箱。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//错误的，1是int类型</span></span><br></pre></td></tr></table></figure>

<h3 id="14-2-2-基本数据类型、包装类与字符串间的转换"><a href="#14-2-2-基本数据类型、包装类与字符串间的转换" class="headerlink" title="14.2.2 基本数据类型、包装类与字符串间的转换"></a>14.2.2 基本数据类型、包装类与字符串间的转换</h3><p><strong>（1）基本数据类型转为字符串</strong></p>
<p><strong>方式1：</strong> 调用字符串重载的valueOf()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//String str = a;//错误的</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(a);</span><br></pre></td></tr></table></figure>

<p><strong>方式2：</strong> 更直接的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> a + <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>（2）字符串转为基本数据类型</strong></p>
<p><strong>方式1：</strong> 除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型，例如：</p>
<ul>
<li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li>
<li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li>
<li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li>
</ul>
<p><strong>方式2：</strong> 字符串转为包装类，然后可以自动拆箱为基本数据类型</p>
<ul>
<li><code>public static Integer valueOf(String s)</code>：将字符串参数转换为对应的Integer包装类，然后可以自动拆箱为int基本类型</li>
<li><code>public static Long valueOf(String s)</code>：将字符串参数转换为对应的Long包装类，然后可以自动拆箱为long基本类型</li>
<li><code>public static Double valueOf(String s)</code>：将字符串参数转换为对应的Double包装类，然后可以自动拆箱为double基本类型</li>
</ul>
<p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p>
<p><strong>方式3：</strong> 通过包装类的构造器实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;整数的字符串&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> Double.parseDouble(<span class="string">&quot;小数的字符串&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true或false&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;整数的字符串&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> Double.valueOf(<span class="string">&quot;小数的字符串&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.valueOf(<span class="string">&quot;true或false&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(“<span class="number">12</span>”);</span><br></pre></td></tr></table></figure>

<p><strong>其他方式小结：</strong><br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/20240703150319.png" alt="image.png"></p>
<h2 id="14-3-包装类的API"><a href="#14-3-包装类的API" class="headerlink" title="14.3 包装类的API"></a>14.3 包装类的API</h2><h3 id="14-3-1-数据类型的最大最小值"><a href="#14-3-1-数据类型的最大最小值" class="headerlink" title="14.3.1 数据类型的最大最小值"></a>14.3.1 数据类型的最大最小值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer.MAX_VALUE和Integer.MIN_VALUE</span><br><span class="line">Long.MAX_VALUE和Long.MIN_VALUE</span><br><span class="line">Double.MAX_VALUE和Double.MIN_VALUE</span><br></pre></td></tr></table></figure>

<h3 id="14-3-2-字符转大小写"><a href="#14-3-2-字符转大小写" class="headerlink" title="14.3.2 字符转大小写"></a>14.3.2 字符转大小写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Character.toUpperCase(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">Character.toLowerCase(<span class="string">&#x27;X&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="14-3-3-整数转进制"><a href="#14-3-3-整数转进制" class="headerlink" title="14.3.3 整数转进制"></a>14.3.3 整数转进制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer.toBinaryString(<span class="type">int</span> i)  </span><br><span class="line">Integer.toHexString(<span class="type">int</span> i)</span><br><span class="line">Integer.toOctalString(<span class="type">int</span> i)</span><br></pre></td></tr></table></figure>

<h3 id="14-3-4-比较的方法"><a href="#14-3-4-比较的方法" class="headerlink" title="14.3.4 比较的方法"></a>14.3.4 比较的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Double.compare(<span class="type">double</span> d1, <span class="type">double</span> d2)</span><br><span class="line">Integer.compare(<span class="type">int</span> x, <span class="type">int</span> y) </span><br></pre></td></tr></table></figure>

<h2 id="14-4-包装类对象的特点"><a href="#14-4-包装类对象的特点" class="headerlink" title="14.4 包装类对象的特点"></a>14.4 包装类对象的特点</h2><h3 id="14-4-1-包装类缓存对象"><a href="#14-4-1-包装类缓存对象" class="headerlink" title="14.4.1 包装类缓存对象"></a>14.4.1 包装类缓存对象</h3><table>
<thead>
<tr>
<th>包装类</th>
<th>缓存对象</th>
</tr>
</thead>
<tbody><tr>
<td>Byte</td>
<td>-128~127</td>
</tr>
<tr>
<td>Short</td>
<td>-128~127</td>
</tr>
<tr>
<td>Integer</td>
<td>-128~127</td>
</tr>
<tr>
<td>Long</td>
<td>-128~127</td>
</tr>
<tr>
<td>Float</td>
<td>没有</td>
</tr>
<tr>
<td>Double</td>
<td>没有</td>
</tr>
<tr>
<td>Character</td>
<td>0~127</td>
</tr>
<tr>
<td>Boolean</td>
<td>true和false</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(i == j); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>); <span class="comment">//新new的在堆中</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;              <span class="comment">//这个用的是缓冲的常量对象，在方法区</span></span><br><span class="line">System.out.println(m == n); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>); <span class="comment">//新new的在堆中</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>); <span class="comment">//另一个新new的在堆中</span></span><br><span class="line">System.out.println(x == y); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">System.out.println(d1==d2);<span class="comment">//false 比较地址，没有缓存对象，每一个都是新new的</span></span><br></pre></td></tr></table></figure>
<h3 id="14-4-2-类型转换问题"><a href="#14-4-2-类型转换问题" class="headerlink" title="14.4.2 类型转换问题"></a>14.4.2 类型转换问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">System.out.println(i==j);<span class="comment">//true  会先将i自动拆箱为int，然后根据基本数据类型“自动类型转换”规则，转为double比较</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">System.out.println(i==j);<span class="comment">//true 会自动拆箱，按照基本数据类型进行比较</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.0</span></span><br><span class="line">System.out.println(i==d);<span class="comment">//编译报错</span></span><br></pre></td></tr></table></figure>

<h3 id="14-4-3-包装类对象不可变"><a href="#14-4-3-包装类对象不可变" class="headerlink" title="14.4.3 包装类对象不可变"></a>14.4.3 包装类对象不可变</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestExam</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>);</span><br><span class="line">		<span class="type">Circle</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">		change(i, j, c);</span><br><span class="line">		System.out.println(<span class="string">&quot;i = &quot;</span> + i); <span class="comment">//1</span></span><br><span class="line">		System.out.println(<span class="string">&quot;j = &quot;</span> + j); <span class="comment">//2</span></span><br><span class="line">		System.out.println(<span class="string">&quot;c.radius = &quot;</span> + c.radius); <span class="comment">//10.0</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 方法的参数传递机制：</span></span><br><span class="line"><span class="comment">	 * （1）基本数据类型：形参的修改完全不影响实参</span></span><br><span class="line"><span class="comment">	 * （2）引用数据类型：通过形参修改对象的属性值，会影响实参的属性值</span></span><br><span class="line"><span class="comment">	 * 这类Integer等包装类对象是“不可变”对象，即一旦修改，就是新对象，和实参就无关了</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> a, Integer b, Circle c)</span> &#123;</span><br><span class="line">		a += <span class="number">10</span>;</span><br><span class="line"><span class="comment">//		b += 10;//等价于  b = new Integer(b+10);</span></span><br><span class="line">		c.radius += <span class="number">10</span>;</span><br><span class="line">		<span class="comment">/*c = new Circle();</span></span><br><span class="line"><span class="comment">		c.radius+=10;*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line">	<span class="type">double</span> radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="15-单例（Singleton）设计模式"><a href="#15-单例（Singleton）设计模式" class="headerlink" title="15 单例（Singleton）设计模式"></a>15 单例（Singleton）设计模式</h1><h2 id="15-1-什么是单例模式"><a href="#15-1-什么是单例模式" class="headerlink" title="15.1 什么是单例模式"></a>15.1 什么是单例模式</h2><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法。</p>
<p><strong>实现思路：</strong><br>首先必须将<code>类的构造器的访问权限设置为private</code>，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，<code>只能调用该类的某个静态方法</code>以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的<code>该类对象的变量也必须定义成静态的</code>。</p>
<h2 id="15-2-单例模式的两种实现方式"><a href="#15-2-单例模式的两种实现方式" class="headerlink" title="15.2 单例模式的两种实现方式"></a>15.2 单例模式的两种实现方式</h2><h3 id="15-2-1-饿汉式"><a href="#15-2-1-饿汉式" class="headerlink" title="15.2.1 饿汉式"></a>15.2.1 饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1.私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.内部提供一个当前类的实例</span></span><br><span class="line">    <span class="comment">// 4.此实例也必须静态化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">single</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-2-2-懒汉式"><a href="#15-2-2-懒汉式" class="headerlink" title="15.2.2 懒汉式"></a>15.2.2 懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1.私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.内部提供一个当前类的实例</span></span><br><span class="line">    <span class="comment">// 4.此实例也必须静态化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton single;</span><br><span class="line">    <span class="comment">// 3.提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(single == <span class="literal">null</span>) &#123;</span><br><span class="line">            single = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>存在多线程安全问题</p>
</blockquote>
<p><strong>使用同步机制：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.single.lazy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyOne</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyOne instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyOne</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式1：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazyOne <span class="title function_">getInstance1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方式2：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyOne <span class="title function_">getInstance2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(LazyOne.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方式3：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyOne <span class="title function_">getInstance3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyOne.class) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);<span class="comment">//加这个代码，暴露问题</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazyOne</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    注意：上述方式3中，有指令重排问题</span></span><br><span class="line"><span class="comment">    mem = allocate(); 为单例对象分配内存空间</span></span><br><span class="line"><span class="comment">    instance = mem;   instance引用现在非空，但还未初始化</span></span><br><span class="line"><span class="comment">    ctorSingleton(instance); 为单例对象通过instance调用构造器</span></span><br><span class="line"><span class="comment">    从JDK2开始，分配空间、初始化、调用构造器会在线程的工作存储区一次性完成，然后复制到主存储区。但是需要   </span></span><br><span class="line"><span class="comment">    volatile关键字，避免指令重排。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用内部类</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.single.lazy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingle</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingle <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">LazySingle</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LazySingle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>内部类只有在外部类被调用才加载，产生INSTANCE实例；又不用加锁。<br>此模式具有之前两个模式的优点，同时屏蔽了它们的缺点，是最好的单例模式。<br>此时的内部类，使用enum进行定义，也是可以的。</p>
<h3 id="15-2-3-饿汉式-vs-懒汉式"><a href="#15-2-3-饿汉式-vs-懒汉式" class="headerlink" title="15.2.3 饿汉式 vs 懒汉式"></a>15.2.3 饿汉式 vs 懒汉式</h3><p>饿汉式：</p>
<ul>
<li>特点：<code>立即加载</code>，即在使用类的时候已经将对象创建完毕。</li>
<li>优点：实现起来<code>简单</code>；没有多线程安全问题。</li>
<li>缺点：当类被加载的时候，会初始化static的实例，静态变量被创建并分配内存空间，从这以后，这个static的实例便一直占着这块内存，直到类被卸载时，静态变量被摧毁，并释放所占有的内存。因此在某些特定条件下会<code>耗费内存</code>。</li>
</ul>
<p>懒汉式：</p>
<ul>
<li>特点：<code>延迟加载</code>，即在调用静态方法时实例才被创建。</li>
<li>优点：实现起来比较简单；当类被加载的时候，static的实例未被创建并分配内存空间，当静态方法第一次被调用时，初始化实例变量，并分配内存，因此在某些特定条件下会<code>节约内存</code>。</li>
<li>缺点：在多线程环境中，这种实现方法是完全错误的，<code>线程不安全</code>，根本不能保证单例的唯一性。<ul>
<li>说明：在多线程章节，会将懒汉式改造成线程安全的模式。</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://baihlup.github.io">梦之痕</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://baihlup.github.io/2024/06/30/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/214%20-%20Java%20&amp;%20Lua/02%20-%20Java--%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">https://baihlup.github.io/2024/06/30/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/214%20-%20Java%20&amp;%20Lua/02%20-%20Java--%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/04/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/214%20-%20Java%20&amp;%20Lua/05%20-%20Java--%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/" title="Java--常用类和基础API"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">Java--常用类和基础API</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/30/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/214%20-%20Java%20&amp;%20Lua/03%20-%20Java--%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B&amp;%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="Java--并发编程&amp;网络编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">Java--并发编程&amp;网络编程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/12/22/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/214%20-%20Java%20&%20Lua/01%20-%20Java--%E5%9F%BA%E7%A1%80%E7%AF%87/" title="Java--基础篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-22</div><div class="title">Java--基础篇</div></div></a></div><div><a href="/2024/06/30/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/214%20-%20Java%20&%20Lua/03%20-%20Java--%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B&%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="Java--并发编程&amp;网络编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-30</div><div class="title">Java--并发编程&amp;网络编程</div></div></a></div><div><a href="/2024/06/30/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/214%20-%20Java%20&%20Lua/07%20-%20Java--%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" title="Java--反射机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-30</div><div class="title">Java--反射机制</div></div></a></div><div><a href="/2023/12/29/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/214%20-%20Java%20&%20Lua/04%20-%20Java--%E8%BF%9B%E9%98%B6%E7%AF%87/" title="Java--进阶篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-29</div><div class="title">Java--进阶篇</div></div></a></div><div><a href="/2024/07/04/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/214%20-%20Java%20&%20Lua/05%20-%20Java--%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/" title="Java--常用类和基础API"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-04</div><div class="title">Java--常用类和基础API</div></div></a></div><div><a href="/2024/07/07/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/214%20-%20Java%20&%20Lua/09%20-%20Java--File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/" title="Java--File类与IO流"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-07</div><div class="title">Java--File类与IO流</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">梦之痕</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">44</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/BaihlUp"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">个人笔记迁移中ing....</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">1 类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 类的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 匿名对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 引用类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 类对象和引用的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 对象的内存解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.5.1 JVM内存结构划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90"><span class="toc-number">1.5.2.</span> <span class="toc-text">1.5.2 对象内存解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.6.1 构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-2-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.2.</span> <span class="toc-text">1.6.2 静态变量和静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-3-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-number">1.6.3.</span> <span class="toc-text">1.6.3 方法调用内存分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-4-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">1.6.4.</span> <span class="toc-text">1.6.4 方法的重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-5-%E5%8F%AF%E5%8F%98%E4%B8%AA%E6%95%B0%E7%9A%84%E5%BD%A2%E5%8F%82"><span class="toc-number">1.6.5.</span> <span class="toc-text">1.6.5 可变个数的形参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-6-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-number">1.6.6.</span> <span class="toc-text">1.6.6 参数传递机制：值传递</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%8C%85%E5%92%8C%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">2.</span> <span class="toc-text">2 包和访问修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-package%EF%BC%88%E5%8C%85%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 package（包）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-import%EF%BC%88%E5%AF%BC%E5%85%A5%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 import（导入）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">2.3.</span> <span class="toc-text">2.2 访问修饰符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Athis"><span class="toc-number">3.</span> <span class="toc-text">3 关键字：this</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%88%96%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%BD%93%E5%89%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 实例方法或构造器中使用当前对象的成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%90%8C%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%E6%9E%84%E9%80%A0%E5%99%A8%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 同一个类中构造器互相调用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E7%BB%A7%E6%89%BF"><span class="toc-number">4.</span> <span class="toc-text">4 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 继承的语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 继承中的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E7%BB%A7%E6%89%BF%E6%80%A7%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 继承性的细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%EF%BC%88override-overwrite%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 方法的重写（override&#x2F;overwrite）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Asuper"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 关键字：super</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-%E5%AD%90%E7%B1%BB%E4%B8%AD%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E8%A2%AB%E9%87%8D%E5%86%99%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.5.1.</span> <span class="toc-text">4.5.1 子类中调用父类被重写的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-%E5%AD%90%E7%B1%BB%E4%B8%AD%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E4%B8%AD%E5%90%8C%E5%90%8D%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">4.5.2.</span> <span class="toc-text">4.5.2 子类中调用父类中同名的成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-3-%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%AD%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">4.5.3.</span> <span class="toc-text">4.5.3 子类构造器中调用父类构造器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E7%BB%A7%E6%89%BF%E9%87%8C%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">4.6.</span> <span class="toc-text">4. 6 继承里的静态方法：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E7%88%B6%E7%B1%BB%E5%92%8C%E5%AD%90%E7%B1%BB%E7%9A%84%E5%BC%95%E7%94%A8%E8%B5%8B%E5%80%BC%E5%85%B3%E7%B3%BB"><span class="toc-number">4.7.</span> <span class="toc-text">4.7 父类和子类的引用赋值关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">5.</span> <span class="toc-text">5 多态性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%A4%9A%E6%80%81%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%92%8C%E4%BD%93%E7%8E%B0"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 多态的形式和体现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84%E5%92%8C%E5%BC%8A%E7%AB%AF"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 多态的好处和弊端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E8%99%9A%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 虚方法调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-instanceof%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.4.</span> <span class="toc-text">5.5 instanceof操作符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Object%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">6 Object类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%A0%B9%E7%88%B6%E7%B1%BB"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 根父类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-Object%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 Object类中的方法：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-equals"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.2.1 equals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-hashCode"><span class="toc-number">6.2.2.</span> <span class="toc-text">6.2.2 hashCode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3-toString"><span class="toc-number">6.2.3.</span> <span class="toc-text">6.2.3 toString</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-4-finalize"><span class="toc-number">6.2.4.</span> <span class="toc-text">6.2.4 finalize()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-5-getClass"><span class="toc-number">6.2.5.</span> <span class="toc-text">6.2.5 getClass()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Astatic"><span class="toc-number">7.</span> <span class="toc-text">7 关键字：static</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-static-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 static 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 静态变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 静态方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">8.</span> <span class="toc-text">8 代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 静态代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E9%9D%9E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 非静态代码块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-final-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">9.</span> <span class="toc-text">9 final 修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-final%E4%BF%AE%E9%A5%B0%E7%B1%BB%EF%BC%9A%E4%B8%8D%E5%8F%AF%E8%A2%AB%E7%BB%A7%E6%89%BF"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 final修饰类：不可被继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-final%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95%EF%BC%9A%E4%B8%8D%E5%8F%AF%E8%A2%AB%E5%AD%90%E7%B1%BB%E8%A6%86%E7%9B%96"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 final修饰方法：不可被子类覆盖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-final-%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F"><span class="toc-number">9.3.</span> <span class="toc-text">9.3 final 修饰变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">10.</span> <span class="toc-text">10 抽象类与抽象方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">10.1.</span> <span class="toc-text">10.1 语法格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toc-number">10.2.</span> <span class="toc-text">10.2 使用说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">10.3.</span> <span class="toc-text">10.3 注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E6%8E%A5%E5%8F%A3%EF%BC%88interface%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">11 接口（interface）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A3%B0%E6%98%8E%E6%A0%BC%E5%BC%8F"><span class="toc-number">11.1.</span> <span class="toc-text">11.1 接口的声明格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">11.2.</span> <span class="toc-text">11.2 接口的使用规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-1-%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.2.1.</span> <span class="toc-text">11.2.1 类实现接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-2-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.2.2.</span> <span class="toc-text">11.2.2 接口的多实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-3-%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">11.2.3.</span> <span class="toc-text">11.2.3 接口的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-4-%E6%9C%89%E6%96%B9%E6%B3%95%E7%9A%84%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.2.4.</span> <span class="toc-text">11.2.4 有方法的代码的接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-5-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%9E%84%E6%88%90%E5%A4%9A%E6%80%81%E5%BC%95%E7%94%A8"><span class="toc-number">11.2.5.</span> <span class="toc-text">11.2.5 接口与实现类对象构成多态引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-6-%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">11.2.6.</span> <span class="toc-text">11.2.6 使用接口的静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-7-%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">11.2.7.</span> <span class="toc-text">11.2.7 使用接口的非静态方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">11.3.</span> <span class="toc-text">11.3 接口的几种使用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%AF%B9%E6%AF%94"><span class="toc-number">11.4.</span> <span class="toc-text">11.4 接口与抽象类对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88InnerClass%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">12 内部类（InnerClass）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">12.1.</span> <span class="toc-text">12.1 成员内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">12.1.1.</span> <span class="toc-text">12.1.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-2-%E5%88%9B%E5%BB%BA%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">12.1.2.</span> <span class="toc-text">12.1.2 创建成员内部类对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">12.2.</span> <span class="toc-text">12.2 局部内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-1-%E9%9D%9E%E5%8C%BF%E5%90%8D%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">12.2.1.</span> <span class="toc-text">12.2.1 非匿名局部内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-2-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">12.2.2.</span> <span class="toc-text">12.2.2 匿名内部类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%88enum%EF%BC%89"><span class="toc-number">13.</span> <span class="toc-text">13 枚举类（enum）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">13.1.</span> <span class="toc-text">13.1 枚举的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-enum%E6%96%B9%E5%BC%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A6%81%E6%B1%82%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">13.2.</span> <span class="toc-text">13.2 enum方式定义的要求和特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-enum%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">13.3.</span> <span class="toc-text">13.3 enum中常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-4-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">13.4.</span> <span class="toc-text">13.4 实现接口的枚举类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">14.</span> <span class="toc-text">14 包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-%E6%9C%89%E9%82%A3%E4%BA%9B%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">14.1.</span> <span class="toc-text">14.1 有那些包装类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">14.2.</span> <span class="toc-text">14.2 包装类与基本数据类型间的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-1-%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="toc-number">14.2.1.</span> <span class="toc-text">14.2.1 自动装箱与拆箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-2-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">14.2.2.</span> <span class="toc-text">14.2.2 基本数据类型、包装类与字符串间的转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3-%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84API"><span class="toc-number">14.3.</span> <span class="toc-text">14.3 包装类的API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">14.3.1.</span> <span class="toc-text">14.3.1 数据类型的最大最小值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-2-%E5%AD%97%E7%AC%A6%E8%BD%AC%E5%A4%A7%E5%B0%8F%E5%86%99"><span class="toc-number">14.3.2.</span> <span class="toc-text">14.3.2 字符转大小写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-3-%E6%95%B4%E6%95%B0%E8%BD%AC%E8%BF%9B%E5%88%B6"><span class="toc-number">14.3.3.</span> <span class="toc-text">14.3.3 整数转进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-4-%E6%AF%94%E8%BE%83%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">14.3.4.</span> <span class="toc-text">14.3.4 比较的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-4-%E5%8C%85%E8%A3%85%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">14.4.</span> <span class="toc-text">14.4 包装类对象的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-1-%E5%8C%85%E8%A3%85%E7%B1%BB%E7%BC%93%E5%AD%98%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.4.1.</span> <span class="toc-text">14.4.1 包装类缓存对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-2-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98"><span class="toc-number">14.4.2.</span> <span class="toc-text">14.4.2 类型转换问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-3-%E5%8C%85%E8%A3%85%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">14.4.3.</span> <span class="toc-text">14.4.3 包装类对象不可变</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E5%8D%95%E4%BE%8B%EF%BC%88Singleton%EF%BC%89%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">15.</span> <span class="toc-text">15 单例（Singleton）设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">15.1.</span> <span class="toc-text">15.1 什么是单例模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">15.2.</span> <span class="toc-text">15.2 单例模式的两种实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-1-%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-number">15.2.1.</span> <span class="toc-text">15.2.1 饿汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-2-%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">15.2.2.</span> <span class="toc-text">15.2.2 懒汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-3-%E9%A5%BF%E6%B1%89%E5%BC%8F-vs-%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">15.2.3.</span> <span class="toc-text">15.2.3 饿汉式 vs 懒汉式</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/260%20-%20%E5%90%8E%E7%AB%AF&amp;%E6%9E%B6%E6%9E%84/261%20-%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02%20-%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/" title="Untitled">Untitled</a><time datetime="2025-03-11T01:00:27.747Z" title="Created 2025-03-11 01:00:27">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/12/260%20-%20%E5%90%8E%E7%AB%AF&amp;%E6%9E%B6%E6%9E%84/263%20-%20%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/06%20-%20WASM%20%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/" title="06 - WASM 插件开发">06 - WASM 插件开发</a><time datetime="2025-02-12T00:00:00.000Z" title="Created 2025-02-12 00:00:00">2025-02-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/28/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/279%20-%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/02%20-%20%E8%AE%B0%E5%BD%95%E8%AE%BF%E9%97%AE%20HTTPS%20%E7%BD%91%E7%AB%99%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/" title="记录访问 HTTPS 网站报错问题">记录访问 HTTPS 网站报错问题</a><time datetime="2024-09-28T00:00:00.000Z" title="Created 2024-09-28 00:00:00">2024-09-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/29/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/279%20-%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/06%20-%20%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%94%A8%E5%8F%8C%E5%8D%81%E4%B8%80%E7%9A%84%E6%95%85%E4%BA%8B%E4%B8%B2%E8%B5%B7%E7%A2%8E%E7%89%87%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%AD%EF%BC%89/" title="Untitled">Untitled</a><time datetime="2024-08-29T08:17:15.548Z" title="Created 2024-08-29 08:17:15">2024-08-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/29/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/279%20-%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/05%20-%20%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%94%A8%E5%8F%8C%E5%8D%81%E4%B8%80%E7%9A%84%E6%95%85%E4%BA%8B%E4%B8%B2%E8%B5%B7%E7%A2%8E%E7%89%87%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8A%EF%BC%89/" title="Untitled">Untitled</a><time datetime="2024-08-29T08:17:15.544Z" title="Created 2024-08-29 08:17:15">2024-08-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 梦之痕</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>