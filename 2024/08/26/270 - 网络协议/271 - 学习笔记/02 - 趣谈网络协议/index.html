<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>趣谈网络协议 | 梦之痕</title><meta name="author" content="梦之痕"><meta name="copyright" content="梦之痕"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="0 参考资料知识图谱 代码地址：https:&#x2F;&#x2F;github.com&#x2F;popsuper1982&#x2F;tcpipillustrated 1 通信协议综述2 底层网络协议2.1 二层到三层2.1.1 物理层和MAC层同一个物理层之间可以使用Hub连接，也就是集线器。这种设备有多个口，可以将宿舍里的多台电脑连接起来。但是，和交换机不同，集线器没有大脑，它完全在物理层工作。它会将自己收到的每一个字节，都复制到">
<meta property="og:type" content="article">
<meta property="og:title" content="趣谈网络协议">
<meta property="og:url" content="https://baihlup.github.io/2024/08/26/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/271%20-%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02%20-%20%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/index.html">
<meta property="og:site_name" content="梦之痕">
<meta property="og:description" content="0 参考资料知识图谱 代码地址：https:&#x2F;&#x2F;github.com&#x2F;popsuper1982&#x2F;tcpipillustrated 1 通信协议综述2 底层网络协议2.1 二层到三层2.1.1 物理层和MAC层同一个物理层之间可以使用Hub连接，也就是集线器。这种设备有多个口，可以将宿舍里的多台电脑连接起来。但是，和交换机不同，集线器没有大脑，它完全在物理层工作。它会将自己收到的每一个字节，都复制到">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg">
<meta property="article:published_time" content="2024-08-26T00:00:00.000Z">
<meta property="article:modified_time" content="2024-10-11T03:19:20.267Z">
<meta property="article:author" content="梦之痕">
<meta property="article:tag" content="网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://baihlup.github.io/2024/08/26/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/271%20-%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02%20-%20%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '趣谈网络协议',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-11 03:19:20'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="梦之痕"><span class="site-name">梦之痕</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">趣谈网络协议</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-08-26T00:00:00.000Z" title="Created 2024-08-26 00:00:00">2024-08-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-10-11T03:19:20.267Z" title="Updated 2024-10-11 03:19:20">2024-10-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="趣谈网络协议"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="0-参考资料"><a href="#0-参考资料" class="headerlink" title="0 参考资料"></a>0 参考资料</h1><p><a target="_blank" rel="noopener" href="https://app.yinxiang.com/shard/s16/nl/19257560/4a675a7a-bbe6-4030-9bdf-32f678e57650">知识图谱</a></p>
<p>代码地址：<a target="_blank" rel="noopener" href="https://github.com/popsuper1982/tcpipillustrated">https://github.com/popsuper1982/tcpipillustrated</a></p>
<h1 id="1-通信协议综述"><a href="#1-通信协议综述" class="headerlink" title="1 通信协议综述"></a>1 通信协议综述</h1><h1 id="2-底层网络协议"><a href="#2-底层网络协议" class="headerlink" title="2 底层网络协议"></a>2 底层网络协议</h1><h2 id="2-1-二层到三层"><a href="#2-1-二层到三层" class="headerlink" title="2.1 二层到三层"></a>2.1 二层到三层</h2><h3 id="2-1-1-物理层和MAC层"><a href="#2-1-1-物理层和MAC层" class="headerlink" title="2.1.1 物理层和MAC层"></a>2.1.1 物理层和MAC层</h3><p>同一个物理层之间可以使用Hub连接，也就是集线器。这种设备有多个口，可以将宿舍里的多台电脑连接起来。但是，和交换机不同，集线器没有大脑，它完全在物理层工作。它会将自己收到的每一个字节，都复制到其他端口上去。这是第一层物理层联通的方案。</p>
<p>第二层，数据链路层，也即MAC层要解决的问题有，</p>
<ol>
<li>这个包是发给谁的？谁应该接收？大家都在发，会不会产生混乱？</li>
<li>有没有谁先发、谁后发的规则？</li>
<li>如果发送的时候出现了错误，怎么办？</li>
</ol>
<p>数据包应该发给谁，谁先发，谁后发，防止混乱等。学名叫多路访问。有很多算法可以解决这个问题。就像车管所管束马路上跑的车，能想的办法都想过了。</p>
<ul>
<li>方式一：分多个车道。每个车一个车道，你走你的，我走我的。这在计算机网络里叫作信道划分；</li>
<li>方式二：今天单号出行，明天双号出行，轮着来。这在计算机网络里叫作轮流协议；</li>
<li>方式三：不管三七二十一，有事儿先出门，发现特堵，就回去。错过高峰再出。我们叫作随机接入协议。著名的以太网，用的就是这个方式。</li>
</ul>
<p>发给谁，谁接收？这里用到一个物理地址，叫作链路层地址。但是因为第二层主要解决媒体接入控制的问题，所以它常被称为MAC地址。</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221013105120.png"></p>
<p>大部分的类型是IP数据包，然后IP里面包含TCP、UDP，以及HTTP等，这都是里层封装的事情。<br>有了这个目标MAC地址，数据包在链路上广播，MAC的网卡才能发现，这个包是给它的。MAC的网卡把包收进来，然后打开IP包，发现IP地址也是自己的，再打开TCP包，发现端口是自己，也就是80，而nginx就是监听80。</p>
<p>对于以太网，第二层的最后面是CRC，也就是循环冗余检测。通过XOR异或的算法，来计算整个包是否在发送的过程中出现了错误。</p>
<p>发送请求的时候知道了IP地址，但是还是不知道对方的MAC地址，这里需要ARP协议，通过IP地址，获取MAC地址。<br>发送一个广播包，谁是这个IP谁来回答。具体询问和回答的报文就像下面这样：</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221013105831.png"><br>为了避免每次都用ARP请求，机器本地也会进行ARP缓存。当然机器会不断地上线下线，IP也可能会变，所以ARP的MAC地址缓存过一段时间就会过期。</p>
<p>单纯使用HUB可以实现物理层多个设备的互通，但是如果设备过多，产生冲突的概率就提高了。而且把不需要的包转发过去，纯属浪费。这时候就需要更智能的设备交换机。<br>交换机通过学习，知道自己的每个口连接的设备的MAC地址。学习的过程如下：<br>一台MAC1电脑将一个包发送给另一台MAC2电脑，当这个包到达交换机的时候，一开始交换机也不知道MAC2的电脑在哪个口，所以没办法，它只能将包转发给除了来的那个口之外的其他所有的口。但是，这个时候，交换机会干一件非常聪明的事情，就是交换机会记住，MAC1是来自一个明确的口。以后有包的目的地址是MAC1的，直接发送到这个口就可以了。<br>当交换机作为一个关卡一样，过了一段时间之后，就有了整个网络的一个结构了，这个时候，基本上不用广播了，全部可以准确转发。当然，每个机器的IP地址会变，所在的口也会变，因而交换机上的学习的结果，我们称为转发表，是有一个过期时间的。</p>
<h3 id="2-1-2-交换机与VLAN"><a href="#2-1-2-交换机与VLAN" class="headerlink" title="2.1.2 交换机与VLAN"></a>2.1.2 交换机与VLAN</h3><p>跨不同交换机的MAC地址学习过程，如果机器1只知道机器4的IP地址，当它想要访问机器4，把包发出去的时候，它必须要知道机器4的MAC地址。</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/202408261127558.png"><br>于是机器1发起广播，机器2收到这个广播，但是这不是找它的，所以没它什么事。交换机A一开始是不知道任何拓扑信息的，在它收到这个广播后，采取的策略是，除了广播包来的方向外，它还要转发给其他所有的网口。于是机器3也收到广播信息了，但是这和它也没什么关系。</p>
<p>当然，交换机B也是能够收到广播信息的，但是这时候它也是不知道任何拓扑信息的，因而也是进行广播的策略，将包转发到局域网三。这个时候，机器4和机器5都收到了广播信息。机器4主动响应说，这是找我的，这是我的MAC地址。于是一个ARP请求就成功完成了。</p>
<p>在上面的过程中，交换机A和交换机B都是能够学习到这样的信息：机器1是在左边这个网口的。当了解到这些拓扑信息之后，情况就好转起来。当机器2要访问机器1的时候，机器2并不知道机器1的MAC地址，所以机器2会发起一个ARP请求。这个广播消息会到达机器1，也同时会到达交换机A。这个时候交换机A已经知道机器1是不可能在右边的网口的，所以这个广播信息就不会广播到局域网二和局域网三。</p>
<p>当机器3要访问机器1的时候，也需要发起一个广播的ARP请求。这个时候交换机A和交换机B都能够收到这个广播请求。交换机A当然知道主机A是在左边这个网口的，所以会把广播消息转发到局域网一。同时，交换机B收到这个广播消息之后，由于它知道机器1是不在右边这个网口的，所以不会将消息广播到局域网三。</p>
<ul>
<li>如何解决常见的环路问题</li>
</ul>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/202408261128886.png"><br>每个交换机都可以对局域网进行广播，如上交换机A和交换机B都可以在LAN1和LAN2进行广播，交换机A和交换机B会形成一个环状。</p>
<p>在数据结构中，有一个方法叫作最小生成树。有环的我们常称为图。将图中的环破了，就生成了树。在计算机网络中，生成树的算法叫作STP，全称Spanning Tree Protocol。</p>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/202408261128388.png"><br>在STP协议里面有很多概念，译名就非常拗口，但是我一作比喻，你很容易就明白了。</p>
<ol>
<li>Root Bridge，也就是根交换机。这个比较容易理解，可以比喻为“掌门”交换机，是某棵树的老大，是掌门，最大的大哥。</li>
<li>Designated Bridges，有的翻译为指定交换机。这个比较难理解，可以想像成一个“小弟”，对于树来说，就是一棵树的树枝。所谓“指定”的意思是，我拜谁做大哥，其他交换机通过这个交换机到达根交换机，也就相当于拜他做了大哥。这里注意是树枝，不是叶子，因为叶子往往是主机。</li>
<li>Bridge Protocol Data Units （BPDU） ，网桥协议数据单元。可以比喻为“相互比较实力”的协议。行走江湖，比的就是武功，拼的就是实力。当两个交换机碰见的时候，也就是相连的时候，就需要互相比一比内力了。BPDU只有掌门能发，已经隶属于某个掌门的交换机只能传达掌门的指示。</li>
<li>Priority Vector，优先级向量。可以比喻为实力 （值越小越牛）。实力是啥？就是一组ID数目，[Root Bridge ID, Root Path Cost, Bridge ID, and Port ID]。为什么这样设计呢？这是因为要看怎么来比实力。先看Root Bridge ID。拿出老大的ID看看，发现掌门一样，那就是师兄弟；再比Root Path Cost，也即我距离我的老大的距离，也就是拿和掌门关系比，看同一个门派内谁和老大关系铁；最后比Bridge ID，比我自己的ID，拿自己的本事比。</li>
</ol>
<p>交换机在基于STP工作时，不同交换机根据优先级高低分成的不同等级，最终形成一个树状，不再有环。</p>
<p>当设备很多时，交换机的广播也会很多，太多会导致网络拥塞，而且不同的设备属于不同的用户，比如设备A和设备B是公司人事部，设备1和设备2是公司研发部，人事部的网络数据不应该广播到研发部的设备上，要实现虚拟隔离，此时会用到VLAN，或者叫虚拟局域网。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/202408261128134.png"><br>在原来的二层的头上加一个TAG，里面有一个VLAN ID，一共12位。为什么是12位呢？因为12位可以划分4096个VLAN（对当前的云计算场景已经不够用）。<br>如果我们买的交换机是支持VLAN的，当这个交换机把二层的头取下来的时候，就能够识别这个VLAN ID。这样只有相同VLAN的包，才会互相转发，不同VLAN的包，是看不到的。这样广播问题和安全问题就都能够解决了。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/202408261129179.png"><br>我们可以设置交换机每个口所属的VLAN。如果某个口坐的是程序员，他们属于VLAN 10；如果某个口坐的是人事，他们属于VLAN 20；如果某个口坐的是财务，他们属于VLAN 30。这样，财务发的包，交换机只会转发到VLAN 30的口上。程序员啊，你就监听VLAN 10吧，里面除了代码，啥都没有。<br>对于支持VLAN的交换机，有一种口叫作Trunk口。它可以转发属于任何VLAN的口。交换机之间可以通过这种口相互连接。</p>
<h3 id="2-1-3-ICMP和ping"><a href="#2-1-3-ICMP和ping" class="headerlink" title="2.1.3 ICMP和ping"></a>2.1.3 ICMP和ping</h3><h2 id="2-2-传输层"><a href="#2-2-传输层" class="headerlink" title="2.2 传输层"></a>2.2 传输层</h2><h2 id="2-3-应用层"><a href="#2-3-应用层" class="headerlink" title="2.3 应用层"></a>2.3 应用层</h2><h2 id="2-4-DNS协议"><a href="#2-4-DNS协议" class="headerlink" title="2.4 DNS协议"></a>2.4 DNS协议</h2><ul>
<li>DNS的树状层级结构</li>
</ul>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/202408261131467.png"></p>
<ul>
<li>DNS协议格式</li>
</ul>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221013140933.png"></p>
<h3 id="2-4-1-DNS的解析流程"><a href="#2-4-1-DNS的解析流程" class="headerlink" title="2.4.1 DNS的解析流程"></a>2.4.1 DNS的解析流程</h3><p>为了提高DNS的解析性能，很多网络都会就近部署DNS缓存服务器。于是，就有了以下的DNS解析流程。</p>
<ol>
<li>电脑客户端会发出一个DNS请求，问<a target="_blank" rel="noopener" href="http://www.163.com的ip是啥啊,并发给本地域名服务器/">www.163.com的IP是啥啊，并发给本地域名服务器</a> (本地DNS)。那本地域名服务器 (本地DNS) 是什么呢？如果是通过DHCP配置，本地DNS由你的网络服务商（ISP），如电信、移动等自动分配，它通常就在你网络服务商的某个机房。</li>
<li>本地DNS收到来自客户端的请求。你可以想象这台服务器上缓存了一张域名与之对应IP地址的大表格。如果能找到 <a target="_blank" rel="noopener" href="http://www.163.com,它直接就返回ip地址.如果没有,本地dns会去问它的根域名服务器,根域名服务器是最高层次的,全球共有13套.它不直接用于域名解析,但能指明一条道路./">www.163.com，它直接就返回IP地址。如果没有，本地DNS会去问它的根域名服务器，根域名服务器是最高层次的，全球共有13套。它不直接用于域名解析，但能指明一条道路。</a></li>
<li>根DNS收到来自本地DNS的请求，发现后缀是 .com，说：“哦，<a target="_blank" rel="noopener" href="http://www.163.com啊,这个域名是由.com区域管理,我给你它的顶级域名服务器的地址,你去问问它吧.”/">www.163.com啊，这个域名是由.com区域管理，我给你它的顶级域名服务器的地址，你去问问它吧。”</a></li>
<li>本地DNS转向问顶级域名服务器，顶级域名服务器就是大名鼎鼎的比如 .com、.net、 .org这些一级域名，它负责管理二级域名，比如 163.com，所以它能提供一条更清晰的方向。</li>
<li>顶级域名服务器说：“我给你负责 <a target="_blank" rel="noopener" href="http://www.163.com/">www.163.com</a> 区域的权威DNS服务器的地址，你去问它应该能问到。”</li>
<li>本地DNS转向问权威DNS服务器：“您好，<a target="_blank" rel="noopener" href="http://www.163.com/">www.163.com</a> 对应的IP是啥呀？”163.com的权威DNS服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li>
<li>权限DNS服务器查询后将对应的IP地址X.X.X.X告诉本地DNS。</li>
<li>本地DNS再将IP地址返回客户端，客户端和目标建立连接。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/202408261146490.png"></p>
<h3 id="2-4-2-负载均衡"><a href="#2-4-2-负载均衡" class="headerlink" title="2.4.2 负载均衡"></a>2.4.2 负载均衡</h3><p>站在客户端角度，这是一次DNS递归查询过程。因为本地DNS全权为它效劳，它只要坐等结果即可。在这个过程中，DNS除了可以通过名称映射为IP地址，它还可以做另外一件事，就是负载均衡。</p>
<h3 id="2-4-3-内部负载均衡"><a href="#2-4-3-内部负载均衡" class="headerlink" title="2.4.3 内部负载均衡"></a>2.4.3 内部负载均衡</h3><p>例如，一个应用要访问数据库，在这个应用里面应该配置这个数据库的IP地址，还是应该配置这个数据库的域名呢？显然应该配置域名，因为一旦这个数据库，因为某种原因，换到了另外一台机器上，而如果有多个应用都配置了这台数据库的话，一换IP地址，就需要将这些应用全部修改一遍。但是如果配置了域名，则只要在DNS服务器里，将域名映射为新的IP地址，这个工作就完成了，大大简化了运维。</p>
<p>在这个基础上，我们可以再进一步。例如，某个应用要访问另外一个应用，如果配置另外一个应用的IP地址，那么这个访问就是一对一的。但是当被访问的应用撑不住的时候，我们其实可以部署多个。但是，访问它的应用，如何在多个之间进行负载均衡？只要配置成为域名就可以了。在域名解析的时候，我们只要配置策略，这次返回第一个IP，下次返回第二个IP，就可以实现负载均衡了。</p>
<h3 id="2-4-5-全局负载均衡"><a href="#2-4-5-全局负载均衡" class="headerlink" title="2.4.5 全局负载均衡"></a>2.4.5 全局负载均衡</h3><p>为了保证我们的应用高可用，往往会部署在多个机房，每个地方都会有自己的IP地址。当用户访问某个域名的时候，这个IP地址可以轮询访问多个数据中心。如果一个数据中心因为某种原因挂了，只要在DNS服务器里面，将这个数据中心对应的IP地址删除，就可以实现一定的高可用。<br>另外，我们肯定希望北京的用户访问北京的数据中心，上海的用户访问上海的数据中心，这样，客户体验就会非常好，访问速度就会超快。这就是全局负载均衡的概念。</p>
<h3 id="2-4-6-示例：DNS访问数据中心对象存储上的静态资源"><a href="#2-4-6-示例：DNS访问数据中心对象存储上的静态资源" class="headerlink" title="2.4.6 示例：DNS访问数据中心对象存储上的静态资源"></a>2.4.6 示例：DNS访问数据中心对象存储上的静态资源</h3><p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/202408261130283.png"></p>
<ol>
<li>当一个客户端要访问object.yourcompany.com的时候，需要将域名转换为IP地址进行访问，所以它要请求本地DNS解析器。</li>
<li>本地无缓存，再访问本地DNS服务器缓存，如果也没有，然后开始递归解析。</li>
<li>上图中的7，请求权威域名服务器，如果要做全局负载均衡（GSLB，Global Server Load Balance），此时会返回全局负载均衡器的CNAME，告诉DNS服务器让它请求这个GSLB解析这个域名，GSLB就可以通过解析这个域名的过程中，通过自己的策略实现负载均衡。</li>
</ol>
<p>图中画了两层的GSLB，是因为分运营商和地域。我们希望不同运营商的客户，可以访问相同运营商机房中的资源，这样不跨运营商访问，有利于提高吞吐量，减少时延。</p>
<ol>
<li>第一层GSLB，通过查看请求它的本地DNS服务器所在的运营商，就知道用户所在的运营商。假设是移动，通过CNAME的方式，通过另一个别名 object.yd.yourcompany.com，告诉本地DNS服务器去请求第二层的GSLB。</li>
<li>第二层GSLB，通过查看请求它的本地DNS服务器所在的地址，就知道用户所在的地理位置，然后将距离用户位置比较近的Region里面，六个内部负载均衡（SLB，Server Load Balancer）的地址，返回给本地DNS服务器。</li>
<li>本地DNS服务器将结果返回给本地DNS解析器。</li>
<li>本地DNS解析器将结果缓存后，返回给客户端。</li>
<li>客户端开始访问属于相同运营商的距离较近的Region 1中的对象存储，当然客户端得到了六个IP地址，它可以通过负载均衡的方式，随机或者轮询选择一个可用区进行访问。对象存储一般会有三个备份，从而可以实现对存储读写的负载均衡。</li>
</ol>
<h2 id="2-5-HTTPDNS"><a href="#2-5-HTTPDNS" class="headerlink" title="2.5 HTTPDNS"></a>2.5 HTTPDNS</h2><h3 id="2-5-1-传统DNS存在的问题"><a href="#2-5-1-传统DNS存在的问题" class="headerlink" title="2.5.1 传统DNS存在的问题"></a>2.5.1 传统DNS存在的问题</h3><p><strong>1. 域名缓存问题</strong></p>
<blockquote>
<p>缓存中的数据可能是旧的，无法实时更新，导致客户端访问错误。</p>
</blockquote>
<ol start="2">
<li>域名转发问题</li>
</ol>
<p>如果是A运营商的客户，访问自己运营商的DNS服务器，如果A运营商去权威DNS服务器查询的话，权威DNS服务器知道你是A运营商的，就返回给一个部署在A运营商的网站地址，这样针对相同运营商的访问，速度就会快很多。<br>但是A运营商偷懒，将解析的请求转发给B运营商，B运营商去权威DNS服务器查询的话，权威服务器会误认为，你是B运营商的，那就返回给你一个在B运营商的网站地址吧，结果客户的每次访问都要跨运营商，速度就会很慢。</p>
<ol start="3">
<li>出口NAT问题</li>
</ol>
<p>网络进行NAT后，无法正确识别运营商，因为IP变了，导致DNS服务器无法正确识别出运营商，也会造成访问慢的问题。</p>
<ol start="4">
<li>域名更新问题</li>
</ol>
<p>本地DNS服务器是由不同地区、不同运营商独立部署的。对域名解析缓存的处理上，实现策略也有区别，有的会偷懒，忽略域名解析结果的TTL时间限制，在权威DNS服务器解析变更的时候，解析结果在全网生效的周期非常漫长。但是有的时候，在DNS的切换中，场景对生效时间要求比较高。<br>例如双机房部署的时候，跨机房的负载均衡和容灾多使用DNS来做。当一个机房出问题之后，需要修改权威DNS，将域名指向新的IP地址，但是如果更新太慢，那很多用户都会出现访问异常。</p>
<ol start="5">
<li>解析延迟问题</li>
</ol>
<p>从DNS查询过程来看，DNS的查询过程需要递归遍历多个DNS服务器，才能获得最终的解析结果，这会带来一定的时延，甚至会解析超时。</p>
<h3 id="2-5-2-HTTPDNS的工作模式"><a href="#2-5-2-HTTPDNS的工作模式" class="headerlink" title="2.5.2 HTTPDNS的工作模式"></a>2.5.2 HTTPDNS的工作模式</h3><p><strong>HTTPNDS其实就是，不走传统的DNS解析，而是自己搭建基于HTTP协议的DNS服务器集群，分布在多个地点和多个运营商。当客户端需要DNS解析的时候，直接通过HTTP协议进行请求这个服务器集群，得到就近的地址。</strong><br>这就相当于每家基于HTTP协议，自己实现自己的域名解析，自己做一个自己的地址簿，而不使用统一的地址簿。但是默认的域名解析都是走DNS的，因而使用HTTPDNS需要绕过默认的DNS路径，就不能使用默认的客户端。使用HTTPDNS的，往往是手机应用，需要在手机端嵌入支持HTTPDNS的客户端SDK。</p>
<p>在客户端的SDK里动态请求服务端，获取HTTPDNS服务器的IP列表，缓存到本地。随着不断地解析域名，SDK也会在本地缓存DNS域名解析的结果。<br>当手机应用要访问一个地址的时候，首先看是否有本地的缓存，如果有就直接返回。这个缓存和本地DNS的缓存不一样的是，这个是手机应用自己做的，而非整个运营商统一做的。如何更新、何时更新，手机应用的客户端可以和服务器协调来做这件事情。<br>如果本地没有，就需要请求HTTPDNS的服务器，在本地HTTPDNS服务器的IP列表中，选择一个发出HTTP的请求，会返回一个要访问的网站的IP列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://106.2.xxx.xxx/d?dn=c.m.163.com</span><br><span class="line">&#123;&quot;dns&quot;:[&#123;&quot;host&quot;:&quot;c.m.163.com&quot;,&quot;ips&quot;:[&quot;223.252.199.12&quot;],&quot;ttl&quot;:300,&quot;http2&quot;:0&#125;],&quot;client&quot;:&#123;&quot;ip&quot;:&quot;106.2.81.50&quot;,&quot;line&quot;:269692944&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>手机客户端自然知道手机在哪个运营商、哪个地址。由于是直接的HTTP通信，HTTPDNS服务器能够准确知道这些信息，因而可以做精准的全局负载均衡。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/202408261129476.jpg"></p>
<h3 id="2-5-3-HTTPDNS的缓存设计"><a href="#2-5-3-HTTPDNS的缓存设计" class="headerlink" title="2.5.3 HTTPDNS的缓存设计"></a>2.5.3 HTTPDNS的缓存设计</h3><p>解析DNS过程复杂，通信次数多，对解析速度造成很大影响。为了加快解析，因而有了缓存，但是这又会产生缓存更新速度不及时的问题。最要命的是，这两个方面都掌握在别人手中，也即本地DNS服务器手中，它不会为你定制，你作为客户端干着急没办法。</p>
<p>而HTTPDNS就是将解析速度和更新速度全部掌控在自己手中。一方面，解析的过程，不需要本地DNS服务递归的调用一大圈，一个HTTP的请求直接搞定，要实时更新的时候，马上就能起作用；另一方面为了提高解析速度，本地也有缓存，缓存是在客户端SDK维护的，过期时间、更新时间，都可以自己控制。</p>
<p>HTTPDNS的缓存设计策略也是咱们做应用架构中常用的缓存设计模式，也即分为客户端、缓存、数据源三层。</p>
<ul>
<li>对于应用架构来讲，就是应用、缓存、数据库。常见的是Tomcat、Redis、MySQL。</li>
<li>对于HTTPDNS来讲，就是手机客户端、DNS缓存、HTTPDNS服务器。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/202408261130186.jpg"><br>SDK中的缓存会严格按照缓存过期时间，如果缓存没有命中，或者已经过期，而且客户端不允许使用过期的记录，则会发起一次解析，保障记录是更新的。</p>
<p>解析可以同步进行，也就是直接调用HTTPDNS的接口，返回最新的记录，更新缓存；也可以异步进行，添加一个解析任务到后台，由后台任务调用HTTPDNS的接口。</p>
<p>同步更新的优点是实时性好，缺点是如果有多个请求都发现过期的时候，同时会请求HTTPDNS多次，其实是一种浪费。</p>
<p>同步更新的方式对应到应用架构中缓存的Cache-Aside机制，也即先读缓存，不命中读数据库，同时将结果写入缓存。<br>异步更新的优点是，可以将多个请求都发现过期的情况，合并为一个对于HTTPDNS的请求任务，只执行一次，减少HTTPDNS的压力。同时可以在即将过期的时候，就创建一个任务进行预加载，防止过期之后再刷新，称为预加载。<br>它的缺点是当前请求拿到过期数据的时候，如果客户端允许使用过期数据，需要冒一次风险。如果过期的数据还能请求，就没问题；如果不能请求，则失败一次，等下次缓存更新后，再请求方能成功。</p>
<h3 id="2-5-4-HTTPDNS的调度设计"><a href="#2-5-4-HTTPDNS的调度设计" class="headerlink" title="2.5.4 HTTPDNS的调度设计"></a>2.5.4 HTTPDNS的调度设计</h3><p>由于客户端嵌入了SDK，因而就不会因为本地DNS的各种缓存、转发、NAT，让权威DNS服务器误会客户端所在的位置和运营商，而可以拿到第一手资料。</p>
<p>在客户端，可以知道手机是哪个国家、哪个运营商、哪个省，甚至哪个市，HTTPDNS服务端可以根据这些信息，选择最佳的服务节点返回。</p>
<p>如果有多个节点，还会考虑错误率、请求时间、服务器压力、网络状况等，进行综合选择，而非仅仅考虑地理位置。当有一个节点宕机或者性能下降的时候，可以尽快进行切换。</p>
<p>要做到这一点，需要客户端使用HTTPDNS返回的IP访问业务应用。客户端的SDK会收集网络请求数据，如错误率、请求时间等网络请求质量数据，并发送到统计后台，进行分析、聚合，以此查看不同的IP的服务质量。</p>
<p>在服务端，应用可以通过调用HTTPDNS的管理接口，配置不同服务质量的优先级、权重。HTTPDNS会根据这些策略综合地理位置和线路状况算出一个排序，优先访问当前那些优质的、时延低的IP地址。</p>
<p>HTTPDNS通过智能调度之后返回的结果，也会缓存在客户端。为了不让缓存使得调度失真，客户端可以根据不同的移动网络运营商WIFI的SSID来分维度缓存。不同的运营商或者WIFI解析出来的结果会不同。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/202408261132202.jpg"></p>
<h2 id="2-6-CDN"><a href="#2-6-CDN" class="headerlink" title="2.6 CDN"></a>2.6 CDN</h2><h3 id="2-6-1-CDN的分发系统的架构"><a href="#2-6-1-CDN的分发系统的架构" class="headerlink" title="2.6.1 CDN的分发系统的架构"></a>2.6.1 CDN的分发系统的架构</h3><p>为了提升用户访问速度，会在各个地方的数据中心部署几台机器，形成一个缓存的集群，用户访问数据的时候，就近访问。<br>部署在各个地方的数据中心节点，就称为边缘节点。<br>由于边缘节点数目比较多，但是每个集群规模比较小，不可能缓存下来所有东西，因而可能无法命中，这样就会在边缘节点之上。有区域节点，规模就要更大，缓存的数据会更多，命中的概率也就更大。在区域节点之上是中心节点，规模更大，缓存数据更多。如果还不命中，就只好回源网站访问了。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/202408261132599.jpg"><br>这就是CDN的分发系统的架构。CDN系统的缓存，也是一层一层的，能不访问后端真正的源，就不打扰它。</p>
<h3 id="2-6-2-客户端如何找到相应的边缘节点进行访问呢？"><a href="#2-6-2-客户端如何找到相应的边缘节点进行访问呢？" class="headerlink" title="2.6.2 客户端如何找到相应的边缘节点进行访问呢？"></a>2.6.2 客户端如何找到相应的边缘节点进行访问呢？</h3><p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/202408261147136.jpg"></p>
<ol>
<li><p>在没有CDN的情况下，用户向浏览器输入<a target="_blank" rel="noopener" href="http://www.web.com这个域名,客户端访问本地dns服务器的时候,如果本地dns服务器有缓存,则返回网站的地址;如果没有,递归查询到网站的权威dns服务器,这个权威dns服务器是负责web.com的,它会返回网站的ip地址.本地dns服务器缓存下ip地址,将ip地址返回,然后客户端直接访问这个ip地址,就访问到了这个网站./">www.web.com这个域名，客户端访问本地DNS服务器的时候，如果本地DNS服务器有缓存，则返回网站的地址；如果没有，递归查询到网站的权威DNS服务器，这个权威DNS服务器是负责web.com的，它会返回网站的IP地址。本地DNS服务器缓存下IP地址，将IP地址返回，然后客户端直接访问这个IP地址，就访问到了这个网站。</a></p>
</li>
<li><p>有了CDN之后，情况发生了变化。在web.com这个权威DNS服务器上，会设置一个CNAME别名，指向另外一个域名 <a target="_blank" rel="noopener" href="http://www.web.cdn.com,返回给本地dns服务器./">www.web.cdn.com，返回给本地DNS服务器。</a></p>
</li>
<li><p>当本地DNS服务器拿到这个新的域名时，需要继续解析这个新的域名。这个时候，再访问的就不是web.com的权威DNS服务器了，而是web.cdn.com的权威DNS服务器，这是CDN自己的权威DNS服务器。在这个服务器上，还是会设置一个CNAME，指向另外一个域名，也即CDN网络的全局负载均衡器。</p>
</li>
<li><p>接下来，本地DNS服务器去请求CDN的全局负载均衡器解析域名，全局负载均衡器会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：</p>
<ol>
<li>根据用户IP地址，判断哪一台服务器距用户最近；</li>
<li>用户所处的运营商；</li>
<li>根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需的内容；</li>
<li>查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。</li>
</ol>
</li>
<li><p>基于以上这些条件，进行综合分析之后，全局负载均衡器会返回一台缓存服务器的IP地址。</p>
</li>
<li><p>本地DNS服务器缓存这个IP地址，然后将IP返回给客户端，客户端去访问这个边缘节点，下载资源。缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</p>
</li>
</ol>
<h3 id="2-6-3-CDN可以进行缓存的内容"><a href="#2-6-3-CDN可以进行缓存的内容" class="headerlink" title="2.6.3 CDN可以进行缓存的内容"></a>2.6.3 CDN可以进行缓存的内容</h3><p>静态页面、图片等，因为这些东西也不怎么变，所以适合缓存。</p>
<p>我们希望通过最外层接入层的缓存，将大部分静态资源的访问拦在边缘。而CDN则更进一步，将这些静态资源缓存到离用户更近的数据中心外。越接近客户，访问性能越好，时延越低。<br>CDN支持流媒体协议，例如前面讲过的RTMP协议。在很多情况下，这相当于一个代理，从上一级缓存读取内容，转发给用户。由于流媒体往往是连续的，因而可以进行预先缓存的策略，也可以预先推送到用户的客户端。<br>对于静态页面来讲，内容的分发往往采取拉取的方式，也即当发现未命中的时候，再去上一级进行拉取。但是，流媒体数据量大，如果出现回源，压力会比较大，所以往往采取主动推送的模式，将热点数据主动推送到边缘节点。</p>
<p>对于流媒体来讲，很多CDN还提供预处理服务，也即文件在分发之前，经过一定的处理。例如将视频转换为不同的码流，以适应不同的网络带宽的用户需求；再如对视频进行分片，降低存储压力，也使得客户端可以选择使用不同的码率加载不同的分片。这就是我们常见的，“我要看超清、标清、流畅等”。</p>
<h3 id="2-6-4-防盗链"><a href="#2-6-4-防盗链" class="headerlink" title="2.6.4 防盗链"></a>2.6.4 防盗链</h3><p>对于流媒体CDN来讲，有个关键的问题是防盗链问题。因为视频是要花大价钱买版权的，为了挣点钱，收点广告费，如果流媒体被其他的网站盗走，在人家的网站播放，那损失可就大了。</p>
<p>最常用也最简单的方法就是HTTP头的refer字段， 当浏览器发送请求的时候，一般会带上referer，告诉服务器是从哪个页面链接过来的，服务器基于此可以获得一些信息用于处理。如果refer信息不是来自本站，就阻止访问或者跳到其它链接。</p>
<p><strong>refer的机制相对比较容易破解，所以还需要配合其他的机制。</strong><br>一种常用的机制是时间戳防盗链。使用CDN的管理员可以在配置界面上，和CDN厂商约定一个加密字符串。</p>
<p>客户端取出当前的时间戳，要访问的资源及其路径，连同加密字符串进行签名算法得到一个字符串，然后生成一个下载链接，带上这个签名字符串和截止时间戳去访问CDN。</p>
<p>在CDN服务端，根据取出过期时间，和当前 CDN 节点时间进行比较，确认请求是否过期。然后CDN服务端有了资源及路径，时间戳，以及约定的加密字符串，根据相同的签名算法计算签名，如果匹配则一致，访问合法，才会将资源返回给客户。</p>
<h3 id="2-6-5-动态CDN"><a href="#2-6-5-动态CDN" class="headerlink" title="2.6.5 动态CDN"></a>2.6.5 动态CDN</h3><p>动态的数据，比较难以缓存。怎么办呢？现在也有动态CDN，主要有两种模式。</p>
<ul>
<li><p>一种为生鲜超市模式，也即边缘计算的模式。既然数据是动态生成的，所以数据的逻辑计算和存储，也相应的放在边缘的节点。其中定时从源数据那里同步存储的数据，然后在边缘进行计算得到结果。就像对生鲜的烹饪是动态的，没办法事先做好缓存，因而将生鲜超市放在你家旁边，既能够送货上门，也能够现场烹饪，也是边缘计算的一种体现。</p>
</li>
<li><p>另一种是冷链运输模式，也即路径优化的模式。数据不是在边缘计算生成的，而是在源站生成的，但是数据的下发则可以通过CDN的网络，对路径进行优化。因为CDN节点较多，能够找到离源站很近的边缘节点，也能找到离用户很近的边缘节点。中间的链路完全由CDN来规划，选择一个更加可靠的路径，使用类似专线的方式进行访问。</p>
</li>
</ul>
<p>对于常用的TCP连接，在公网上传输的时候经常会丢数据，导致TCP的窗口始终很小，发送速度上不去。根据前面的TCP流量控制和拥塞控制的原理，在CDN加速网络中可以调整TCP的参数，使得TCP可以更加激进地传输数据。</p>
<p>可以通过多个请求复用一个连接，保证每次动态请求到达时。连接都已经建立了，不必临时三次握手或者建立过多的连接，增加服务器的压力。另外，可以通过对传输数据进行压缩，增加传输效率。</p>
<h2 id="2-7-数据中心"><a href="#2-7-数据中心" class="headerlink" title="2.7 数据中心"></a>2.7 数据中心</h2><h3 id="2-7-1"><a href="#2-7-1" class="headerlink" title="2.7.1"></a>2.7.1</h3><h2 id="2-8-VPN"><a href="#2-8-VPN" class="headerlink" title="2.8 VPN"></a>2.8 VPN</h2><p>VPN，全名Virtual Private Network，虚拟专用网，就是利用开放的公众网络，建立专用数据传输通道，将远程的分支机构、移动办公人员等连接起来。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/202306071649041.png"></p>
<h3 id="2-8-1-IPsec"><a href="#2-8-1-IPsec" class="headerlink" title="2.8.1 IPsec"></a>2.8.1 IPsec</h3><p><strong>以IPsec协议为例</strong>：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/202306071649080.png"></p>
<p>IPsec具备私密性、完整性、真实性，组成IPsec VPN协议簇如下：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/202306071652759.png"></p>
<p>在这个协议簇里面，有两种协议，这两种协议的区别在于封装网络包的格式不一样：</p>
<ul>
<li>一种协议称为AH（Authentication Header），只能进行数据摘要 ，不能实现数据加密。</li>
<li>还有一种ESP（Encapsulating Security Payload），能够进行数据加密和数据摘要。</li>
</ul>
<p>这个协议簇中有两类算法：加密算法和摘要算法。<br>两大组件：一个用于VPN的双方要进行对称密钥的交换的IKE组件，另一个是VPN的双方要对连接进行维护的SA（Security Association）组件。</p>
<p><strong>IPsec VPN的建立过程：</strong></p>
<ul>
<li>第一个阶段，建立IKE自己的SA。</li>
</ul>
<p>在这个阶段，通过DH（Diffie-Hellman）算法计算出一个对称密钥K。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/202306071654668.png"></p>
<ul>
<li>第二个阶段，建立IPsec SA</li>
</ul>
<p>IPsec SA里面有以下内容：</p>
<ul>
<li>SPI（Security Parameter Index），用于标识不同的连接；</li>
<li>双方商量好的加密算法、哈希算法和封装模式；</li>
<li>生存周期，超过这个周期，就需要重新生成一个IPsec SA，重新生成对称密钥。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/202306071701530.png"><br>当IPsec建立好，接下来就可以开始打包封装传输了。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/202306071702590.png"><br>左面是原始的IP包，在IP头里面，会指定上一层的协议为TCP。ESP要对IP包进行封装，因而IP头里面的上一层协议为ESP。在ESP的正文里面，ESP的头部有双方商讨好的SPI，以及这次传输的序列号。</p>
<p>接下来全部是加密的内容。可以通过对称密钥进行解密，解密后在正文的最后，指明了里面的协议是什么。如果是IP，则需要先解析IP头，然后解析TCP头，这是从隧道出来后解封装的过程。</p>
<p>有了IPsec VPN之后，客户端发送的明文的IP包，都会被加上ESP头和IP头，在公网上传输，由于加密，可以保证不被窃取，到了对端后，去掉ESP的头，进行解密。</p>
<p>这种点对点的基于IP的VPN，能满足互通的要求，但是速度往往比较慢，这是由底层IP协议的特性决定的。IP不是面向连接的，是尽力而为的协议，每个IP包自由选择路径，到每一个路由器，都自己去找下一跳，丢了就丢了，是靠上一层TCP的重发来保证可靠性。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/202306071703457.png"></p>
<h3 id="2-8-2-MPLS"><a href="#2-8-2-MPLS" class="headerlink" title="2.8.2 MPLS"></a>2.8.2 MPLS</h3><p>多协议标签交换（MPLS，Multi-Protocol Label Switching）。MPLS的格式如图所示，在原始的IP头之外，多了MPLS的头，里面可以打标签。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/202306071704826.png"><br>在二层头里面，有类型字段，0x0800表示IP，0x8847表示MPLS Label。</p>
<p>在MPLS头里面，首先是标签值占20位，接着是3位实验位，再接下来是1位栈底标志位，表示当前标签是否位于栈底了。这样就允许多个标签被编码到同一个数据包中，形成标签栈。最后是8位TTL存活时间字段，如果标签数据包的出发TTL值为0，那么该数据包在网络中的生命期被认为已经过期了。</p>
<p>有了标签，还需要设备认这个标签，并且能够根据这个标签转发，这种能够转发标签的路由器称为标签交换路由器（LSR，Label Switching Router）。</p>
<p>这种路由器会有两个表格，一个就是传统的FIB，也即路由表，另一个就是LFIB，标签转发表。有了这两个表，既可以进行普通的路由转发，也可以进行基于标签的转发。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/202306071705905.png"><br>有了标签转发表，转发的过程如图所示，就不用每次都进行普通路由的查找了。</p>
<p>在MPLS区域中间，使用标签进行转发，非MPLS区域，使用普通路由转发，在边缘节点上，需要有能力将对于普通路由的转发，变成对于标签的转发。</p>
<p>通过标签转换而建立的路径称为LSP，标签交换路径。在一条LSP上，沿数据包传送的方向，相邻的LSR分别叫上游LSR（upstream LSR）和下游LSR（downstream LSR）。</p>
<p>这样一个通过标签转换而建立的路径称为LSP，标签交换路径。在一条LSP上，沿数据包传送的方向，相邻的LSR分别叫上游LSR（upstream LSR）和下游LSR（downstream LSR）。<br>使用LDP（Label Distribution Protocol），一个动态的生成标签协议。</p>
<p>其实LDP与IP帮派中的路由协议十分相像，通过LSR的交互，互相告知去哪里应该打哪个标签，称为标签分发，往往是从下游开始的。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/202306071822261.png"><br>如果有一个边缘节点发现自己的路由表中出现了新的目的地址，它就要给别人说，我能到达一条新的路径了。</p>
<p>如果此边缘节点存在上游LSR，并且尚有可供分配的标签，则该节点为新的路径分配标签，并向上游发出标签映射消息，其中包含分配的标签等信息。</p>
<p>收到标签映射消息的LSR记录相应的标签映射信息，在其标签转发表中增加相应的条目。此LSR为它的上游LSR分配标签，并继续向上游LSR发送标签映射消息。</p>
<p>当入口LSR收到标签映射消息时，在标签转发表中增加相应的条目。这时，就完成了LSP的建立。有了标签，转发轻松多了，但是这个和VPN什么关系呢？</p>
<p>可以想象，如果我们VPN通道里面包的转发，都是通过标签的方式进行，效率就会高很多。所以要想个办法把MPLS应用于VPN。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/202306071824487.png"><br>在MPLS VPN中，网络中的路由器分成以下几类：</p>
<ul>
<li>PE（Provider Edge）：运营商网络与客户网络相连的边缘网络设备；</li>
<li>CE（Customer Edge）：客户网络与PE相连接的边缘设备；</li>
<li>P（Provider）：这里特指运营商网络中除PE之外的其他运营商网络设备。</li>
</ul>
<p><strong>VPN报文转发采用两层标签方式：</strong></p>
<ul>
<li>第一层（外层）标签在骨干网内部进行交换，指示从PE到对端PE的一条LSP。VPN报文利用这层标签，可以沿LSP到达对端PE；</li>
<li>第二层（内层）标签在从对端PE到达CE时使用，在PE上，通过查找VRF表项，指示报文应被送到哪个VPN用户，或者更具体一些，到达哪一个CE。这样，对端PE根据内层标签可以找到转发报文的接口。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/202306071826622.png"></p>
<p>举一个例子，看MPLS VPN的包发送过程。</p>
<ol>
<li>机构A和机构B都发出一个目的地址为192.168.101.0&#x2F;24的IP报文，分别由各自的CE将报文发送至PE。</li>
<li>PE会根据报文到达的接口及目的地址查找VPN实例表项VRF，匹配后将报文转发出去，同时打上内层和外层两个标签。假设通过MP-BGP配置的路由，两个报文在骨干网走相同的路径。</li>
<li>MPLS网络利用报文的外层标签，将报文传送到出口PE，报文在到达出口PE 2前一跳时已经被剥离外层标签，仅含内层标签。</li>
<li>出口PE根据内层标签和目的地址查找VPN实例表项VRF，确定报文的出接口，将报文转发至各自的CE。</li>
<li>CE根据正常的IP转发过程将报文传送到目的地。</li>
</ol>
<h1 id="3-云计算中的网络"><a href="#3-云计算中的网络" class="headerlink" title="3 云计算中的网络"></a>3 云计算中的网络</h1><h2 id="3-1-云中网络"><a href="#3-1-云中网络" class="headerlink" title="3.1 云中网络"></a>3.1 云中网络</h2><p>云计算的关键技术是虚拟化，虚拟机是物理机上跑着的一个软件。这个软件可以像其他应用打开文件一样，打开一个称为TUN&#x2F;TAP的Char Dev（字符设备文件）。打开了这个字符设备文件之后，在物理机上就能看到一张虚拟TAP网卡。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221006161059.png"><br>云计算中的网络都需要注意哪些点:</p>
<ol>
<li>共享：尽管每个虚拟机都会有一个或者多个虚拟网卡，但是物理机上可能只有有限的网卡。那这么多虚拟网卡如何共享同一个出口？</li>
<li>隔离：分两个方面，一个是安全隔离，两个虚拟机可能属于两个用户，那怎么保证一个用户的数据不被另一个用户窃听？一个是流量隔离，两个虚拟机，如果有一个疯狂下片，会不会导致另外一个上不了网？</li>
<li>互通：分两个方面，一个是如果同一台机器上的两个虚拟机，属于同一个用户的话，这两个如何相互通信？另一个是如果不同物理机上的两个虚拟机，属于同一个用户的话，这两个如何相互通信？</li>
<li>灵活：虚拟机和物理不同，会经常创建、删除，从一个机器漂移到另一台机器，有的互通、有的不通等等，灵活性比物理网络要好得多，需要能够灵活配置。<blockquote>
<p>云中的网络重点关注四个方面，共享、隔离、互通、灵活。其中共享和互通有两种常用的方式，分别是桥接和NAT，隔离可以通过VLAN的方式。<br>命令vconfig，可以基于物理网卡eth0创建带VLAN的虚拟网卡，所有从这个虚拟网卡出去的包，都带这个VLAN，如果这样，跨物理机的互通和隔离就可以通过这个网卡来实现。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221006161321.png"></p>
</blockquote>
</li>
</ol>
<h2 id="3-2-软件定义网络"><a href="#3-2-软件定义网络" class="headerlink" title="3.2 软件定义网络"></a>3.2 软件定义网络</h2><h3 id="3-2-1-软件定义网络（SDN）"><a href="#3-2-1-软件定义网络（SDN）" class="headerlink" title="3.2.1 软件定义网络（SDN）"></a>3.2.1 软件定义网络（SDN）</h3><p>软件定义网络（SDN）。它主要有以下三个特点：</p>
<ol>
<li>控制与转发分离：转发平面就是一个个虚拟或者物理的网络设备，就像小区里面的一条条路。控制平面就是统一的控制中心，就像小区物业的监控室。它们原来是一起的，物业管理员要从监控室出来，到路上去管理设备，现在是分离的，路就是走人的，控制都在监控室。</li>
<li>控制平面与转发平面之间的开放接口：控制器向上提供接口，被应用层调用，就像总控室提供按钮，让物业管理员使用。控制器向下调用接口，来控制网络设备，就像总控室会远程控制电梯的速度。这里经常使用两个名词，前面这个接口称为北向接口，后面这个接口称为南向接口，上北下南嘛。</li>
<li>逻辑上的集中控制：逻辑上集中的控制平面可以控制多个转发面设备，也就是控制整个物理网络，因而可以获得全局的网络状态视图，并根据该全局网络状态视图实现对网络的优化控制，就像物业管理员在监控室能够看到整个小区的情况，并根据情况优化出入方案。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221006170205.png"></li>
</ol>
<h3 id="3-2-2-OpenFlow和OpenvSwitch"><a href="#3-2-2-OpenFlow和OpenvSwitch" class="headerlink" title="3.2.2 OpenFlow和OpenvSwitch"></a>3.2.2 OpenFlow和OpenvSwitch</h3><p>OpenFlow是SDN控制器和网络设备之间互通的南向接口协议，OpenvSwitch用于创建软件的虚拟交换机。OpenvSwitch是支持OpenFlow协议的，当然也有一些硬件交换机也支持OpenFlow协议。它们都可以被统一的SDN控制器管理，从而实现物理机和虚拟机的网络连通。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221006170354.png"></p>
<ul>
<li>SDN控制器是如何通过OpenFlow协议控制网络的呢？<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221006170503.png"><br>在OpenvSwitch里面，有一个流表规则，任何通过这个交换机的包，都会经过这些规则进行处理，从而接收、转发、放弃。<br>流表如下图所示：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221006170534.png"><br>流表就是一个个表格，每个表格好多行，每行都是一条规则。每条规则都有优先级，先看高优先级的规则，再看低优先级的规则。<br>对于每一条规则，要看是否满足匹配条件。这些条件包括，从哪个端口进来的，网络包头里面有什么等等。满足了条件的网络包，就要执行一个动作，对这个网络包进行处理。可以修改包头里的内容，可以跳到任何一个表格，可以转发到某个网口出去，也可以丢弃。<br>通过这些表格，可以对收到的网络包随意处理。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221006170700.png"><br>通过上图可以看到，处理方式有很多种，可以覆盖TCP&#x2F;IP协议栈的四层。</li>
<li>物理层<br>匹配规则包括由从哪个口进来；<br>执行动作包括从哪个口出去。</li>
<li>MAC层<br>匹配规则包括：源MAC地址是多少？（dl_src），目标MAC是多少？（dl_dst），所属vlan是多少？（dl_vlan）；<br>执行动作包括：修改源MAC（mod_dl_src），修改目标MAC（mod_dl_dst），修改VLAN（mod_vlan_vid），删除VLAN（strip_vlan），MAC地址学习（learn）。</li>
<li>网络层<br>匹配规则包括：源IP地址是多少？(nw_src)，目标IP是多少？（nw_dst）。<br>执行动作包括：修改源IP地址（mod_nw_src），修改目标IP地址（mod_nw_dst）。</li>
<li>传输层<br>匹配规则包括：源端口是多少？（tp_src），目标端口是多少？（tp_dst）。<br>执行动作包括：修改源端口（mod_tp_src），修改目标端口（mod_tp_dst）。<br>OpenvSwitch有本地的命令行可以进行配置，能够实验咱们前面讲过的一些功能。我们可以通过OpenvSwitch的命令创建一个虚拟交换机。然后可以将多个虚拟端口port添加到这个虚拟交换机上。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ovs-vsctl add-br ubuntu_br</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-3-云中的网络安全"><a href="#3-3-云中的网络安全" class="headerlink" title="3.3 云中的网络安全"></a>3.3 云中的网络安全</h2><p>对于公有云上的虚拟机，我的建议是仅仅开放需要的端口，而将其他的端口一概关闭。这个时候，你只要通过安全措施守护好这个唯一的入口就可以了。采用的方式常常是用ACL（Access Control List，访问控制列表）来控制IP和端口。<br>设置好了这些规则，只有指定的IP段能够访问指定的开放接口，就算有个有漏洞的后台进程在那里，也会被屏蔽，黑客进不来。在云平台上，这些规则的集合常称为安全组。<br>当一个网络包进入一台机器的时候，首先拿下MAC头看看，是不是我的。如果是，则拿下IP头来。得到目标IP之后呢，就开始进行路由判断。在路由判断之前，这个节点我们称为PREROUTING。如果发现IP是我的，包就应该是我的，就发给上面的传输层，这个节点叫作INPUT。如果发现IP不是我的，就需要转发出去，这个节点称为FORWARD。如果是我的，上层处理完毕完毕后，一般会返回一个处理结果，这个处理结果会发出去，这个节点称为OUTPUT，无论是FORWARD还是OUTPUT，都是路由判断之后发生的，最后一个节点是POSTROUTING。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221006172044.png"><br>因为在Linux内核中，有一个框架叫Netfilter。它可以在这些节点插入hook函数。这些函数可以截获数据包，对数据包进行干预。例如做一定的修改，然后决策是否接着交给TCP&#x2F;IP协议栈处理；或者可以交回给协议栈，那就是ACCEPT；或者过滤掉，不再传输，就是DROP；还有就是QUEUE，发送给某个用户态进程处理。<br>基于这个Netfilter框架，内核模块ip_tables就实现了不同过程中的hook函数，在五个节点上根据规则进行包的处理。按功能可以分为四大类：连接跟踪（conntrack）、数据包的过滤（filter）、网络地址转换（nat）和数据包的修改（mangle）。其中连接跟踪是基础功能，被其他功能所依赖。其他三个可以实现包的过滤、修改和网络地址转换。<br>在用户态的客户端程序iptables，用命令行干预内核的规则，内核的功能对应iptables的命令行来讲，就是表和链的概念。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221006173630.png"><br>iptables的表分为四种：raw–&gt;mangle–&gt;nat–&gt;filter。这四个优先级依次降低，raw不常用，所以主要功能都在其他三种表里实现。每个表可以设置多个链。</p>
<ol>
<li>filter表处理过滤功能，主要包含三个链：<br>INPUT链：过滤所有目标地址是本机的数据包；<br>FORWARD链：过滤所有路过本机的数据包；<br>OUTPUT链：过滤所有由本机产生的数据包。</li>
<li>nat表主要是处理网络地址转换，可以进行Snat（改变数据包的源地址）、Dnat（改变数据包的目标地址），包含三个链：<br>PREROUTING链：可以在数据包到达防火墙时改变目标地址；<br>OUTPUT链：可以改变本地产生的数据包的目标地址；<br>POSTROUTING链：在数据包离开防火墙时改变数据包的源地址。</li>
<li>mangle表主要是修改数据包，包含：<br>PREROUTING链；<br>INPUT链；<br>FORWARD链；<br>OUTPUT链；<br>POSTROUTING链。<br>将iptables的表和链加入到上面的过程图中，就形成了下面的图和过程。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221006174000.png"></li>
<li>数据包进入的时候，先进mangle表的PREROUTING链。在这里可以根据需要，改变数据包头内容之后，进入nat表的PREROUTING链，在这里可以根据需要做Dnat，也就是目标地址转换。</li>
<li>进入路由判断，要判断是进入本地的还是转发的。</li>
<li>如果是进入本地的，就进入INPUT链，之后按条件过滤限制进入。</li>
<li>之后进入本机，再进入OUTPUT链，按条件过滤限制出去，离开本地。</li>
<li>如果是转发就进入FORWARD链，根据条件过滤限制转发。</li>
<li>之后进入POSTROUTING链，这里可以做Snat，离开网络接口。</li>
</ol>
<h2 id="3-4-云中的网络QoS"><a href="#3-4-云中的网络QoS" class="headerlink" title="3.4 云中的网络QoS"></a>3.4 云中的网络QoS</h2><p>控制网络的QoS的方式：在Linux下，可以通过TC控制网络的QoS，主要就是通过队列的方式。</p>
<ol>
<li>无类别排队规则</li>
</ol>
<ul>
<li>无类别排队<br>pfifo_fast，这是一种不把网络包分类的技术。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221007143136.png"><br>pfifo_fast分为三个先入先出的队列，称为三个Band。根据网络包里面TOS，看这个包到底应该进入哪个队列。TOS总共四位，每一位表示的意思不同，总共十六种类型。<br>通过命令行tc qdisc show dev eth0，可以输出结果priomap，也是十六个数字。在0到2之间，和TOS的十六种类型对应起来，表示不同的TOS对应的不同的队列。其中Band 0优先级最高，发送完毕后才轮到Band 1发送，最后才是Band 2。</li>
<li>随机公平队列</li>
</ul>
<p> <br>会建立很多的FIFO的队列，TCP Session会计算hash值，通过hash值分配到某个队列。在队列的另一端，网络包会通过轮询策略从各个队列中取出发送。这样不会有一个Session占据所有的流量。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221007143324.png"><br>当然如果两个Session的hash是一样的，会共享一个队列，也有可能互相影响。hash函数会经常改变，从而session不会总是相互影响。</p>
<ul>
<li>令牌桶规则<br>所有的网络包排成队列进行发送，但不是到了队头就能发送，而是需要拿到令牌才能发送。令牌根据设定的速度生成，所以即便队列很长，也是按照一定的速度进行发送的。当没有包在队列中的时候，令牌还是以既定的速度生成，但是不是无限累积的，而是放满了桶为止。设置桶的大小为了避免下面的情况：当长时间没有网络包发送的时候，积累了大量的令牌，突然来了大量的网络包，每个都能得到令牌，造成瞬间流量大增。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221007143525.png"></li>
</ul>
<ol start="2">
<li>基于类别的队列规则</li>
</ol>
<ul>
<li>分层令牌桶规则（HTB， Hierarchical Token Bucket）<br>HTB往往是一棵树，接下来我举个具体的例子，通过TC如何构建一棵HTB树来带你理解。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221007143708.png"><br>使用TC可以为某个网卡eth0创建一个HTB的队列规则，需要付给它一个句柄为（1:）。<br>这是整棵树的根节点，接下来会有分支。例如图中有三个分支，句柄分别为（:10）、（:11）、（:12）。最后的参数default 12，表示默认发送给1:12，也即发送给第三个分支。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev eth0 root handle 1: htb default 12</span><br></pre></td></tr></table></figure>
对于这个网卡，需要规定发送的速度。一般有两个速度可以配置，一个是rate，表示一般情况下的速度；一个是ceil，表示最高情况下的速度。对于根节点来讲，这两个速度是一样的，于是创建一个root class，速度为（rate&#x3D;100kbps，ceil&#x3D;100kbps）。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc class add dev eth0 parent 1: classid 1:1 htb rate 100kbps ceil 100kbps</span><br></pre></td></tr></table></figure>
接下来要创建分支，也即创建几个子class。每个子class统一有两个速度。三个分支分别为（rate&#x3D;30kbps，ceil&#x3D;100kbps）、（rate&#x3D;10kbps，ceil&#x3D;100kbps）、（rate&#x3D;60kbps，ceil&#x3D;100kbps）。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tc class add dev eth0 parent 1:1 classid 1:10 htb rate 30kbps ceil 100kbps</span><br><span class="line">tc class add dev eth0 parent 1:1 classid 1:11 htb rate 10kbps ceil 100kbps</span><br><span class="line">tc class add dev eth0 parent 1:1 classid 1:12 htb rate 60kbps ceil 100kbps</span><br></pre></td></tr></table></figure>
你会发现三个rate加起来，是整个网卡允许的最大速度。<br>HTB有个很好的特性，同一个root class下的子类可以相互借流量，如果不直接在队列规则下面创建一个root class，而是直接创建三个class，它们之间是不能相互借流量的。借流量的策略，可以使得当前不使用这个分支的流量的时候，可以借给另一个分支，从而不浪费带宽，使带宽发挥最大的作用。<br>最后，创建叶子队列规则，分别为fifo和sfq。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev eth0 parent 1:10 handle 20: pfifo limit 5</span><br><span class="line">tc qdisc add dev eth0 parent 1:11 handle 30: pfifo limit 5</span><br><span class="line">tc qdisc add dev eth0 parent 1:12 handle 40: sfq perturb 10</span><br></pre></td></tr></table></figure>
基于这个队列规则，我们还可以通过TC设定发送规则：从1.2.3.4来的，发送给port 80的包，从第一个分支1:10走；其他从1.2.3.4发送来的包从第二个分支1:11走；其他的走默认分支。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 match ip src 1.2.3.4 match ip dport 80 0xffff flowid 1:10</span><br><span class="line">tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 match ip src 1.2.3.4 flowid 1:11</span><br></pre></td></tr></table></figure>
云中的流量控制主要通过队列进行的，队列分为两大类：无类别队列规则和基于类别的队列规则。<br>使用Openvswitch配置QoS，在云中网络Openvswitch中，主要使用的是分层令牌桶规则（HTB），将总的带宽在一棵树上按照配置的比例进行分配，并且在一个分支不用的时候，可以借给另外的分支，从而增强带宽利用率。</li>
</ul>
<h2 id="3-5-云中网络的隔离GRE、VXLAN"><a href="#3-5-云中网络的隔离GRE、VXLAN" class="headerlink" title="3.5 云中网络的隔离GRE、VXLAN"></a>3.5 云中网络的隔离GRE、VXLAN</h2><p>底层的物理网络设备组成的网络我们称为Underlay网络，而用于虚拟机和云中的这些技术组成的网络称为Overlay网络，这是一种基于物理网络的虚拟化网络实现。下边讲两个Overlay的网络技术。</p>
<h3 id="3-5-1-GRE"><a href="#3-5-1-GRE" class="headerlink" title="3.5.1 GRE"></a>3.5.1 GRE</h3><p>GRE，全称Generic Routing Encapsulation，它是一种IP-over-IP的隧道技术。它将IP包封装在GRE包里，外面加上IP头，在隧道的一端封装数据包，并在通路上进行传输，到另外一端的时候解封装。你可以认为Tunnel是一个虚拟的、点对点的连接。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221007144901.png"><br>在GRE头中，前32位是一定会有的，后面的都是可选的。在前4位标识位里面，有标识后面到底有没有可选项？这里面有个很重要的key字段，是一个32位的字段，里面存放的往往就是用于区分用户的Tunnel ID。32位，在云平台上也绰绰有余了。<br>下面的格式类型专门用于网络虚拟化的GRE包头格式，称为NVGRE，也给网络ID号24位，也完全够用了。<br>GRE还需要有一个地方来封装和解封装GRE的包，这个地方往往是路由器或者有路由功能的Linux机器。<br>使用GRE隧道，传输的过程就像下面这张图。这里面有两个网段、两个路由器，中间要通过GRE隧道进行通信。当隧道建立之后，会多出两个Tunnel端口，用于封包、解封包。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221007145231.png"></p>
<ol>
<li>主机A在左边的网络，IP地址为192.168.1.102，它想要访问主机B，主机B在右边的网络，IP地址为192.168.2.115。于是发送一个包，源地址为192.168.1.102，目标地址为192.168.2.115。因为要跨网段访问，于是根据默认的default路由表规则，要发给默认的网关192.168.1.1，也即左边的路由器。</li>
<li>根据路由表，从左边的路由器，去192.168.2.0&#x2F;24这个网段，应该走一条GRE的隧道，从隧道一端的网卡Tunnel0进入隧道。</li>
<li>在Tunnel隧道的端点进行包的封装，在内部的IP头之外加上GRE头。对于NVGRE来讲，是在MAC头之外加上GRE头，然后加上外部的IP地址，也即路由器的外网IP地址。源IP地址为172.17.10.10，目标IP地址为172.16.11.10，然后从E1的物理网卡发送到公共网络里。</li>
<li>在公共网络里面，沿着路由器一跳一跳地走，全部都按照外部的公网IP地址进行。</li>
<li>当网络包到达对端路由器的时候，也要到达对端的Tunnel0，然后开始解封装，将外层的IP头取下来，然后根据里面的网络包，根据路由表，从E3口转发出去到达服务器B。</li>
</ol>
<p>GRE技术存在的一些不足之处：</p>
<ol>
<li>Tunnel的数量问题。GRE是一种点对点隧道，如果有三个网络，就需要在每两个网络之间建立一个隧道。如果网络数目增多，这样隧道的数目会呈指数性增长。</li>
<li>GRE不支持组播，因此一个网络中的一个虚机发出一个广播帧后，GRE会将其广播到所有与该节点有隧道连接的节点。</li>
<li>目前还是有很多防火墙和三层网络设备无法解析GRE，因此它们无法对GRE封装包做合适地过滤和负载均衡。</li>
</ol>
<h3 id="3-5-2-VXLAN"><a href="#3-5-2-VXLAN" class="headerlink" title="3.5.2 VXLAN"></a>3.5.2 VXLAN</h3><p>第二种Overlay的技术称为VXLAN。和三层外面再套三层的GRE不同，VXLAN则是从二层外面就套了一个VXLAN的头，这里面包含的VXLAN ID为24位，也够用了。在VXLAN头外面还封装了UDP、IP，以及外层的MAC头。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221007145755.png"><br>VXLAN作为扩展性协议，也需要一个地方对VXLAN的包进行封装和解封装，实现这个功能的点称为VTEP（VXLAN Tunnel Endpoint）。<br>VTEP相当于虚拟机网络的管家。每台物理机上都可以有一个VTEP。每个虚拟机启动的时候，都需要向这个VTEP管家注册，每个VTEP都知道自己上面注册了多少个虚拟机。当虚拟机要跨VTEP进行通信的时候，需要通过VTEP代理进行，由VTEP进行包的封装和解封装。<br>和GRE端到端的隧道不同，VXLAN不是点对点的，而是支持通过组播的来定位目标机器的，而非一定是这一端发出，另一端接收。<br>当一个VTEP启动的时候，它们都需要通过IGMP协议。加入一个组播组，就像加入一个邮件列表，或者加入一个微信群一样，所有发到这个邮件列表里面的邮件，或者发送到微信群里面的消息，大家都能收到。而当每个物理机上的虚拟机启动之后，VTEP就知道，有一个新的VM上线了，它归我管。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221007152220.png"><br>虚拟机1发送数据包到虚拟机2时，因为不知道虚拟机2的MAC地址，首先需要发送ARP报文进行广播，虚拟机1发送ARP到VTEP1,VTEP1使用VXLAN封装报文，因为VTEP1加入了组播组，可以发送组播，问VTEP2和VTEP3虚拟机2是谁在管，VTEP2收到报文后回复VTEP1，告诉了VTEP1虚拟机2的MAC信息，VTEP2也学到了VTEP1的信息，知道找虚拟机1要到VTEP1。<br>通过以上的方式，虚拟机1知道了虚拟机2的MAC地址，再发送报文时目标MAC填为虚拟机2。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221007152800.png"><br>OpenvSwitch支持三类隧道：GRE、VXLAN、IPsec_GRE。在使用OpenvSwitch的时候，虚拟交换机就相当于GRE和VXLAN封装的端点。OpenvSwitch可以作为Tunnel Endpoint，通过设置流表的规则，将虚拟机网络和物理机网络进行隔离、转换。<br>GRE是一种点对点的隧道模式，VXLAN支持组播的隧道模式，它们都要在某个Tunnel Endpoint进行封装和解封装，来实现跨物理机的互通。</p>
<h2 id="3-6-容器网络"><a href="#3-6-容器网络" class="headerlink" title="3.6 容器网络"></a>3.6 容器网络</h2><p>容器是一种比虚拟机更加轻量级的隔离方式，主要通过namespace和cgroup技术进行资源的隔离，namespace用于负责看起来隔离，cgroup用于负责用起来隔离。<br>容器网络连接到物理网络的方式和虚拟机很像，通过桥接的方式实现一台物理机上的容器进行相互访问，如果要访问外网，最简单的方式还是通过NAT。</p>
<h3 id="3-6-1-容器网络之Flannel"><a href="#3-6-1-容器网络之Flannel" class="headerlink" title="3.6.1 容器网络之Flannel"></a>3.6.1 容器网络之Flannel</h3><p>每个物理机内部的容器要访问其他物理机内的容器就需要映射物理机IP和端口，可以注册到注册中心，但是一个物理机中部署了多个tomcat容器服务，每个都要监听8080端口，物理机上的8080端口无法对应多个tomcat服务。因而就需要随机分配映射端口，于是在注册中心就出现了各种各样奇怪的端口。无论是注册中心，还是调用方都会觉得很奇怪，而且不是默认的端口，很多情况下也容易出错。<br>为了解决物理机IP地址冲突问题，区分物理机可以把不同物理机使用不同的网段，例如物理机A是网段172.17.8.0&#x2F;24，物理机B是网段172.17.9.0&#x2F;24，这样两台机器上启动的容器IP肯定不一样，而且就看IP地址，我们就一下子识别出，这个容器是本机的，还是远程的，如果是远程的，也能从网段一下子就识别出它归哪台物理机管，太方便了。<br>物理机A上的容器如何访问到物理机B上的容器呢？ Flannel使用UDP实现Overlay网络的方案。如下：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221009114841.png"></p>
<ol>
<li>在物理机A上的容器A里面，能看到的容器的IP地址是172.17.8.2&#x2F;24，里面设置了默认的路由规则default via 172.17.8.1 dev eth0。</li>
<li>如果容器A要访问172.17.9.2，就会发往这个默认的网关172.17.8.1。172.17.8.1就是物理机上面docker0网桥的IP地址，这台物理机上的所有容器都是连接到这个网桥的。</li>
<li>在物理机上面，查看路由策略，会有这样一条172.17.0.0&#x2F;24 via 172.17.0.0 dev flannel.1，也就是说发往172.17.9.2的网络包会被转发到flannel.1这个网卡。</li>
<li>在每台物理机上，都会跑一个flanneld进程，这个进程打开一个&#x2F;dev&#x2F;net&#x2F;tun字符设备的时候，就出现了这个网卡。</li>
<li>物理机A上的flanneld会将网络包封装在UDP包里面，然后外层加上物理机A和物理机B的IP地址，发送给物理机B上的flanneld。</li>
<li>为什么是UDP呢？因为不想在flanneld之间建立两两连接，而UDP没有连接的概念，任何一台机器都能发给另一台。</li>
<li>物理机B上的flanneld收到包之后，解开UDP的包，将里面的网络包拿出来，从物理机B的flannel.1网卡发出去。</li>
<li>在物理机B上，有路由规则172.17.9.0&#x2F;24 dev docker0 proto kernel scope link src 172.17.9.1。</li>
<li>将包发给docker0，docker0将包转给容器B。通信成功。</li>
</ol>
<blockquote>
<p>上面的过程连通性没有问题，但是由于全部在用户态，所以性能差了一些。</p>
</blockquote>
<p>Flannel也可以用VXLAN，如果使用VXLAN，就不需要打开一个TUN设备了，而是要建立一个VXLAN的VTEP。可以通过netlink通知内核建立一个VTEP的网卡flannel.1。在我们讲OpenvSwitch的时候提过，netlink是一种用户态和内核态通信的机制。<br>当网络包从物理机A上的容器A发送给物理机B上的容器B，在容器A里面通过默认路由到达物理机A上的docker0网卡，然后根据路由规则，在物理机A上，将包转发给flannel.1。这个时候flannel.1就是一个VXLAN的VTEP了，它将网络包进行封装。<br>内部的MAC地址这样写：源为物理机A的flannel.1的MAC地址，目标为物理机B的flannel.1的MAC地址，在外面加上VXLAN的头。<br>外层的IP地址这样写：源为物理机A的IP地址，目标为物理机B的IP地址，外面加上物理机的MAC地址。<br>这样就能通过VXLAN将包转发到另一台机器，从物理机B的flannel.1上解包，变成内部的网络包，通过物理机B上的路由转发到docker0，然后转发到容器B里面。通信成功。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221009115554.png"><br>基于NAT的容器网络模型在微服务架构下有两个问题，一个是IP重叠，一个是端口冲突，需要通过Overlay网络的机制保持跨节点的连通性。<br>Flannel是跨节点容器网络方案之一，它提供的Overlay方案主要有两种方式，一种是UDP在用户态封装，一种是VXLAN在内核态封装，而VXLAN的性能更好一些。</p>
<h3 id="3-6-2-容器网络之Calico"><a href="#3-6-2-容器网络之Calico" class="headerlink" title="3.6.2 容器网络之Calico"></a>3.6.2 容器网络之Calico</h3><ul>
<li>Calico网络模型的设计思路</li>
</ul>
<p>我们看图中的两台物理机。它们的物理网卡是同一个二层网络里面的。由于两台物理机的容器网段不同，我们完全可以将两台物理机配置成为路由器，并按照容器的网段配置路由表。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221009200916.png"><br>例如，在物理机A中，我们可以这样配置：要想访问网段172.17.9.0&#x2F;24，下一跳是192.168.100.101，也即到物理机B上去。<br>这样在容器A中访问容器B，当包到达物理机A的时候，就能够匹配到这条路由规则，并将包发给下一跳的路由器，也即发给物理机B。在物理机B上也有路由规则，要访问172.17.9.0&#x2F;24，从docker0的网卡进去即可。<br>当容器B返回结果的时候，在物理机B上，可以做类似的配置：要想访问网段172.17.8.0&#x2F;24，下一跳是192.168.100.100，也即到物理机A上去。<br>当包到达物理机B的时候，能够匹配到这条路由规则，将包发给下一跳的路由器，也即发给物理机A。在物理机A上也有路由规则，要访问172.17.8.0&#x2F;24，从docker0的网卡进去即可。<br>这就是<strong>Calico网络的大概思路，即不走Overlay网络，不引入另外的网络性能损耗，而是将转发全部用三层网络的路由转发来实现</strong>，只不过具体的实现和上面的过程稍有区别。<br>首先，如果全部走三层的路由规则，没必要每台机器都用一个docker0，从而浪费了一个IP地址，而是可以直接用路由转发到veth pair在物理机这一端的网卡。同样，在容器内，路由规则也可以这样设定：把容器外面的veth pair网卡算作默认网关，下一跳就是外面的物理机。<br>于是，整个拓扑结构就变成了这个图中的样子。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221009201035.png"></p>
<ul>
<li>Calico网络的转发细节</li>
</ul>
<p>容器A1的IP地址为172.17.8.2&#x2F;32，里面配置的默认路由为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default via 169.254.1.1 dev eth0</span><br><span class="line">169.254.1.1 dev eth0 scope link</span><br></pre></td></tr></table></figure>
<p>在物理机A上查看所有网卡的MAC地址的时候，我们会发现veth1就是这个MAC地址。所以容器A1里发出的网络包，第一跳就是这个veth1这个网卡，也就到达了物理机A这个路由器。<br>在物理机A上有三条路由规则，分别是去两个本机的容器的路由，以及去172.17.9.0&#x2F;24，下一跳为物理机B。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">172.17.8.2 dev veth1 scope link</span><br><span class="line">172.17.8.3 dev veth2 scope link</span><br><span class="line">172.17.9.0/24 via 192.168.100.101 dev eth0 proto bird onlink</span><br></pre></td></tr></table></figure>
<p>同理，物理机B上也有三条路由规则，分别是去两个本机的容器的路由，以及去172.17.8.0&#x2F;24，下一跳为物理机A。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">172.17.9.2 dev veth1 scope link</span><br><span class="line">172.17.9.3 dev veth2 scope link</span><br><span class="line">172.17.8.0/24 via 192.168.100.100 dev eth0 proto bird onlink</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221009201439.png"><br>在这里，物理机化身为路由器，通过路由器上的路由规则，将包转发到目的地。在这个过程中，没有隧道封装解封装，仅仅是单纯的路由转发，性能会好很多。但是，这种模式也有很多问题。</p>
<ul>
<li>路由配置组件Felix</li>
</ul>
<p>如果只有两台机器，每台机器只有两个容器，而且保持不变。我手动配置一下，倒也没啥问题。但是如果容器不断地创建、删除，节点不断地加入、退出，情况就会变得非常复杂。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221009201528.png"></p>
<p>就像图中，有三台物理机，两两之间都需要配置路由，每台物理机上对外的路由就有两条。如果有六台物理机，则每台物理机上对外的路由就有五条。新加入一个节点，需要通知每一台物理机添加一条路由。<br>这还是在物理机之间，一台物理机上，每创建一个容器，也需要多配置一条指向这个容器的路由。如此复杂，肯定不能手动配置，需要每台物理机上有一个agent，当创建和删除容器的时候，自动做这件事情。这个agent在Calico中称为Felix。</p>
<ul>
<li>路由广播组件BGP Speaker</li>
</ul>
<p>当Felix配置了路由之后，接下来的问题就是，如何将路由信息，也即将“如何到达我这个节点，访问我这个节点上的容器”这些信息，广播出去。<br>能想起来吗？这其实就是路由协议啊！路由协议就是将“我能到哪里，如何能到我”的信息广播给全网传出去，从而客户端可以一跳一跳地访问目标地址的。路由协议有很多种，Calico使用的是BGP协议。<br>在Calico中，每个Node上运行一个软件BIRD，作为BGP的客户端，或者叫作BGP Speaker，将“如何到达我这个Node，访问我这个Node上的容器”的路由信息广播出去。所有Node上的BGP Speaker 都互相建立连接，就形成了全互连的情况，这样每当路由有所变化的时候，所有节点就都能够收到了。</p>
<ul>
<li>安全策略组件</li>
</ul>
<p>Calico中还实现了灵活配置网络策略Network Policy，可以灵活配置两个容器通或者不通，实现方式就是通过配置iptables规则。</p>
<ul>
<li>跨网段访问问题</li>
</ul>
<p>前面我们说的那些逻辑成立的条件，是我们假设物理机可以作为路由器进行使用。例如物理机A要告诉物理机B，你要访问172.17.8.0&#x2F;24，下一跳是我192.168.100.100；同理，物理机B要告诉物理机A，你要访问172.17.9.0&#x2F;24，下一跳是我192.168.100.101。<br>之所以能够这样，是因为物理机A和物理机B是同一个网段的，是连接在同一个交换机上的。那如果物理机A和物理机B不是在同一个网段呢？<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/blog/20221009201800.png"><br>通过在物理机A和物理机B之间打一个隧道，这个隧道有两个端点，在端点上进行封装，将容器的IP作为乘客协议放在隧道里面，而物理主机的IP放在外面作为承载协议。这样不管外层的IP通过传统的物理网络，走多少跳到达目标物理机，从隧道两端看起来，物理机A的下一跳就是物理机B。<br>这就是Calico的IPIP模式。使用了IPIP模式之后，在物理机A上，我们能看到这样的路由表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">172.17.8.2 dev veth1 scope link</span><br><span class="line">172.17.8.3 dev veth2 scope link</span><br><span class="line">172.17.9.0/24 via 192.168.200.101 dev tun0 proto bird onlink</span><br></pre></td></tr></table></figure>
<p>这和原来模式的区别在于，下一跳不再是同一个网段的物理机B了，IP为192.168.200.101，并且不是从eth0跳，而是建立一个隧道的端点tun0，从这里才是下一跳。<br>如果我们在容器A1里面的172.17.8.2，去ping容器B1里面的172.17.9.2，首先会到物理机A。在物理机A上根据上面的规则，会转发给tun0，并在这里对包做封装：</p>
<ul>
<li>内层源IP为172.17.8.2；</li>
<li>内层目标IP为172.17.9.2；</li>
<li>外层源IP为192.168.100.100；</li>
<li>外层目标IP为192.168.200.101。</li>
</ul>
<p>将这个包从eth0发出去，在物理网络上会使用外层的IP进行路由，最终到达物理机B。在物理机B上，tun0会解封装，将内层的源IP和目标IP拿出来，转发给相应的容器。</p>
<ul>
<li>总结</li>
</ul>
<p>Calico推荐使用物理机作为路由器的模式，这种模式没有虚拟化开销，性能比较高。<br>Calico的主要组件包括路由、iptables的配置组件Felix、路由广播组件BGP Speaker，以及大规模场景下的BGP Route Reflector。<br>为解决跨网段的问题，Calico还有一种IPIP模式，也即通过打隧道的方式，从隧道端点来看，将本来不是邻居的两台机器，变成相邻的机器。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://baihlup.github.io">梦之痕</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://baihlup.github.io/2024/08/26/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/271%20-%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02%20-%20%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">https://baihlup.github.io/2024/08/26/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/271%20-%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02%20-%20%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/28/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/279%20-%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/02%20-%20%E8%AE%B0%E5%BD%95%E8%AE%BF%E9%97%AE%20HTTPS%20%E7%BD%91%E7%AB%99%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/" title="记录访问 HTTPS 网站报错问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">记录访问 HTTPS 网站报错问题</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/28/240%20-%20%E8%99%9A%E6%8B%9F%E5%8C%96&amp;%E4%BA%91%E8%AE%A1%E7%AE%97/244%20-%20%E4%BA%91%E5%8E%9F%E7%94%9F/02%20-%20Kubernetes%20%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%EF%BC%88%E4%BA%8C%EF%BC%89/" title="Kubernetes 核心组件（二）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">Kubernetes 核心组件（二）</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">梦之痕</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/BaihlUp"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">个人笔记迁移中ing....</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.</span> <span class="toc-text">0 参考资料</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%BB%BC%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">1 通信协议综述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%BA%95%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.</span> <span class="toc-text">2 底层网络协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%BA%8C%E5%B1%82%E5%88%B0%E4%B8%89%E5%B1%82"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 二层到三层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E7%89%A9%E7%90%86%E5%B1%82%E5%92%8CMAC%E5%B1%82"><span class="toc-number">3.1.1.</span> <span class="toc-text">2.1.1 物理层和MAC层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%B8%8EVLAN"><span class="toc-number">3.1.2.</span> <span class="toc-text">2.1.2 交换机与VLAN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-ICMP%E5%92%8Cping"><span class="toc-number">3.1.3.</span> <span class="toc-text">2.1.3 ICMP和ping</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 传输层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 应用层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-DNS%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.4.</span> <span class="toc-text">2.4 DNS协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-DNS%E7%9A%84%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-number">3.4.1.</span> <span class="toc-text">2.4.1 DNS的解析流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">3.4.2.</span> <span class="toc-text">2.4.2 负载均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E5%86%85%E9%83%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">3.4.3.</span> <span class="toc-text">2.4.3 内部负载均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-5-%E5%85%A8%E5%B1%80%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">3.4.4.</span> <span class="toc-text">2.4.5 全局负载均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-6-%E7%A4%BA%E4%BE%8B%EF%BC%9ADNS%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E4%B8%8A%E7%9A%84%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="toc-number">3.4.5.</span> <span class="toc-text">2.4.6 示例：DNS访问数据中心对象存储上的静态资源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-HTTPDNS"><span class="toc-number">3.5.</span> <span class="toc-text">2.5 HTTPDNS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E4%BC%A0%E7%BB%9FDNS%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.1.</span> <span class="toc-text">2.5.1 传统DNS存在的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-HTTPDNS%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.5.2.</span> <span class="toc-text">2.5.2 HTTPDNS的工作模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-HTTPDNS%E7%9A%84%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.5.3.</span> <span class="toc-text">2.5.3 HTTPDNS的缓存设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-4-HTTPDNS%E7%9A%84%E8%B0%83%E5%BA%A6%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.5.4.</span> <span class="toc-text">2.5.4 HTTPDNS的调度设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-CDN"><span class="toc-number">3.6.</span> <span class="toc-text">2.6 CDN</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-CDN%E7%9A%84%E5%88%86%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="toc-number">3.6.1.</span> <span class="toc-text">2.6.1 CDN的分发系统的架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E7%9B%B8%E5%BA%94%E7%9A%84%E8%BE%B9%E7%BC%98%E8%8A%82%E7%82%B9%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%E5%91%A2%EF%BC%9F"><span class="toc-number">3.6.2.</span> <span class="toc-text">2.6.2 客户端如何找到相应的边缘节点进行访问呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-3-CDN%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E7%BC%93%E5%AD%98%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">3.6.3.</span> <span class="toc-text">2.6.3 CDN可以进行缓存的内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-4-%E9%98%B2%E7%9B%97%E9%93%BE"><span class="toc-number">3.6.4.</span> <span class="toc-text">2.6.4 防盗链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-5-%E5%8A%A8%E6%80%81CDN"><span class="toc-number">3.6.5.</span> <span class="toc-text">2.6.5 动态CDN</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83"><span class="toc-number">3.7.</span> <span class="toc-text">2.7 数据中心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-1"><span class="toc-number">3.7.1.</span> <span class="toc-text">2.7.1</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-VPN"><span class="toc-number">3.8.</span> <span class="toc-text">2.8 VPN</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-1-IPsec"><span class="toc-number">3.8.1.</span> <span class="toc-text">2.8.1 IPsec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-2-MPLS"><span class="toc-number">3.8.2.</span> <span class="toc-text">2.8.2 MPLS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C"><span class="toc-number">4.</span> <span class="toc-text">3 云计算中的网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E4%BA%91%E4%B8%AD%E7%BD%91%E7%BB%9C"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 云中网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 软件定义网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%EF%BC%88SDN%EF%BC%89"><span class="toc-number">4.2.1.</span> <span class="toc-text">3.2.1 软件定义网络（SDN）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-OpenFlow%E5%92%8COpenvSwitch"><span class="toc-number">4.2.2.</span> <span class="toc-text">3.2.2 OpenFlow和OpenvSwitch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E4%BA%91%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 云中的网络安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E4%BA%91%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9CQoS"><span class="toc-number">4.4.</span> <span class="toc-text">3.4 云中的网络QoS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E4%BA%91%E4%B8%AD%E7%BD%91%E7%BB%9C%E7%9A%84%E9%9A%94%E7%A6%BBGRE%E3%80%81VXLAN"><span class="toc-number">4.5.</span> <span class="toc-text">3.5 云中网络的隔离GRE、VXLAN</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-GRE"><span class="toc-number">4.5.1.</span> <span class="toc-text">3.5.1 GRE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-VXLAN"><span class="toc-number">4.5.2.</span> <span class="toc-text">3.5.2 VXLAN</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C"><span class="toc-number">4.6.</span> <span class="toc-text">3.6 容器网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B9%8BFlannel"><span class="toc-number">4.6.1.</span> <span class="toc-text">3.6.1 容器网络之Flannel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-2-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B9%8BCalico"><span class="toc-number">4.6.2.</span> <span class="toc-text">3.6.2 容器网络之Calico</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/11/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/279%20-%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/06%20-%20%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%94%A8%E5%8F%8C%E5%8D%81%E4%B8%80%E7%9A%84%E6%95%85%E4%BA%8B%E4%B8%B2%E8%B5%B7%E7%A2%8E%E7%89%87%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%AD%EF%BC%89/" title="Untitled">Untitled</a><time datetime="2024-10-11T03:19:20.271Z" title="Created 2024-10-11 03:19:20">2024-10-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/11/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/279%20-%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/07%20-%20%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%94%A8%E5%8F%8C%E5%8D%81%E4%B8%80%E7%9A%84%E6%95%85%E4%BA%8B%E4%B8%B2%E8%B5%B7%E7%A2%8E%E7%89%87%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8B%EF%BC%89/" title="Untitled">Untitled</a><time datetime="2024-10-11T03:19:20.271Z" title="Created 2024-10-11 03:19:20">2024-10-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/11/260%20-%20%E5%90%8E%E7%AB%AF&amp;%E6%9E%B6%E6%9E%84/261%20-%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02%20-%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/" title="Untitled">Untitled</a><time datetime="2024-10-11T03:19:20.267Z" title="Created 2024-10-11 03:19:20">2024-10-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/11/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/279%20-%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/05%20-%20%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%94%A8%E5%8F%8C%E5%8D%81%E4%B8%80%E7%9A%84%E6%95%85%E4%BA%8B%E4%B8%B2%E8%B5%B7%E7%A2%8E%E7%89%87%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8A%EF%BC%89/" title="Untitled">Untitled</a><time datetime="2024-10-11T03:19:20.267Z" title="Created 2024-10-11 03:19:20">2024-10-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/28/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/279%20-%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/02%20-%20%E8%AE%B0%E5%BD%95%E8%AE%BF%E9%97%AE%20HTTPS%20%E7%BD%91%E7%AB%99%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/" title="记录访问 HTTPS 网站报错问题">记录访问 HTTPS 网站报错问题</a><time datetime="2024-09-28T00:00:00.000Z" title="Created 2024-09-28 00:00:00">2024-09-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 梦之痕</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>