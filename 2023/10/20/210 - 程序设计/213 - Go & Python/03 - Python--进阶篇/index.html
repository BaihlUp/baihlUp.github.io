<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Python编程语言--进阶篇 | 梦之痕</title><meta name="author" content="梦之痕"><meta name="copyright" content="梦之痕"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="0 参考资料 Python核心技术与实战 – Geek  1 Python对象的比较、拷贝1.1 比较is 操作符和 &#x3D;&#x3D;操作符： 在 Python 中，每个对象的身份标识，都能通过函数 id(object) 获得。因此，&#39;is&#39;操作符，相当于比较对象之间的 ID 是否相等， 1234567891011121314a &#x3D; 10b &#x3D; 10 a &#x3D;&#x3D; bTrue id(a)44275">
<meta property="og:type" content="article">
<meta property="og:title" content="Python编程语言--进阶篇">
<meta property="og:url" content="https://baihlup.github.io/2023/10/20/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/213%20-%20Go%20&%20Python/03%20-%20Python--%E8%BF%9B%E9%98%B6%E7%AF%87/index.html">
<meta property="og:site_name" content="梦之痕">
<meta property="og:description" content="0 参考资料 Python核心技术与实战 – Geek  1 Python对象的比较、拷贝1.1 比较is 操作符和 &#x3D;&#x3D;操作符： 在 Python 中，每个对象的身份标识，都能通过函数 id(object) 获得。因此，&#39;is&#39;操作符，相当于比较对象之间的 ID 是否相等， 1234567891011121314a &#x3D; 10b &#x3D; 10 a &#x3D;&#x3D; bTrue id(a)44275">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg">
<meta property="article:published_time" content="2023-10-20T16:27:41.000Z">
<meta property="article:modified_time" content="2024-08-01T07:16:13.626Z">
<meta property="article:author" content="梦之痕">
<meta property="article:tag" content="程序设计">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://baihlup.github.io/2023/10/20/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/213%20-%20Go%20&amp;%20Python/03%20-%20Python--%E8%BF%9B%E9%98%B6%E7%AF%87/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python编程语言--进阶篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-01 07:16:13'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">56</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="梦之痕"><span class="site-name">梦之痕</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Python编程语言--进阶篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-10-20T16:27:41.000Z" title="Created 2023-10-20 16:27:41">2023-10-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-08-01T07:16:13.626Z" title="Updated 2024-08-01 07:16:13">2024-08-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Go-Python/">Go &amp; Python</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Python编程语言--进阶篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="0-参考资料"><a href="#0-参考资料" class="headerlink" title="0 参考资料"></a>0 参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100026901">Python核心技术与实战 – Geek</a></li>
</ul>
<h1 id="1-Python对象的比较、拷贝"><a href="#1-Python对象的比较、拷贝" class="headerlink" title="1 Python对象的比较、拷贝"></a>1 Python对象的比较、拷贝</h1><h2 id="1-1-比较"><a href="#1-1-比较" class="headerlink" title="1.1 比较"></a>1.1 比较</h2><p><strong><code>is</code> 操作符和 <code>==</code>操作符：</strong></p>
<p>在 Python 中，每个对象的身份标识，都能通过函数 id(object) 获得。因此，<code>&#39;is&#39;</code>操作符，相当于比较对象之间的 ID 是否相等，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line">a == b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">4427562448</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">4427562448</span></span><br><span class="line"> </span><br><span class="line">a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>对于整型数字来说，以上<code>a is b</code>为 True 的结论，适用于 -5 到 256 范围内的数字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">257</span></span><br><span class="line">b = <span class="number">257</span></span><br><span class="line"> </span><br><span class="line">a == b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">id</span>(a)</span><br><span class="line"><span class="number">4473417552</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">id</span>(b)</span><br><span class="line"><span class="number">4473417584</span></span><br><span class="line"> </span><br><span class="line">a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>Python 内部会对 -5 到 256 的整型维持一个数组，起到一个缓存的作用。这样，每次你试图创建一个 -5 到 256 范围内的整型数字时，Python 都会从这个数组中返回相对应的引用，而不是重新开辟一块新的内存空间。<br>使用<code>&#39;==&#39;</code>的次数会比<code>&#39;is&#39;</code>多得多，因为我们一般更关心两个变量的值，而不是它们内部的存储地址。但是，当我们比较一个变量与一个单例（singleton）时，通常会使用<code>&#39;is&#39;</code>。一个典型的例子，就是检查一个变量是否为 None：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      ...</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>
<p>比较操作符<code>&#39;is&#39;</code>的速度效率，通常要优于<code>&#39;==&#39;</code>。因为<code>&#39;is&#39;</code>操作符不能被重载，这样，Python 就不需要去寻找，程序中是否有其他地方重载了比较操作符，并去调用。执行比较操作符<code>&#39;is&#39;</code>，就仅仅是比较两个变量的 ID 而已。</p>
<p>但是<code>&#39;==&#39;</code>操作符却不同，执行<code>a == b</code>相当于是去执行<code>a.__eq__(b)</code>，而 Python 大部分的数据类型都会去重载<code>__eq__</code>这个函数，其内部的处理通常会复杂一些。比如，对于列表，<code>__eq__</code>函数会去遍历列表中的元素，比较它们的顺序和值是否相等。</p>
<h2 id="1-2-深拷贝和浅拷贝"><a href="#1-2-深拷贝和浅拷贝" class="headerlink" title="1.2 深拷贝和浅拷贝"></a>1.2 深拷贝和浅拷贝</h2><ul>
<li><strong>浅拷贝</strong></li>
</ul>
<p>常见的浅拷贝的方法，是使用数据类型本身的构造器，比如下面两个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l2 = <span class="built_in">list</span>(l1)</span><br><span class="line"> </span><br><span class="line">l2</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"> </span><br><span class="line">l1 == l2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"> </span><br><span class="line">l1 <span class="keyword">is</span> l2</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"> </span><br><span class="line">s1 = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">s2 = <span class="built_in">set</span>(s1)</span><br><span class="line"> </span><br><span class="line">s2</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"> </span><br><span class="line">s1 == s2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"> </span><br><span class="line">s1 <span class="keyword">is</span> s2</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>l2 就是 l1 的浅拷贝，s2 是 s1 的浅拷贝。对于可变的序列，还可以通过切片操作符<code>&#39;:&#39;</code>完成浅拷贝，比如下面这个列表的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l2 = l1[:]</span><br><span class="line"> </span><br><span class="line">l1 == l2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"> </span><br><span class="line">l1 <span class="keyword">is</span> l2</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>Python 中也提供了相对应的函数 copy.copy()，适用于任何数据类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l2 = copy.copy(l1)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，对于元组，使用 tuple() 或者切片操作符<code>&#39;:&#39;</code>不会创建一份浅拷贝，相反，它会返回一个指向相同元组的引用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">t2 = <span class="built_in">tuple</span>(t1)</span><br><span class="line"> </span><br><span class="line">t1 == t2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"> </span><br><span class="line">t1 <span class="keyword">is</span> t2</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>浅拷贝，是指重新分配一块内存，创建一个新的对象，里面的元素是原对象中子对象的引用。如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]  </span><br><span class="line">l2 = <span class="built_in">list</span>(l1)  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(l1), <span class="built_in">id</span>(l2))  <span class="comment"># 4372080128 4371268224  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(l1[<span class="number">3</span>]), <span class="built_in">id</span>(l2[<span class="number">3</span>])) <span class="comment"># 4302757312 4302757312  元素引用，地址一样</span></span><br><span class="line"><span class="built_in">print</span>(l1 <span class="keyword">is</span> l2)  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<p>如果原对象中的元素不可变，那倒无所谓；但如果元素可变，浅拷贝通常会带来一些副作用，尤其需要注意。我们来看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">l1 = [[<span class="number">1</span>, <span class="number">2</span>], (<span class="number">30</span>, <span class="number">40</span>)]</span><br><span class="line">l2 = <span class="built_in">list</span>(l1)</span><br><span class="line">l1.append(<span class="number">100</span>)</span><br><span class="line">l1[<span class="number">0</span>].append(<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">l1</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (<span class="number">30</span>, <span class="number">40</span>), <span class="number">100</span>]</span><br><span class="line"> </span><br><span class="line">l2</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (<span class="number">30</span>, <span class="number">40</span>)]</span><br><span class="line"> </span><br><span class="line">l1[<span class="number">1</span>] += (<span class="number">50</span>, <span class="number">60</span>)</span><br><span class="line">l1</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>), <span class="number">100</span>]</span><br><span class="line"> </span><br><span class="line">l2</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (<span class="number">30</span>, <span class="number">40</span>)]</span><br></pre></td></tr></table></figure>
<p>因为浅拷贝里的元素是对原对象元素的引用，因此 l2 中的元素和 l1 指向同一个列表和元组对象。<br><code>l1.append(100)</code>，表示对 l1 的列表新增元素 100。这个操作不会对 l2 产生任何影响，因为 l2 和 l1 作为整体是两个不同的对象，并不共享内存地址。操作过后 l2 不变，l1 会发生改变。<br><code>l1[0].append(3)</code>，这里表示对 l1 中的第一个列表新增元素 3。因为 l2 是 l1 的浅拷贝，l2 中的第一个元素和 l1 中的第一个元素，共同指向同一个列表，因此 l2 中的第一个列表也会相对应的新增元素 3。</p>
<ul>
<li><strong>深拷贝</strong></li>
</ul>
<p>深度拷贝，是指重新分配一块内存，创建一个新的对象，并且将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中。因此，新对象和原对象没有任何关联。<br>Python 中以 copy.deepcopy() 来实现对象的深度拷贝：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">l1 = [[<span class="number">1</span>, <span class="number">2</span>], (<span class="number">30</span>, <span class="number">40</span>)]</span><br><span class="line">l2 = copy.deepcopy(l1)</span><br><span class="line">l1.append(<span class="number">100</span>)</span><br><span class="line">l1[<span class="number">0</span>].append(<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">l1</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (<span class="number">30</span>, <span class="number">40</span>), <span class="number">100</span>]</span><br><span class="line"> </span><br><span class="line">l2 </span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], (<span class="number">30</span>, <span class="number">40</span>)]</span><br></pre></td></tr></table></figure>

<p>可以看到，无论 l1 如何变化，l2 都不变。因为此时的 l1 和 l2 完全独立，没有任何联系。<br>深度拷贝也不是完美的，往往也会带来一系列问题。如果被拷贝对象中存在指向自身的引用，那么程序很容易陷入无限循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">x = [<span class="number">1</span>]</span><br><span class="line">x.append(x) <span class="comment"># 列表 x 中有指向自身的引用，因此 x 是一个无限嵌套的列表。</span></span><br><span class="line"> </span><br><span class="line">x</span><br><span class="line">[<span class="number">1</span>, [...]]</span><br><span class="line"> </span><br><span class="line">y = copy.deepcopy(x)  </span><br><span class="line">y</span><br><span class="line">[<span class="number">1</span>, [...]]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x == y) <span class="comment"># 报错：list比较会进行遍历，导致无限循环</span></span><br></pre></td></tr></table></figure>
<p>深度拷贝函数 deepcopy 中会维护一个字典，记录已经拷贝的对象与其 ID。拷贝过程中，如果字典里已经存储了将要拷贝的对象，则会从字典直接返回，不会导致无限循环。如下是deepcopy源码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deepcopy</span>(<span class="params">x, memo=<span class="literal">None</span>, _nil=[]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Deep copy operation on arbitrary Python objects.</span></span><br><span class="line"><span class="string">    	</span></span><br><span class="line"><span class="string">	See the module&#x27;s __doc__ string for more info.</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> memo <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        memo = &#123;&#125;</span><br><span class="line">    d = <span class="built_in">id</span>(x) <span class="comment"># 查询被拷贝对象 x 的 id</span></span><br><span class="line">	y = memo.get(d, _nil) <span class="comment"># 查询字典里是否已经存储了该对象</span></span><br><span class="line">	<span class="keyword">if</span> y <span class="keyword">is</span> <span class="keyword">not</span> _nil:</span><br><span class="line">	    <span class="keyword">return</span> y <span class="comment"># 如果字典里已经存储了将要拷贝的对象，则直接返回</span></span><br><span class="line">        ...    </span><br></pre></td></tr></table></figure>

<h1 id="2-值传递-or-引用传递"><a href="#2-值传递-or-引用传递" class="headerlink" title="2 值传递 or 引用传递"></a>2 值传递 or 引用传递</h1><h2 id="2-1-Python变量及其赋值"><a href="#2-1-Python变量及其赋值" class="headerlink" title="2.1 Python变量及其赋值"></a>2.1 Python变量及其赋值</h2><p>Python代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = a</span><br><span class="line">a = a + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>前两行会让a、b同时指向 1 这个对象。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20231022095756.png"></p>
<p>最后一行，a的值变成2，会重新创建一个新的值为2的对象，让a指向它。b的值不变。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20231022095921.png"><br>通过这个例子你可以看到，这里的 a 和 b，开始只是两个指向同一个对象的变量而已，或者你也可以把它们想象成同一个对象的两个名字。</p>
<p>下边看一个列表的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l2 = l1</span><br><span class="line">l1.append(<span class="number">4</span>)</span><br><span class="line">l1</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">l2</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>首先让列表 l1 和 l2 同时指向了 [1, 2, 3] 这个对象。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20231022100035.png"><br>由于列表是可变的，所以 l1.append(4) 不会创建新的列表，只是在原列表的末尾插入了元素 4，变成 [1, 2, 3, 4]。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20231022100058.png"><br>需要注意的是，Python 里的变量可以被删除，但是对象无法被删除。比如下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">del</span> l</span><br></pre></td></tr></table></figure>
<p>del l 删除了 l 这个变量，从此以后你无法访问 l，但是对象 [1, 2, 3] 仍然存在。Python 程序运行时，其自带的垃圾回收系统会跟踪每个对象的引用。如果 [1, 2, 3] 除了 l 外，还在其他地方被引用，那就不会被回收，反之则会被回收。</p>
<blockquote>
<p>使用 <code>l2 = l1</code> 会创建两个变量指向同一个列表，而使用 <code>l2 = list(l1)</code> 会创建一个新的包含相同元素的列表。</p>
</blockquote>
<p><strong>总结：</strong></p>
<ul>
<li>变量的赋值，只是表示让变量指向了某个对象，并不表示拷贝对象给变量；而一个对象，可以被多个变量所指向。</li>
<li>可变对象（列表，字典，集合等等）的改变，会影响所有指向该对象的变量。</li>
<li>对于不可变对象（字符串，整型，元组等等），所有指向该对象的变量的值总是一样的，也不会改变。但是通过某些操作（+&#x3D; 等等）更新不可变对象的值时，会返回一个新的对象。</li>
<li>变量可以被删除，但是对象无法被删除。</li>
</ul>
<h2 id="2-2-Python函数的参数传递"><a href="#2-2-Python函数的参数传递" class="headerlink" title="2.2 Python函数的参数传递"></a>2.2 Python函数的参数传递</h2><p>Python 的参数传递是<strong>赋值传递</strong> （pass by assignment），或者叫作对象的<strong>引用传递</strong>（pass by object reference）。Python 里所有的数据类型都是对象，所以参数传递时，只是让新变量与原变量指向相同的对象而已，并不存在值传递或是引用传递一说。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func2</span>(<span class="params">b</span>):</span><br><span class="line">	b = <span class="number">2</span></span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line"> </span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">a = my_func2(a)</span><br><span class="line">a</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>函数my_func2传递a时，a，b都指向1，执行<code>b=2</code>后，b指向了一个新的对象2，a不变，如果要改变a，可以通过返回值赋值方式。（Python中无法通过引用方式改变参数值）</p>
<p>当可变对象当作参数传入函数里的时候，改变可变对象的值，就会影响所有指向它的变量。比如下面的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func3</span>(<span class="params">l2</span>):</span><br><span class="line">	l2.append(<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">my_func3(l1)</span><br><span class="line">l1</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>这里 l1 和 l2 先是同时指向值为 [1, 2, 3] 的列表。不过，由于列表可变，执行 append() 函数，对其末尾加入新元素 4 时，变量 l1 和 l2 的值也都随之改变了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func4</span>(<span class="params">l2</span>):</span><br><span class="line">	l2 = l2 + [<span class="number">4</span>]  <span class="comment"># 创建了新的对象赋值给l2</span></span><br><span class="line"> </span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">my_func4(l1)</span><br><span class="line">l1</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>为什么 l1 仍然是 [1, 2, 3]，而不是 [1, 2, 3, 4] 呢？<br>要注意，这里 l2 &#x3D; l2 + [4]，表示创建了一个“末尾加入元素 4“的新列表，并让 l2 指向这个新的对象。这个过程与 l1 无关，因此 l1 的值不变。当然，同样的，如果要改变 l1 的值，我们就得让上述函数返回一个新列表，再赋予 l1 即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func5</span>(<span class="params">l2</span>):</span><br><span class="line">	l2 = l2 + [<span class="number">4</span>]</span><br><span class="line">	<span class="keyword">return</span> l2</span><br><span class="line"> </span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l1 = my_func5(l1)</span><br><span class="line">l1</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>my_func3() 和 my_func5() 的用法，两者虽然写法不同，但实现的功能一致。不过，在实际工作应用中，往往倾向于类似 my_func5() 的写法，添加返回语句。</p>
<p><strong>总结：</strong></p>
<ul>
<li>如果对象是可变的，当其改变时，所有指向这个对象的变量都会改变。</li>
<li>如果对象不可变，简单的赋值只能改变其中一个变量的值，其余变量则不受影响。</li>
</ul>
<blockquote>
<p>如果你想通过一个函数来改变某个变量的值，通常有两种方法。一种是直接将可变数据类型（比如列表，字典，集合）当作参数传入，直接在其上修改；第二种则是创建一个新变量，来保存修改后的值，然后将其返回给原变量。在实际工作中，我们更倾向于使用后者，因为其表达清晰明了，不易出错。</p>
</blockquote>
<p><strong>示例程序：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">d</span>):  </span><br><span class="line">    d[<span class="string">&#x27;a&#x27;</span>] = <span class="number">10</span>  </span><br><span class="line">    d[<span class="string">&#x27;b&#x27;</span>] = <span class="number">20</span>  </span><br><span class="line">    d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;  <span class="comment"># 重新定义了新的字典，d为函数func函数内的局部变量</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    d = &#123;&#125;  </span><br><span class="line">    func(d)  </span><br><span class="line">    <span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: 10, <span class="string">&#x27;b&#x27;</span>: 20&#125;</span><br></pre></td></tr></table></figure>


<h1 id="3-装饰器"><a href="#3-装饰器" class="headerlink" title="3 装饰器"></a>3 装饰器</h1><h2 id="3-1-函数装饰器"><a href="#3-1-函数装饰器" class="headerlink" title="3.1 函数装饰器"></a>3.1 函数装饰器</h2><p>函数的基本用法包括：</p>
<ol>
<li>函数参数传递变量</li>
<li>函数当作参数传递</li>
<li>函数中嵌套函数</li>
<li>函数的返回值可以是函数对象（闭包）</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;wrapper of decorator&#x27;</span>)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">greet = my_decorator(greet)</span><br><span class="line">greet()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">wrapper of decorator</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>这段代码中，变量 greet 指向了内部函数 wrapper()，而内部函数 wrapper() 中又会调用原函数 greet()，因此，最后调用 greet() 时，就会先打印<code>&#39;wrapper of decorator&#39;</code>，然后输出<code>&#39;hello world&#39;</code>。<br>这里的函数 my_decorator() 就是一个装饰器，它把真正需要执行的函数 greet() 包裹在其中，并且改变了它的行为，但是原函数 greet() 不变。</p>
<p>事实上，上述代码在 Python 中有更简单、更优雅的表示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;wrapper of decorator&#x27;</span>)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"> </span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">greet()</span><br></pre></td></tr></table></figure>
<p>这里的<code>@</code>，我们称之为语法糖，<code>@my_decorator</code>就相当于前面的<code>greet=my_decorator(greet)</code>语句，只不过更加简洁。因此，如果你的程序中有其它函数需要做类似的装饰，你只需在它们的上方加上<code>@decorator</code>就可以了，这样就大大提高了函数的重复利用和程序的可读性。</p>
<ul>
<li><strong>带有参数的装饰器</strong></li>
</ul>
<p><code>*args</code>和<code>**kwargs</code>，表示接受任意数量和类型的参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;wrapper of decorator&#x27;</span>)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>带有自定义参数的装饰器</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repeat</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;wrapper of decorator&#x27;</span>)</span><br><span class="line">                func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> my_decorator</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@repeat(<span class="params"><span class="number">4</span></span>)  </span><span class="comment"># 先执行 repeat(4) 函数，返回的是一个装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">message</span>):</span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line"> </span><br><span class="line">greet(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">wrapper of decorator</span><br><span class="line">hello world</span><br><span class="line">wrapper of decorator</span><br><span class="line">hello world</span><br><span class="line">wrapper of decorator</span><br><span class="line">hello world</span><br><span class="line">wrapper of decorator</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>保留原函数</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">greet.__name__</span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line"><span class="string">&#x27;wrapper&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">help</span>(greet)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">Help on function wrapper <span class="keyword">in</span> module __main__:</span><br><span class="line"> </span><br><span class="line">wrapper(*args, **kwargs)</span><br></pre></td></tr></table></figure>
<p>greet() 函数被装饰以后，它的元信息变了。元信息告诉我们“它不再是以前的那个 greet() 函数，而是被 wrapper() 函数取代了”。</p>
<p>通常使用内置的装饰器<code>@functools.wrap</code>，它会帮助保留原函数的元信息（也就是将原函数的元信息，拷贝到对应的装饰器函数里）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;wrapper of decorator&#x27;</span>)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">    </span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">message</span>):</span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line"> </span><br><span class="line">greet.__name__</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="string">&#x27;greet&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-类装饰器"><a href="#3-2-类装饰器" class="headerlink" title="3.2 类装饰器"></a>3.2 类装饰器</h2><ul>
<li>类的装饰器是类方法的装饰器的缩写</li>
<li>可以通过装饰器改变方法的调用方式和行为</li>
</ul>
<h3 id="3-2-1-call-模式方法"><a href="#3-2-1-call-模式方法" class="headerlink" title="3.2.1  __call__ 模式方法"></a>3.2.1  <code>__call__</code> 模式方法</h3><p>类装饰器主要依赖于函数<code>__call_()</code>，每当你调用一个类的示例时，函数<code>__call__()</code>就会被执行一次。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Count</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line">        self.num_calls = <span class="number">0</span></span><br><span class="line">	<span class="comment"># 类默认没有 __call__ 模式方法，当增加 __call__ 方法后则可以调用类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        self.num_calls += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;num of calls is: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.num_calls))</span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Count</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">example</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"> </span><br><span class="line">example()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">num of calls <span class="keyword">is</span>: <span class="number">1</span></span><br><span class="line">hello world</span><br><span class="line"> </span><br><span class="line">example()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">num of calls <span class="keyword">is</span>: <span class="number">2</span></span><br><span class="line">hello world</span><br><span class="line"> </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>定义了类 Count，初始化时传入原函数 func()，而<code>__call__()</code>函数表示让变量 num_calls 自增 1，然后打印，并且调用原函数。因此，在我们第一次调用函数 example() 时，num_calls 的值是 1，而在第二次调用时，它的值变成了 2。</p>
<ul>
<li><strong>在函数中</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():  </span><br><span class="line">	<span class="keyword">pass</span>  </span><br><span class="line"><span class="built_in">dir</span>(func1)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;__annotations__&#x27;,</span><br><span class="line"> &#x27;__builtins__&#x27;,</span><br><span class="line"> &#x27;__call__&#x27;,  # 类中没有此方法</span><br><span class="line"> &#x27;__class__&#x27;,</span><br><span class="line"> &#x27;__closure__&#x27;,</span><br><span class="line"> &#x27;__code__&#x27;,</span><br><span class="line"> &#x27;__defaults__&#x27;,</span><br><span class="line"> &#x27;__delattr__&#x27;,</span><br><span class="line"> &#x27;__dict__&#x27;,</span><br><span class="line"> &#x27;__dir__&#x27;,</span><br><span class="line"> &#x27;__doc__&#x27;,</span><br><span class="line"> &#x27;__eq__&#x27;,</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>在类中</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Class1</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">cls = Class1()</span><br><span class="line">cls()   <span class="comment"># 报错</span></span><br></pre></td></tr></table></figure>
<p>增加 <code>__call__</code> :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Class1</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;class is run&quot;</span>)</span><br><span class="line"></span><br><span class="line">cls = Class1()</span><br><span class="line">cls()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class is run</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-classmethod-装饰器"><a href="#3-2-2-classmethod-装饰器" class="headerlink" title="3.2.2 classmethod 装饰器"></a>3.2.2 classmethod 装饰器</h3><p>classmethod 修饰的方法定义为类的方法，用于类直接调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Klass1</span>:</span><br><span class="line"><span class="meta">      @classmethod</span></span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">funcs</span>(<span class="params">cls</span>): </span><br><span class="line">           <span class="built_in">print</span>(<span class="string">&quot;Class method&quot;</span>)</span><br><span class="line">        </span><br><span class="line">Klass1.funcs()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class method</span><br></pre></td></tr></table></figure>

<p><strong>用途：</strong> <code>classmethod</code> 用于定义类方法，类方法与类相关联，而不是与类的实例相关联。它们可以访问类级别的属性和方法，但不能直接访问实例级别的属性和方法。通常用于实现与类相关的功能，而不需要创建类的实例。<br><strong>调用方式：</strong> 类方法的第一个参数通常被命名为 <code>cls</code>，它表示类本身，可以使用它来访问类的属性和调用其他类方法。类方法可以通过类名或类的实例调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    class_variable = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increment_class_variable</span>(<span class="params">cls</span>):</span><br><span class="line">        cls.class_variable += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用类方法</span></span><br><span class="line">MyClass.increment_class_variable()</span><br><span class="line"><span class="built_in">print</span>(MyClass.class_variable)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-staticmethod-装饰器"><a href="#3-2-3-staticmethod-装饰器" class="headerlink" title="3.2.3 staticmethod 装饰器"></a>3.2.3 staticmethod 装饰器</h3><ul>
<li><strong>用途：</strong> <code>staticmethod</code> 用于定义静态方法，静态方法与类相关联，但不依赖于类的实例。它们不能访问类级别的属性或实例级别的属性。通常用于实现与类相关但不需要访问实例状态的功能。</li>
<li><strong>调用方式：</strong> 静态方法没有特殊的参数，可以通过类名或类的实例调用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MathUtils</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> self.add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># 实例方法可以直接调用静态方法和类方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用静态方法</span></span><br><span class="line">result = MathUtils.add(<span class="number">5</span>, <span class="number">3</span>)  <span class="comment"># 8</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-4-classmethod-和-staticmethod的区别"><a href="#3-2-4-classmethod-和-staticmethod的区别" class="headerlink" title="3.2.4 classmethod 和 staticmethod的区别"></a>3.2.4 <code>classmethod</code> 和 <code>staticmethod</code>的区别</h3><ul>
<li><p>主要区别在于能否访问类属性和实例属性。类方法可以访问类属性，但不能访问实例属性，而静态方法既不能访问类属性也不能访问实例属性。</p>
</li>
<li><p>使用 <code>classmethod</code> 主要是为了在方法内部操作类级别的属性或实现与类相关的逻辑，而使用 <code>staticmethod</code> 主要是为了封装与类相关但与实例无关的功能。</p>
</li>
<li><p>如果你需要在方法内部访问或修改类级别的属性，或者需要与类相关的操作，使用 <code>classmethod</code>。如果方法不依赖于类或实例的状态，使用 <code>staticmethod</code>。</p>
</li>
</ul>
<h3 id="3-2-5-property-修饰器"><a href="#3-2-5-property-修饰器" class="headerlink" title="3.2.5 property 修饰器"></a>3.2.5 property 修饰器</h3><p><code>property</code> 修饰器是一种用于创建属性的特殊装饰器，它允许你定义一个方法，这个方法可以像访问属性一样被调用，而不需要使用函数调用的方式。这样可以隐藏属性的内部实现细节，同时可以提供更多的控制和验证。</p>
<ol>
<li><strong>创建只读属性</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, radius</span>):</span><br><span class="line">        self._radius = radius</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radius</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._radius</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Circle 类的实例</span></span><br><span class="line">circle = Circle(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 访问只读属性</span></span><br><span class="line"><span class="built_in">print</span>(circle.radius)</span><br><span class="line"><span class="comment"># 尝试修改属性会引发 AttributeError</span></span><br><span class="line"><span class="comment"># circle.radius = 10  # 这会引发 AttributeError</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>创建可读写属性</strong></li>
</ol>
<p>提供一个与属性同名的setter方法，用户设置属性的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, radius</span>):</span><br><span class="line">        self._radius = radius</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radius</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._radius</span><br><span class="line"></span><br><span class="line"><span class="meta">    @radius.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radius</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Radius cannot be negative&quot;</span>)</span><br><span class="line">        self._radius = value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Circle 类的实例</span></span><br><span class="line">circle = Circle(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 访问可读写属性</span></span><br><span class="line"><span class="built_in">print</span>(circle.radius)</span><br><span class="line"><span class="comment"># 设置属性的值</span></span><br><span class="line">circle.radius = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(circle.radius)</span><br></pre></td></tr></table></figure>
<p>定义<code>@property</code>和<code>@radius.setter</code>是配对出现，不可直接定义<code>@radius.setter</code>。</p>
<ol start="3">
<li><strong>创建可删除属性</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, radius</span>):</span><br><span class="line">        self._radius = radius</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radius</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._radius</span><br><span class="line"></span><br><span class="line"><span class="meta">    @radius.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radius</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Radius cannot be negative&quot;</span>)</span><br><span class="line">        self._radius = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @radius.deleter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radius</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Deleting radius&quot;</span>)</span><br><span class="line">        <span class="keyword">del</span> self._radius</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Circle 类的实例</span></span><br><span class="line">circle = Circle(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 删除属性</span></span><br><span class="line"><span class="keyword">del</span> circle.radius</span><br></pre></td></tr></table></figure>
<p>在执行 del 属性时，会自动执行 deleter 属性方法。可删除属性可以做一些实例收尾操作，比如连接数据库，在清理数据库连接时。</p>
<blockquote>
<p>通过使用 <code>property</code>可以隐藏内部实现细节，封装属性的访问和修改，从而提供更多的控制和验证。在定义时常用下划线前缀（例如<code>_radius</code>）来表示属性是受保护的。</p>
</blockquote>
<h2 id="3-3-装饰器的嵌套"><a href="#3-3-装饰器的嵌套" class="headerlink" title="3.3 装饰器的嵌套"></a>3.3 装饰器的嵌套</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator1</span></span><br><span class="line"><span class="meta">@decorator2</span></span><br><span class="line"><span class="meta">@decorator3</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>执行顺序从里到外，上边的代码等价如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decorator1(decorator2(decorator3(func)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator1</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;execute decorator1&#x27;</span>)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator2</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;execute decorator2&#x27;</span>)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@my_decorator1</span></span><br><span class="line"><span class="meta">@my_decorator2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">message</span>):</span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">greet(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">execute decorator1</span><br><span class="line">execute decorator2</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<h2 id="3-4-装饰器的应用实例"><a href="#3-4-装饰器的应用实例" class="headerlink" title="3.4 装饰器的应用实例"></a>3.4 装饰器的应用实例</h2><h3 id="3-4-1-身份认证"><a href="#3-4-1-身份认证" class="headerlink" title="3.4.1 身份认证"></a>3.4.1 身份认证</h3><p>在某函数执行前做身份认证，如果未认证则抛出异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">authenticate</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        request = args[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> check_user_logged_in(request): <span class="comment"># 如果用户处于登录状态</span></span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs) <span class="comment"># 执行函数 post_comment() </span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;Authentication failed&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">    </span><br><span class="line"><span class="meta">@authenticate</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">post_comment</span>(<span class="params">request, ...</span>)</span><br><span class="line">    ...</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="3-4-2-日志记录"><a href="#3-4-2-日志记录" class="headerlink" title="3.4.2 日志记录"></a>3.4.2 日志记录</h3><p>统计日志记录某函数的执行时间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_execution_time</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start = time.perf_counter()</span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        end = time.perf_counter()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; took &#123;&#125; ms&#x27;</span>.<span class="built_in">format</span>(func.__name__, (end - start) * <span class="number">1000</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">    </span><br><span class="line"><span class="meta">@log_execution_time</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_similarity</span>(<span class="params">items</span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>装饰器 log_execution_time 记录某个函数的运行时间，并返回其执行结果。如果你想计算任何函数的执行时间，在这个函数上方加上<code>@log_execution_time</code>即可。</p>
<h3 id="3-4-3-输入合理性检查"><a href="#3-4-3-输入合理性检查" class="headerlink" title="3.4.3 输入合理性检查"></a>3.4.3 输入合理性检查</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">validation_check</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>): </span><br><span class="line">        ... <span class="comment"># 检查输入是否合法</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@validation_check</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">neural_network_training</span>(<span class="params">param1, param2, ...</span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h3 id="3-4-4-缓存"><a href="#3-4-4-缓存" class="headerlink" title="3.4.4 缓存"></a>3.4.4 缓存</h3><p>LRU cache，在 Python 中的表示形式是<code>@lru_cache</code>。<code>@lru_cache</code>会缓存进程中的函数参数和结果，当缓存满了以后，会删除 least recenly used 的数据。<br>使用缓存装饰器，来包裹这些检查函数，避免其被反复调用，进而提高程序运行效率，比如写成下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="meta">@lru_cache</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">param1, param2, ...</span>) <span class="comment"># 检查用户设备类型，版本号等等</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>通过使用 <code>lru_cache</code> 提升斐波那契数列计算时间<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/202309221129781.png"></p>
<h1 id="4-metaclass"><a href="#4-metaclass" class="headerlink" title="4 metaclass"></a>4 metaclass</h1><h2 id="4-1-type类"><a href="#4-1-type类" class="headerlink" title="4.1 type类"></a>4.1 type类</h2><p>所有的 Python 的用户定义类，都是 type 这个类的实例，在Python中type这个类就是造物的上帝，可以通过如下代码查看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 3 和 Python 2 类似</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line">instance = MyClass()</span><br><span class="line"> </span><br><span class="line"><span class="built_in">type</span>(instance)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.C&#x27;</span>&gt;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">type</span>(MyClass)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>用户自定义类，只不过是 type 类的<code>__call__</code>运算符重载</strong></li>
</ul>
<p>当我们定义一个类的语句结束时，真正发生的情况，是 Python 调用 type 的<code>__call__</code>运算符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">  data = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>Python真正执行的是下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> = <span class="built_in">type</span>(classname, superclasses, attributedict)</span><br></pre></td></tr></table></figure>

<p>这里等号右边的<code>type(classname, superclasses, attributedict)</code>，就是 type 的<code>__call__</code>运算符重载，它会进一步调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>.__new__(typeclass, classname, superclasses, attributedict)</span><br><span class="line"><span class="built_in">type</span>.__init__(<span class="keyword">class</span>, classname, superclasses, attributedict)</span><br></pre></td></tr></table></figure>

<p>通过type定义MyClass类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">  data = <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">instance = MyClass()</span><br><span class="line">MyClass, instance</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">(__main__.MyClass, &lt;__main__.MyClass instance at <span class="number">0x7fe4f0b00ab8</span>&gt;)</span><br><span class="line">instance.data</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"> </span><br><span class="line">MyClass = <span class="built_in">type</span>(<span class="string">&#x27;MyClass&#x27;</span>, (), &#123;<span class="string">&#x27;data&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line">instance = MyClass()</span><br><span class="line">MyClass, instance</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">(__main__.MyClass, &lt;__main__.MyClass at <span class="number">0x7fe4f0aea5d0</span>&gt;)</span><br><span class="line"> </span><br><span class="line">instance.data</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>通过上面可以看到，正常的 MyClass 定义，和手工去调用 type 运算符的结果是完全一样的。</p>
<p><strong>示例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class_body = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">def greeting(self):</span></span><br><span class="line"><span class="string">    print(&#x27;Hello customer&#x27;)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">def jump(self):</span></span><br><span class="line"><span class="string">    print(&#x27;jump&#x27;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">class_dict = &#123;&#125;</span><br><span class="line"><span class="built_in">exec</span>(class_body, <span class="built_in">globals</span>(), class_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># type的第三个参数是具体类的属性，是一个字典</span></span><br><span class="line">Customer = <span class="built_in">type</span>(<span class="string">&quot;Customer&quot;</span>, (<span class="built_in">object</span>,), class_dict)</span><br><span class="line"></span><br><span class="line">c = Customer()</span><br><span class="line">c.greeting()</span><br><span class="line">c.jump()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello customer</span><br><span class="line">jump</span><br></pre></td></tr></table></figure>
<p>以上代码，通过type类实现了一个<code>Customer</code>类，通过字符串内容定义了类的属性，使用此方法，可以实现动态定义类。</p>
<h2 id="4-2-metaclass的使用"><a href="#4-2-metaclass的使用" class="headerlink" title="4.2 metaclass的使用"></a>4.2 metaclass的使用</h2><p>把一个类型 MyClass 的 metaclass 设置成 MyMeta，MyClass 就不再由原生的 type 创建，而是会调用 MyMeta 的<code>__call__</code>运算符重载。</p>
<p><strong>自定义metaclass类创建类：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span>(<span class="title class_ inherited__">type</span>):  </span><br><span class="line"><span class="meta">    @staticmethod  </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, *args, **kwargs</span>):  </span><br><span class="line">        class_ = <span class="built_in">super</span>().__new__(mcs, *args)  </span><br><span class="line">        <span class="comment"># class_.freedom = True  </span></span><br><span class="line">        <span class="keyword">if</span> kwargs:  </span><br><span class="line">            <span class="keyword">for</span> name, value <span class="keyword">in</span> kwargs.items():  </span><br><span class="line">                <span class="built_in">setattr</span>(class_, name, value)  </span><br><span class="line">        <span class="keyword">return</span> class_  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="built_in">object</span>, metaclass=Human, country=<span class="string">&quot;China&quot;</span>, freedom=<span class="literal">True</span>):  </span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(Student.country)  <span class="comment"># China</span></span><br><span class="line"><span class="built_in">print</span>(Student.freedom)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>


<h1 id="5-迭代器和生成器"><a href="#5-迭代器和生成器" class="headerlink" title="5 迭代器和生成器"></a>5 迭代器和生成器</h1><h2 id="5-1-迭代器"><a href="#5-1-迭代器" class="headerlink" title="5.1 迭代器"></a>5.1 迭代器</h2><p>可迭代对象，通过 iter() 函数返回一个迭代器，再通过 next() 函数就可以实现遍历。for in 语句将这个过程隐式化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_iterable</span>(<span class="params">param</span>):</span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        <span class="built_in">iter</span>(param) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> TypeError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"> </span><br><span class="line">params = [</span><br><span class="line">    <span class="number">1234</span>,</span><br><span class="line">    <span class="string">&#x27;1234&#x27;</span>,</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]),</span><br><span class="line">    &#123;<span class="number">1</span>:<span class="number">1</span>, <span class="number">2</span>:<span class="number">2</span>, <span class="number">3</span>:<span class="number">3</span>, <span class="number">4</span>:<span class="number">4</span>&#125;,</span><br><span class="line">    (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">]</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; is iterable? &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(param, is_iterable(param)))</span><br><span class="line"> </span><br><span class="line"><span class="comment">########## 输出 ##########</span></span><br><span class="line"> </span><br><span class="line"><span class="number">1234</span> <span class="keyword">is</span> iterable? <span class="literal">False</span></span><br><span class="line"><span class="number">1234</span> <span class="keyword">is</span> iterable? <span class="literal">True</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] <span class="keyword">is</span> iterable? <span class="literal">True</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; <span class="keyword">is</span> iterable? <span class="literal">True</span></span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">3</span>, <span class="number">4</span>: <span class="number">4</span>&#125; <span class="keyword">is</span> iterable? <span class="literal">True</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="keyword">is</span> iterable? <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>列表转换成迭代器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]  </span><br><span class="line">l2 = <span class="built_in">iter</span>(l1)  </span><br><span class="line"><span class="built_in">print</span>(l1)   <span class="comment"># [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">print</span>(l2)   <span class="comment"># &lt;list_iterator object at 0x104887010&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="5-2-生成器"><a href="#5-2-生成器" class="headerlink" title="5.2 生成器"></a>5.2 生成器</h2><h3 id="5-2-1-生成器的使用"><a href="#5-2-1-生成器的使用" class="headerlink" title="5.2.1 生成器的使用"></a>5.2.1 生成器的使用</h3><p><strong>生成器是懒人版本的迭代器</strong>，在迭代器中，如果我们想要枚举它的元素，这些元素需要事先生成，但是生成器，是在调用 <code>next()</code>函数的时候，才会生成下一个变量，并不需要在内存中同时保存太多值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"><span class="keyword">import</span> psutil  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 显示当前 python 程序占用的内存大小  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_memory_info</span>(<span class="params">hint</span>):  </span><br><span class="line">    pid = os.getpid()  </span><br><span class="line">    p = psutil.Process(pid)  </span><br><span class="line">  </span><br><span class="line">    info = p.memory_full_info()  </span><br><span class="line">    memory = info.uss / <span class="number">1024.</span> / <span class="number">1024</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; memory used: &#123;&#125; MB&#x27;</span>.<span class="built_in">format</span>(hint, memory))  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_iterator</span>():  </span><br><span class="line">    show_memory_info(<span class="string">&#x27;initing iterator&#x27;</span>)  </span><br><span class="line">    list_1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>)]  </span><br><span class="line">    show_memory_info(<span class="string">&#x27;after iterator initiated&#x27;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(list_1))  </span><br><span class="line">    show_memory_info(<span class="string">&#x27;after sum called&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_generator</span>():  </span><br><span class="line">    show_memory_info(<span class="string">&#x27;initing generator&#x27;</span>)  </span><br><span class="line">    list_2 = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>))  </span><br><span class="line">    show_memory_info(<span class="string">&#x27;after generator initiated&#x27;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(list_2))  </span><br><span class="line">    show_memory_info(<span class="string">&#x27;after sum called&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">test_iterator()  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)  </span><br><span class="line">test_generator()</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">initing iterator memory used: 9.34375 MB</span><br><span class="line">after iterator initiated memory used: 1146.734375 MB</span><br><span class="line">4999999950000000</span><br><span class="line">after sum called memory used: 3452.4375 MB</span><br><span class="line"></span><br><span class="line">initing generator memory used: 4.578125 MB</span><br><span class="line">after generator initiated memory used: 4.609375 MB</span><br><span class="line">4999999950000000</span><br><span class="line">after sum called memory used: 4.609375 MB</span><br></pre></td></tr></table></figure>
<p>使用生成器时，不需要在内存中同时保存对元素求和，我们只需要知道每个元素在相加的那一刻是多少就行了，用完就可以扔掉了。<br>相对迭代器，使用生成器省掉更多的内存。</p>
<h3 id="5-2-2-生成器更多用法"><a href="#5-2-2-生成器更多用法" class="headerlink" title="5.2.2 生成器更多用法"></a>5.2.2 生成器更多用法</h3><p>含有yield的函数，会返回一个生成器，每次执行到yield，会把对应的值返回出去，并且函数暂停，等待下次被唤醒。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generator</span>(<span class="params">k</span>):  </span><br><span class="line">    i = <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        <span class="keyword">yield</span> i ** k  </span><br><span class="line">        i += <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">gen_1 = generator(<span class="number">1</span>)  </span><br><span class="line">gen_3 = generator(<span class="number">3</span>)  </span><br><span class="line"><span class="built_in">print</span>(gen_1)  </span><br><span class="line"><span class="built_in">print</span>(gen_3)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_sum</span>(<span class="params">n</span>):  </span><br><span class="line">    sum_1, sum_3 = <span class="number">0</span>, <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  </span><br><span class="line">        next_1 = <span class="built_in">next</span>(gen_1)  </span><br><span class="line">        next_3 = <span class="built_in">next</span>(gen_3)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;next_1 = &#123;&#125;, next_3 = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(next_1, next_3))  </span><br><span class="line">        sum_1 += next_1  </span><br><span class="line">        sum_3 += next_3  </span><br><span class="line">    <span class="built_in">print</span>(sum_1, sum_3)  </span><br><span class="line">  </span><br><span class="line">get_sum(<span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<p>generator() 这个函数，返回了一个生成器，执行到yield时程序会从这里暂停，每次 next(gen) 函数被调用的时候，暂停的程序就又复活了，从 yield 这里向下继续执行。通过yield实现了返回了一个k次幂的生成器。</p>
<p>下边看一个使用生成器，确认target元素在列表的位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">index_generator</span>(<span class="params">L, target</span>):</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(L):</span><br><span class="line">        <span class="keyword">if</span> num == target:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(index_generator([<span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>], <span class="number">2</span>)))</span><br></pre></td></tr></table></figure>
<p>以上 index_generator 返回了一个生成器，然后使用 list 转换为列表，默认会执行 遍历生成器的元素。</p>
<h3 id="5-2-3-使用生成器实现判断子序列"><a href="#5-2-3-使用生成器实现判断子序列" class="headerlink" title="5.2.3 使用生成器实现判断子序列"></a>5.2.3 使用生成器实现判断子序列</h3><p>给定两个序列，判定第一个是不是第二个的子序列：序列就是列表，子序列则指的是，一个列表的元素在第二个列表中都按顺序出现，但是并不必挨在一起。举个例子，[1, 3, 5] 是 [1, 2, 3, 4, 5] 的子序列，[1, 4, 3] 则不是。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_subsequence</span>(<span class="params">a, b</span>):</span><br><span class="line">    b = <span class="built_in">iter</span>(b)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">all</span>(i <span class="keyword">in</span> b <span class="keyword">for</span> i <span class="keyword">in</span> a)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(is_subsequence([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br><span class="line"><span class="built_in">print</span>(is_subsequence([<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br></pre></td></tr></table></figure>
<p>代码注解：</p>
<ol>
<li>is_subsequence 函数先把 b 转换为迭代器</li>
<li>通过 <code>(i for i in a)</code> 会生成一个生成器</li>
<li>通过 <code>(i in b)</code> 判断 i 是否在 列表 b 中，如果在 b 中则返回 True，若不在则返回 Flase。最后返回一个含有多个 bool值的列表。</li>
<li>最后的 all() 函数用来判断一个迭代器的元素是否全部为 True，如果是则返回 True，否则就返回 False。</li>
</ol>
<p>具体解释下 <code>(i in b)</code> 大概等价于下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    val = <span class="built_in">next</span>(b)</span><br><span class="line">    <span class="keyword">if</span> val == i:</span><br><span class="line">        <span class="keyword">yield</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>利用生成器的特性，next() 函数运行的时候，<strong>保存了当前的指针</strong>，如下示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">b = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> <span class="keyword">in</span> b)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">4</span> <span class="keyword">in</span> b)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">in</span> b)</span><br><span class="line"> </span><br><span class="line"><span class="comment">########## 输出 ##########</span></span><br><span class="line"> </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span> </span><br></pre></td></tr></table></figure>

<h1 id="6-并发编程–Python-协程"><a href="#6-并发编程–Python-协程" class="headerlink" title="6 并发编程–Python 协程"></a>6 并发编程–Python 协程</h1><h2 id="6-1-asyncio使用"><a href="#6-1-asyncio使用" class="headerlink" title="6.1 asyncio使用"></a>6.1 asyncio使用</h2><p>协程事件循环：<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/%E6%88%AA%E5%B1%8F2023-10-22%2018.15.17.png"></p>
<p>在Python 3.7 基于 asyncio 和 async &#x2F; await 的方法使用协程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">crawl_page</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;crawling &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(url))</span><br><span class="line">    sleep_time = <span class="built_in">int</span>(url.split(<span class="string">&#x27;_&#x27;</span>)[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sleep_time)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;OK &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(url))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">urls</span>):</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        <span class="keyword">await</span> crawl_page(url)</span><br><span class="line"> </span><br><span class="line">%time asyncio.run(main([<span class="string">&#x27;url_1&#x27;</span>, <span class="string">&#x27;url_2&#x27;</span>, <span class="string">&#x27;url_3&#x27;</span>, <span class="string">&#x27;url_4&#x27;</span>]))</span><br><span class="line"> </span><br><span class="line"><span class="comment">########## 输出 ##########</span></span><br><span class="line"> </span><br><span class="line">crawling url_1</span><br><span class="line">OK url_1</span><br><span class="line">crawling url_2</span><br><span class="line">OK url_2</span><br><span class="line">crawling url_3</span><br><span class="line">OK url_3</span><br><span class="line">crawling url_4</span><br><span class="line">OK url_4</span><br><span class="line">Wall time: <span class="number">10</span> s</span><br></pre></td></tr></table></figure>
<p>在函数前通过 async 定义了协程函数，使用 await 把协程函数加入事件循环，并等待协程函数完成，使用 asyncio.run 执行协程函数。<br>如果你 <code>print(crawl_page(&#39;&#39;))</code>，便会输出<code>&lt;coroutine object crawl_page at 0x000002BEDF141148&gt;</code>，提示你这是一个 Python 的协程对象，而并不会真正执行这个函数。</p>
<h2 id="6-2-asyncio创建任务"><a href="#6-2-asyncio创建任务" class="headerlink" title="6.2 asyncio创建任务"></a>6.2 asyncio创建任务</h2><p>以上方式在main中直接使用 await 调用协程函数，会让main函数阻塞，程序执行完的总时间是所有协程函数执行时间之和，下边使用asyncio创建任务执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">call_api</span>(<span class="params">name: <span class="built_in">str</span>, delay: <span class="built_in">float</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> - step 1&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> - step 2&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    time_1 = time.perf_counter()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start A coroutine&quot;</span>)</span><br><span class="line">    task_1 = asyncio.create_task(call_api(<span class="string">&quot;A&quot;</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start B coroutine&quot;</span>)</span><br><span class="line">    task_2 = asyncio.create_task(call_api(<span class="string">&quot;B&quot;</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> task_1</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task 1 completed&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> task_2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;task 2 completed&quot;</span>)</span><br><span class="line"></span><br><span class="line">    time_2 = time.perf_counter()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Spent <span class="subst">&#123;time_2 - time_1&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">start A coroutine</span><br><span class="line">start B coroutine</span><br><span class="line">A - step 1</span><br><span class="line">B - step 1</span><br><span class="line">A - step 2</span><br><span class="line">task 1 completed</span><br><span class="line">B - step 2</span><br><span class="line">task 2 completed</span><br><span class="line">Spent 5.002599277999252</span><br></pre></td></tr></table></figure>

<p>通过<code>asyncio.create_task</code>只是把协程函数放到队列中，直接返回，然后由时间循环进行调度执行，使用 await 等待任务执行完毕，以上方式执行总时间是所有协程函数最长的那个。</p>
<h2 id="6-3-asyncio进阶用法"><a href="#6-3-asyncio进阶用法" class="headerlink" title="6.3 asyncio进阶用法"></a>6.3 asyncio进阶用法</h2><p>把正在执行的任务取消、判断任务是否完成、为任务设置超时时间等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> asyncio.exceptions <span class="keyword">import</span> TimeoutError</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">play_music</span>(<span class="params">music: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Start playing <span class="subst">&#123;music&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Finished playing <span class="subst">&#123;music&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> music</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">call_api</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;calling api.....&quot;</span>)</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;Error calling&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_cancel</span>():</span><br><span class="line">    task = asyncio.create_task(play_music(<span class="string">&quot;A&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> task.done():</span><br><span class="line">        task.cancel()  <span class="comment"># 取消任务</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_cancel_with_timeout</span>():</span><br><span class="line">    task = asyncio.create_task(play_music(<span class="string">&quot;B&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait_for(task, timeout=<span class="number">2</span>)  <span class="comment"># 任务超时会抛出异常后自动取消</span></span><br><span class="line">    <span class="keyword">except</span> TimeoutError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_timeout</span>():</span><br><span class="line">    task = asyncio.create_task(play_music(<span class="string">&quot;B&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait_for(asyncio.shield(task), timeout=<span class="number">2</span>)  <span class="comment"># 任务超时抛出异常，但不取消任务</span></span><br><span class="line">    <span class="keyword">except</span> TimeoutError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> task   <span class="comment"># 任务超时，正常执行完退出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_gather</span>():</span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(play_music(<span class="string">&quot;A&quot;</span>), play_music(<span class="string">&quot;B&quot;</span>))  <span class="comment"># 等待多个协程执行完成，并获取协程执行结果</span></span><br><span class="line">    <span class="built_in">print</span>(results)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_gather_with_exception</span>():</span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(play_music(<span class="string">&quot;A&quot;</span>), play_music(<span class="string">&quot;B&quot;</span>), call_api(),</span><br><span class="line">                                   return_exceptions=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(results) <span class="comment"># 设置 return_exceptions 获取异常协程的结果，如果不设置，则任意一个协程抛出异常，则程序异常退出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    asyncio.run(my_gather_with_exception())</span><br></pre></td></tr></table></figure>
<ol>
<li><code>task.cancel()</code> 取消任务</li>
<li><code>task.done()</code> 任务完成为True，否则为 Flase</li>
<li><code>asyncio.wait_for</code> 为任务设置超时时间</li>
<li><code>asyncio.gather</code> 获取多个协程执行结果，若有一个协程异常则退出，设置<code>return_exceptions=True</code> 则不退出，正常获取协程异常结果</li>
</ol>
<h2 id="6-4-实战和总结"><a href="#6-4-实战和总结" class="headerlink" title="6.4 实战和总结"></a>6.4 实战和总结</h2><p>通过协程实现获取豆瓣数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_content</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(</span><br><span class="line">        headers=header, connector=aiohttp.TCPConnector(ssl=<span class="literal">False</span>)</span><br><span class="line">    ) <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> response.text()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    url = <span class="string">&quot;https://movie.douban.com/cinema/later/beijing/&quot;</span></span><br><span class="line">    init_page = <span class="keyword">await</span> fetch_content(url)</span><br><span class="line">    init_soup = BeautifulSoup(init_page, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">    movie_names, urls_to_fetch, movie_dates = [], [], []</span><br><span class="line"> </span><br><span class="line">    all_movies = init_soup.find(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">id</span>=<span class="string">&quot;showing-soon&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> each_movie <span class="keyword">in</span> all_movies.find_all(<span class="string">&#x27;div&#x27;</span>, class_=<span class="string">&quot;item&quot;</span>):</span><br><span class="line">        all_a_tag = each_movie.find_all(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        all_li_tag = each_movie.find_all(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">        movie_names.append(all_a_tag[<span class="number">1</span>].text)</span><br><span class="line">        urls_to_fetch.append(all_a_tag[<span class="number">1</span>][<span class="string">&#x27;href&#x27;</span>])</span><br><span class="line">        movie_dates.append(all_li_tag[<span class="number">0</span>].text)</span><br><span class="line"> </span><br><span class="line">    tasks = [fetch_content(url) <span class="keyword">for</span> url <span class="keyword">in</span> urls_to_fetch]</span><br><span class="line">    pages = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> movie_name, movie_date, page <span class="keyword">in</span> <span class="built_in">zip</span>(movie_names, movie_dates, pages):</span><br><span class="line">        soup_item = BeautifulSoup(page, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">        img_tag = soup_item.find(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; &#123;&#125; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(movie_name, movie_date, img_tag[<span class="string">&#x27;src&#x27;</span>]))</span><br><span class="line"> </span><br><span class="line">%time asyncio.run(main())</span><br><span class="line"> </span><br><span class="line"><span class="comment">########## 输出 ##########</span></span><br><span class="line"> </span><br><span class="line">阿拉丁 05 月 <span class="number">24</span> 日 https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2553992741.jpg</span><br><span class="line">龙珠超：布罗利 05 月 <span class="number">24</span> 日 https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2557371503.jpg</span><br><span class="line">五月天人生无限公司 05 月 <span class="number">24</span> 日 https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2554324453.jpg</span><br><span class="line"><span class="meta">... </span>...</span><br><span class="line">直播攻略 06 月 04 日 https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2555957974.jpg</span><br><span class="line">Wall time: <span class="number">4.98</span> s</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>协程和多线程的区别，主要在于两点，一是协程为单线程；二是协程由用户决定，在哪些地方交出控制权，切换到下一个任务。</li>
<li>协程的写法更加简洁清晰，把 async &#x2F; await 语法和 create_task 结合来用，对于中小级别的并发需求已经毫无压力。</li>
<li>写协程程序的时候，你的脑海中要有清晰的事件循环概念，知道程序在什么时候需要暂停、等待 I&#x2F;O，什么时候需要一并执行到底。</li>
</ul>
<h1 id="7-并发编程–多线程"><a href="#7-并发编程–多线程" class="headerlink" title="7 并发编程–多线程"></a>7 并发编程–多线程</h1><h2 id="7-1-线程"><a href="#7-1-线程" class="headerlink" title="7.1 线程"></a>7.1 线程</h2><p>使用 <code>Thread</code> 创建线程，示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">count: <span class="built_in">int</span></span>):  </span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(count):  </span><br><span class="line">        <span class="built_in">print</span>(n)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">thread1 = Thread(target=task, args=(<span class="number">10</span>,))  </span><br><span class="line">thread2 = Thread(target=task, args=(<span class="number">20</span>,))  </span><br><span class="line"></span><br><span class="line">thread1.daemon = <span class="literal">True</span>  <span class="comment"># 创建守护线程</span></span><br><span class="line">thread2.daemon = <span class="literal">True</span> </span><br><span class="line"></span><br><span class="line">thread1.start()  </span><br><span class="line">thread2.start()  </span><br><span class="line">  </span><br><span class="line">thread1.join()  <span class="comment"># 等待线程结束</span></span><br><span class="line">thread2.join()  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Main threads is end&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>以上默认创建的是 非守护线程，执行<code>thread1.daemon = True</code>设置成守护线程， 主线程需要使用 join 等待守护线程结束，否则主程序结束后，线程可能未执行完。</p>
<ul>
<li>守护线程会在主线程结束时候自动结束</li>
<li>主线程需要等到所有非守护线程结束才能结束（默认创建的为非守护线程）</li>
<li>守护线程一般用于执行后台任务和服务，如日志记录、监控、定时任务等</li>
</ul>
<h2 id="7-2-线程安全队列"><a href="#7-2-线程安全队列" class="headerlink" title="7.2 线程安全队列"></a>7.2 线程安全队列</h2><p>queue模块中的Queue类提供了线程安全队列功能：</p>
<ol>
<li>queue.put(item, block&#x3D;False)  非阻塞写入数据到队列</li>
<li>queue.put(item, timeout&#x3D;3)    阻塞超时3s</li>
<li>queue.get(block&#x3D;False)</li>
<li>queue.get(timeout&#x3D;10)</li>
<li>queue.qsize()</li>
<li>queue.empty()</li>
<li>queue.full()</li>
</ol>
<p>通过继承 Thread 类创建线程，实现生产者和消费者：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgProducer</span>(<span class="title class_ inherited__">Thread</span>):  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name: <span class="built_in">str</span>, count: <span class="built_in">int</span>, queue: Queue</span>):  </span><br><span class="line">        <span class="built_in">super</span>().__init__()  </span><br><span class="line">  </span><br><span class="line">        self.name = name  </span><br><span class="line">        self.count = count  </span><br><span class="line">        self.queue = queue  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:  </span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(self.count):  </span><br><span class="line">            msg = <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> - <span class="subst">&#123;n&#125;</span>&quot;</span>  </span><br><span class="line">            self.queue.put(msg, block=<span class="literal">True</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgConsumer</span>(<span class="title class_ inherited__">Thread</span>):  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name: <span class="built_in">str</span>, queue: Queue</span>):  </span><br><span class="line">        <span class="built_in">super</span>().__init__()  </span><br><span class="line">  </span><br><span class="line">        self.name = name  </span><br><span class="line">        self.queue = queue  </span><br><span class="line">        self.daemon = <span class="literal">True</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:  </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">            msg = self.queue.get(block=<span class="literal">True</span>)  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> - <span class="subst">&#123;msg&#125;</span>\n&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)  <span class="comment"># 取消print默认带的换行符</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">queue = Queue(<span class="number">3</span>)  </span><br><span class="line">threads = <span class="built_in">list</span>()  </span><br><span class="line">threads.append(MsgProducer(<span class="string">&quot;PA&quot;</span>, <span class="number">10</span>, queue))  </span><br><span class="line">threads.append(MsgProducer(<span class="string">&quot;PB&quot;</span>, <span class="number">10</span>, queue))  </span><br><span class="line">threads.append(MsgProducer(<span class="string">&quot;PC&quot;</span>, <span class="number">10</span>, queue))  </span><br><span class="line">  </span><br><span class="line">threads.append(MsgConsumer(<span class="string">&quot;CA&quot;</span>, queue))  </span><br><span class="line">threads.append(MsgConsumer(<span class="string">&quot;CB&quot;</span>, queue))  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:  </span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>

<p>以上消费者线程设置为了守护线程，会等到所有生产者线程和主线程结束后，自动结束。run函数表示线程要执行的逻辑，主线程中创建了3个生产者线程和2个消费者线程。</p>
<h2 id="7-3-线程锁"><a href="#7-3-线程锁" class="headerlink" title="7.3 线程锁"></a>7.3 线程锁</h2><p>使用Lock让线程顺序执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock, Condition  </span><br><span class="line"></span><br><span class="line">task_lock = Lock()  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name: <span class="built_in">str</span></span>):  </span><br><span class="line">    <span class="keyword">global</span> task_lock  </span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):  </span><br><span class="line">        task_lock.acquire()  <span class="comment"># 获取锁</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> - round <span class="subst">&#123;n&#125;</span> - step 1\n&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> - round <span class="subst">&#123;n&#125;</span> - step 2\n&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> - round <span class="subst">&#123;n&#125;</span> - step 3\n&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)  </span><br><span class="line">        task_lock.release()  <span class="comment"># 释放锁</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">t1 = Thread(target=task, args=(<span class="string">&quot;A&quot;</span>,))  </span><br><span class="line">t2 = Thread(target=task, args=(<span class="string">&quot;B&quot;</span>,))  </span><br><span class="line">t3 = Thread(target=task, args=(<span class="string">&quot;C&quot;</span>,))  </span><br><span class="line">  </span><br><span class="line">t1.start()  </span><br><span class="line">t2.start()  </span><br><span class="line">t3.start()</span><br></pre></td></tr></table></figure>
<p>以上三个线程将依次执行task函数。</p>
<p>基于 list 自定义实现一个安全队列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock, Condition</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeQueue</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, size: <span class="built_in">int</span></span>):  </span><br><span class="line">        self.__item_list = <span class="built_in">list</span>()  </span><br><span class="line">        self.size = size  </span><br><span class="line">        self.__item_lock = Condition()  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, item</span>):  </span><br><span class="line">        <span class="keyword">with</span> self.__item_lock:  <span class="comment"># 使用with语句加锁，多线程可以并发访问 </span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(self.__item_list) &gt;= self.size:  </span><br><span class="line">                self.__item_lock.wait()  <span class="comment"># 队列满，阻塞等待</span></span><br><span class="line">  </span><br><span class="line">            self.__item_list.insert(<span class="number">0</span>, item)  </span><br><span class="line">            self.__item_lock.notify_all()  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">with</span> self.__item_lock:  </span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(self.__item_list) == <span class="number">0</span>:  </span><br><span class="line">                self.__item_lock.wait()  <span class="comment"># 队列空，阻塞等待</span></span><br><span class="line">  </span><br><span class="line">            result = self.__item_list.pop()  </span><br><span class="line">            self.__item_lock.notify_all()  <span class="comment"># 通知所有wait的线程</span></span><br><span class="line">  </span><br><span class="line">            <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>


<h2 id="7-4-线程池"><a href="#7-4-线程池" class="headerlink" title="7.4 线程池"></a>7.4 线程池</h2><p>线程的创建和销毁相对比较昂贵，频繁的创建和销毁线程不利于高性能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name: <span class="built_in">str</span></span>):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> - step 1\n&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)  </span><br><span class="line">    time.sleep(<span class="number">1</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> - step 2\n&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;name&#125;</span> complete&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个ThreadPoolExecutor，设置max_workers指定线程池的大小</span></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> executor:</span><br><span class="line">	<span class="comment"># 提交任务给线程池</span></span><br><span class="line">    result_1 = executor.submit(task, <span class="string">&#x27;A&#x27;</span>)  </span><br><span class="line">    result_2 = executor.submit(task, <span class="string">&#x27;B&#x27;</span>)  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取任务的执行结果</span></span><br><span class="line">    <span class="built_in">print</span>(result_1.result())  </span><br><span class="line">    <span class="built_in">print</span>(result_2.result())  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> executor:  </span><br><span class="line">	<span class="comment"># 批量提交多个任务</span></span><br><span class="line">    results = executor.<span class="built_in">map</span>(task, [<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>])  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> results:  </span><br><span class="line">        <span class="built_in">print</span>(r)</span><br></pre></td></tr></table></figure>
<p><code>ThreadPoolExecutor</code> 类是一个用于管理线程池的工具，可用于异步执行函数或方法。</p>
<ol>
<li><code>executor.submit()</code> 方法提交任务给线程池，后边的参数是给任务传递的参数，可以多个</li>
<li>创建<code>ThreadPoolExecutor</code> 类时，根据 <code>max_workers</code> 参数来控制线程池中的线程数量，默认根据CPU数量设置线程数</li>
<li>executor.map函数批量提交多个任务到线程池</li>
</ol>
<p><strong>使用submit提交多个任务，示例：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_one</span>(<span class="params">url</span>):</span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Read &#123;&#125; from &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(resp.content), url))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_all</span>(<span class="params">sites</span>):</span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        to_do = []</span><br><span class="line">        <span class="keyword">for</span> site <span class="keyword">in</span> sites:</span><br><span class="line">            future = executor.submit(download_one, site)</span><br><span class="line">            to_do.append(future)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(to_do):</span><br><span class="line">            future.result()</span><br></pre></td></tr></table></figure>
<p>以上使用 <code>concurrent.futures.as_completed</code> 函数处理多个并发任务的结果。它的作用是返回一个生成器，该生成器在任务完成时生成任务的 Future 对象，而不是按照它们完成的顺序。这使你可以处理任何任务的结果，而不必等待它们按照提交的顺序完成。</p>
<h2 id="7-5-多线程还是Asyncio"><a href="#7-5-多线程还是Asyncio" class="headerlink" title="7.5 多线程还是Asyncio"></a>7.5 多线程还是Asyncio</h2><p><strong>多线程和Asyncio的区别：</strong><br>多线程：</p>
<ul>
<li>多线程是使用标准的线程和锁机制来实现并发的方式。</li>
<li>在多线程中，每个线程都是一个独立的执行单元，可以并发执行不同的任务。</li>
<li>多线程由于 Python 的 GIL（全局解释器锁）的限制，在同一时刻只能执行一个线程</li>
</ul>
<p>Asyncio（协程）：</p>
<ul>
<li>asyncio 使用单线程和事件循环来管理异步协程任务。</li>
<li>在 asyncio 中，多个协程可以在同一线程中并发执行，但在某一时刻只有一个协程在执行，而不会涉及线程切换。</li>
<li>asyncio 适用于 I&#x2F;O 密集型任务，如网络通信和文件操作。由于避免了线程切换的开销，它通常比多线程更高效。</li>
</ul>
<p>Asyncio（协程）可以通过编程控制协程切换，本质是一个线程在异步执行都个协程任务，避免了线程协换的开销，比多线程更加高效。</p>
<p><strong>多线程和Asyncio的选择：</strong></p>
<ul>
<li>如果是 I&#x2F;O bound，并且 I&#x2F;O 操作很慢，需要很多任务 &#x2F; 线程协同实现，那么使用 Asyncio 更合适。</li>
<li>如果是 I&#x2F;O bound，但是 I&#x2F;O 操作很快，只需要有限数量的任务 &#x2F; 线程，那么使用多线程就可以了。</li>
<li>如果是 CPU bound，则需要使用多进程来提高程序运行效率，使用多线程是无效的。</li>
</ul>
<h1 id="8-GIL（全局解释器锁）"><a href="#8-GIL（全局解释器锁）" class="headerlink" title="8  GIL（全局解释器锁）"></a>8  GIL（全局解释器锁）</h1><h2 id="8-1-什么是GIL"><a href="#8-1-什么是GIL" class="headerlink" title="8.1 什么是GIL"></a>8.1 什么是GIL</h2><p>GIL，是最流行的 Python 解释器 CPython 中的一个技术术语。它的意思是全局解释器锁，本质上是类似操作系统的 Mutex。每一个 Python 线程，在 CPython 解释器中执行时，都会先锁住自己的线程，阻止别的线程执行。CPython会轮流执行Python线程，这样一来，用户看到的就是“伪并行”——Python 线程在交错执行，来模拟真正并行的线程。</p>
<ul>
<li>为什么需要GIL？</li>
</ul>
<p>CPython 使用引用计数来管理内存，所有 Python 脚本中创建的实例，都会有一个引用计数，来记录有多少个指针指向它。当引用计数只有 0 时，则会自动释放内存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrefcount(a)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>a 的引用计数是 3，因为有 a、b 和作为参数传递的 getrefcount 这三个地方，都引用了一个空列表。<br>这样一来，如果有两个 Python 线程同时引用了 a，就会造成引用计数的 race condition，引用计数可能最终只增加 1，这样就会造成内存被污染。因为第一个线程结束时，会把引用计数减少 1，这时可能达到条件释放内存，当第二个线程再试图访问 a 时，就找不到有效的内存了。</p>
<p>CPython 引进 GIL 其实主要就是这么两个原因：</p>
<ul>
<li>一是设计者为了规避类似于内存管理这样的复杂的竞争风险问题（race condition）；</li>
<li>二是因为 CPython 大量使用 C 语言库，但大部分 C 语言库都不是原生线程安全的（线程安全会降低性能和增加复杂度）。</li>
</ul>
<h2 id="8-2-GIL如何工作的"><a href="#8-2-GIL如何工作的" class="headerlink" title="8.2 GIL如何工作的"></a>8.2 GIL如何工作的</h2><p>下面这张图，就是一个 GIL 在 Python 程序的工作示例。其中，Thread 1、2、3 轮流执行，每一个线程在开始执行时，都会锁住 GIL，以阻止别的线程执行；同样的，每一个线程执行完一段后，会释放 GIL，以允许别的线程开始利用资源。<br><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2023/20231024092005.png"></p>
<p>CPython 中还有一个check_interval机制，CPython 解释器会去轮询检查线程 GIL 的锁住情况。每隔一段时间，Python 解释器就会强制当前线程去释放 GIL，这样别的线程才能有执行的机会。</p>
<ul>
<li>Python的线程安全</li>
</ul>
<p>有了GIL并不代表Python就不需要考虑线程安全了，因为有check interval这种抢占机制。</p>
<h2 id="8-3-如何绕过GIL"><a href="#8-3-如何绕过GIL" class="headerlink" title="8.3 如何绕过GIL"></a>8.3 如何绕过GIL</h2><p>Python 的 GIL，是通过 CPython 的解释器加的限制。如果你的代码并不需要 CPython 解释器来执行，就不再受 GIL 的限制。<br>事实上，很多高性能应用场景都已经有大量的 C 实现的 Python 库，例如 NumPy 的矩阵运算，就都是通过 C 来实现的，并不受 GIL 影响。<br><strong>绕过 GIL 的大致思路有这么两种：</strong></p>
<ol>
<li>绕过 CPython，使用 JPython（Java 实现的 Python 解释器）等别的实现；</li>
<li>把关键性能代码，放到别的语言（一般是 C++）中实现。</li>
</ol>
<h1 id="9-并发编程–多进程"><a href="#9-并发编程–多进程" class="headerlink" title="9 并发编程–多进程"></a>9 并发编程–多进程</h1><h2 id="9-1-多进程"><a href="#9-1-多进程" class="headerlink" title="9.1 多进程"></a>9.1 多进程</h2><p>基于<code>multiprocessing</code>包，<code>multiprocessing.Process</code> 类：</p>
<ul>
<li><code>Process</code> 类用于创建新的进程。</li>
<li>使用 <code>target</code> 参数指定要在新进程中运行的函数。</li>
<li>使用 <code>args</code> 参数传递给目标函数的参数。</li>
<li>通过调用 <code>start()</code> 方法启动新进程。</li>
<li>通过调用 <code>join()</code> 方法等待新进程执行完成。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing  </span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name: <span class="built_in">str</span>, count: <span class="built_in">int</span></span>):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> - start\n&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)  </span><br><span class="line">    result = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(count):  </span><br><span class="line">        result += n + <span class="number">1</span>  </span><br><span class="line">    time.sleep(<span class="number">1</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> - end with <span class="subst">&#123;result&#125;</span>&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_process_1</span>():  </span><br><span class="line">    process = multiprocessing.Process(target=task, args=[<span class="string">&quot;A&quot;</span>, <span class="number">100</span>])  </span><br><span class="line">  </span><br><span class="line">    process.start()  </span><br><span class="line">  </span><br><span class="line">    process.join()  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Main process over&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_process_2</span>():  </span><br><span class="line">    args_list = [(<span class="string">&quot;A&quot;</span>, <span class="number">100</span>), (<span class="string">&quot;B&quot;</span>, <span class="number">99</span>), (<span class="string">&quot;C&quot;</span>, <span class="number">98</span>)]  </span><br><span class="line">    processes = [multiprocessing.Process(target=task, args=[name, count]) <span class="keyword">for</span> name, count <span class="keyword">in</span> args_list]  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:  </span><br><span class="line">        p.start()  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:  </span><br><span class="line">        p.join()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    start_process_2()</span><br></pre></td></tr></table></figure>
<p>在使用多进程时需要 把代码放在 <code>__name__ == &quot;__main__&quot;</code> 中。</p>
<h2 id="9-2-进程池"><a href="#9-2-进程池" class="headerlink" title="9.2 进程池"></a>9.2 进程池</h2><p>Python中实现多进程的包与多线程的类似，都可以使用futures包，示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker_function</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">        results = <span class="built_in">list</span>(executor.<span class="built_in">map</span>(worker_function, numbers))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(results)</span><br></pre></td></tr></table></figure>


<h1 id="10-Python垃圾回收机制"><a href="#10-Python垃圾回收机制" class="headerlink" title="10 Python垃圾回收机制"></a>10 Python垃圾回收机制</h1><ul>
<li>计数引用</li>
<li>循环引用</li>
</ul>
<p>调试内存泄漏的工具：objgraph</p>
<h1 id="11-上下文管理器和With语句"><a href="#11-上下文管理器和With语句" class="headerlink" title="11 上下文管理器和With语句"></a>11 上下文管理器和With语句</h1><h2 id="11-1-With语句的使用"><a href="#11-1-With语句的使用" class="headerlink" title="11.1 With语句的使用"></a>11.1 With语句的使用</h2><ul>
<li><strong>使用with语句自动关闭文件</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>通过使用以上的With语句方式，不再需要写关闭文件的操作。</p>
<ul>
<li><strong>自动释放锁</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">some_lock = threading.Lock()</span><br><span class="line"><span class="keyword">with</span> somelock:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h2 id="11-2-上下文管理器的实现"><a href="#11-2-上下文管理器的实现" class="headerlink" title="11.2 上下文管理器的实现"></a>11.2 上下文管理器的实现</h2><h3 id="11-2-1-基于类的上下文管理器"><a href="#11-2-1-基于类的上下文管理器" class="headerlink" title="11.2.1 基于类的上下文管理器"></a>11.2.1 基于类的上下文管理器</h3><p>当我们用类来创建上下文管理器时，必须保证这个类包括方法<code>”__enter__()”</code>和方法<code>“__exit__()”</code>。其中，方法<code>“__enter__()”</code>返回需要被管理的资源，方法<code>“__exit__()”</code>里通常会存在一些释放、清理资源的操作，比如这个例子中的关闭文件等等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, mode</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;calling __init__ method&#x27;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.mode = mode </span><br><span class="line">        self.file = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;calling __enter__ method&#x27;</span>)</span><br><span class="line">        self.file = <span class="built_in">open</span>(self.name, self.mode)</span><br><span class="line">        <span class="keyword">return</span> self.file  <span class="comment"># 赋值给with语句中as后边的变量</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;calling __exit__ method&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.file:</span><br><span class="line">            self.file.close()</span><br><span class="line">            </span><br><span class="line"><span class="keyword">with</span> FileManager(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ready to write to file&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">## 输出</span></span><br><span class="line">calling __init__ method</span><br><span class="line">calling __enter__ method</span><br><span class="line">ready to write to file</span><br><span class="line">calling __exit__ method</span><br></pre></td></tr></table></figure>

<p>以上with语句执行逻辑：</p>
<ol>
<li>方法<code>“__init__()”</code>被调用，程序初始化对象 FileManager，使得文件名（name）是<code>&quot;test.txt&quot;</code>，文件模式 (mode) 是<code>&#39;w&#39;</code>；</li>
<li>with语句自动调用方法<code>“__enter__()”</code>，文件<code>“test.txt”</code>以写入的模式被打开，并且返回 FileManager 对象赋予变量 f；</li>
<li>字符串<code>“hello world”</code>被写入文件<code>“test.txt”</code>；</li>
<li>方法<code>“__exit__()”</code>被调用，负责关闭之前打开的文件流。</li>
</ol>
<p>方法<code>“__exit__()”</code>中的参数<code>“exc_type, exc_val, exc_tb”</code>，分别表示 exception_type、exception_value 和 traceback。当执行含有上下文管理器的 with 语句时，如果有异常抛出，异常的信息就会包含在这三个变量中，传入方法<code>“__exit__()”</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__init__ called&#x27;</span>)        </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__enter__ called&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_value, exc_tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;__exit__ called&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> exc_type:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;exc_type: <span class="subst">&#123;exc_type&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;exc_value: <span class="subst">&#123;exc_value&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;exc_traceback: <span class="subst">&#123;exc_tb&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;exception handled&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> Foo() <span class="keyword">as</span> obj:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;exception raised&#x27;</span>).with_traceback(<span class="literal">None</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">__init__ called</span><br><span class="line">__enter__ called</span><br><span class="line">__exit__ called</span><br><span class="line">exc_type: &lt;<span class="keyword">class</span> <span class="string">&#x27;Exception&#x27;</span>&gt;</span><br><span class="line">exc_value: exception raised</span><br><span class="line">exc_traceback: &lt;traceback <span class="built_in">object</span> at <span class="number">0x1046036c8</span>&gt;</span><br><span class="line">exception handled</span><br></pre></td></tr></table></figure>

<p>在 with 语句中手动抛出了异常“exception raised”，你可以看到，<code>“__exit__()”</code>方法中异常，被顺利捕捉并进行了处理。不过需要注意的是，如果方法<code>“__exit__()”</code>没有返回 True，异常仍然会被抛出。因此，如果你确定异常已经被处理了，请在<code>“__exit__()”</code>的最后，加上<code>“return True”</code>这条语句。</p>
<ul>
<li><strong>示例代码：（用上下文管理器，实现数据库连接）</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConnectionManager</span>: </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, hostname, port</span>): </span><br><span class="line">        self.hostname = hostname </span><br><span class="line">        self.port = port </span><br><span class="line">        self.connection = <span class="literal">None</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>): </span><br><span class="line">        self.connection = DBClient(self.hostname, self.port) </span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>): </span><br><span class="line">        self.connection.close() </span><br><span class="line">  </span><br><span class="line"><span class="keyword">with</span> DBConnectionManager(<span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;8080&#x27;</span>) <span class="keyword">as</span> db_client: </span><br></pre></td></tr></table></figure>

<p>实现了 DBconnectionManager 这个类，那么在程序每次连接数据库时，只需要简单地调用 with 语句即可，并不需要关心数据库的关闭、异常等等，显然大大提高了开发的效率。</p>
<h3 id="11-2-2-基于生成器的上下文管理器"><a href="#11-2-2-基于生成器的上下文管理器" class="headerlink" title="11.2.2 基于生成器的上下文管理器"></a>11.2.2 基于生成器的上下文管理器</h3><p>可以使用装饰器 contextlib.contextmanager，来定义自己所需的基于生成器的上下文管理器，用以支持 with 语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"> </span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_manager</span>(<span class="params">name, mode</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = <span class="built_in">open</span>(name, mode)</span><br><span class="line">        <span class="keyword">yield</span> f</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        f.close()</span><br><span class="line">        </span><br><span class="line"><span class="keyword">with</span> file_manager(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;hello world&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>函数 file_manager() 是一个生成器，当执行 with 语句时，便会打开文件，并返回文件对象 f；当 with 语句执行完后，finally block 中的关闭文件操作便会执行。<br>使用基于生成器的上下文管理器时，我们不再用定义<code>“__enter__()”</code>和<code>“__exit__()”</code>方法，但请务必加上装饰器 @contextmanager。</p>
<p><strong>总结：</strong></p>
<ul>
<li>基于类的上下文管理器更加 flexible，适用于大型的系统开发；</li>
<li>而基于生成器的上下文管理器更加方便、简洁，适用于中小型程序。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://baihlup.github.io">梦之痕</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://baihlup.github.io/2023/10/20/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/213%20-%20Go%20&amp;%20Python/03%20-%20Python--%E8%BF%9B%E9%98%B6%E7%AF%87/">https://baihlup.github.io/2023/10/20/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/213%20-%20Go%20&amp;%20Python/03%20-%20Python--%E8%BF%9B%E9%98%B6%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/16/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/213%20-%20Go%20&amp;%20Python/06%20-%20Python--%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8C%85/" title="Python--常用工具包"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">Python--常用工具包</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/16/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/213%20-%20Go%20&amp;%20Python/02%20-%20Python--%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="Python编程语言--面向对象"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">Python编程语言--面向对象</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/10/16/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/213%20-%20Go%20&%20Python/02%20-%20Python--%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="Python编程语言--面向对象"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-16</div><div class="title">Python编程语言--面向对象</div></div></a></div><div><a href="/2023/10/16/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/213%20-%20Go%20&%20Python/01%20-%20Python--%E5%9F%BA%E7%A1%80%E7%AF%87/" title="Python编程语言--基础篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-16</div><div class="title">Python编程语言--基础篇</div></div></a></div><div><a href="/2023/11/16/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/213%20-%20Go%20&%20Python/06%20-%20Python--%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8C%85/" title="Python--常用工具包"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-16</div><div class="title">Python--常用工具包</div></div></a></div><div><a href="/2023/11/20/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/213%20-%20Go%20&%20Python/09%20-%20Go--%E5%9F%BA%E7%A1%80%E7%AF%87/" title="Go--基础篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-20</div><div class="title">Go--基础篇</div></div></a></div><div><a href="/2024/03/04/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/213%20-%20Go%20&%20Python/10%20-%20Go--%E8%BF%9B%E9%98%B6%E7%AF%87/" title="Go--进阶篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-04</div><div class="title">Go--进阶篇</div></div></a></div><div><a href="/2023/12/22/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/214%20-%20Java%20&%20Lua/01%20-%20Java--%E5%9F%BA%E7%A1%80%E7%AF%87/" title="Java--基础篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-22</div><div class="title">Java--基础篇</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">梦之痕</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">56</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/BaihlUp"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">个人笔记迁移中ing....</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.</span> <span class="toc-text">0 参考资料</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Python%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83%E3%80%81%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.</span> <span class="toc-text">1 Python对象的比较、拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%AF%94%E8%BE%83"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 深拷贝和浅拷贝</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%80%BC%E4%BC%A0%E9%80%92-or-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">3.</span> <span class="toc-text">2 值传递 or 引用传递</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Python%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E8%B5%8B%E5%80%BC"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 Python变量及其赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Python%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 Python函数的参数传递</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">3 装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 函数装饰器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 类装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-call-%E6%A8%A1%E5%BC%8F%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">3.2.1  __call__ 模式方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-classmethod-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">3.2.2 classmethod 装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-staticmethod-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">4.2.3.</span> <span class="toc-text">3.2.3 staticmethod 装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-classmethod-%E5%92%8C-staticmethod%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.4.</span> <span class="toc-text">3.2.4 classmethod 和 staticmethod的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-5-property-%E4%BF%AE%E9%A5%B0%E5%99%A8"><span class="toc-number">4.2.5.</span> <span class="toc-text">3.2.5 property 修饰器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 装饰器的嵌套</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.4.</span> <span class="toc-text">3.4 装饰器的应用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81"><span class="toc-number">4.4.1.</span> <span class="toc-text">3.4.1 身份认证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><span class="toc-number">4.4.2.</span> <span class="toc-text">3.4.2 日志记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-%E8%BE%93%E5%85%A5%E5%90%88%E7%90%86%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="toc-number">4.4.3.</span> <span class="toc-text">3.4.3 输入合理性检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-%E7%BC%93%E5%AD%98"><span class="toc-number">4.4.4.</span> <span class="toc-text">3.4.4 缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-metaclass"><span class="toc-number">5.</span> <span class="toc-text">4 metaclass</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-type%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 type类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-metaclass%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 metaclass的使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">5 迭代器和生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">6.2.</span> <span class="toc-text">5.2 生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.2.1.</span> <span class="toc-text">5.2.1 生成器的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E7%94%9F%E6%88%90%E5%99%A8%E6%9B%B4%E5%A4%9A%E7%94%A8%E6%B3%95"><span class="toc-number">6.2.2.</span> <span class="toc-text">5.2.2 生成器更多用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">6.2.3.</span> <span class="toc-text">5.2.3 使用生成器实现判断子序列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%93Python-%E5%8D%8F%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">6 并发编程–Python 协程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-asyncio%E4%BD%BF%E7%94%A8"><span class="toc-number">7.1.</span> <span class="toc-text">6.1 asyncio使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-asyncio%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 asyncio创建任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-asyncio%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95"><span class="toc-number">7.3.</span> <span class="toc-text">6.3 asyncio进阶用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E5%AE%9E%E6%88%98%E5%92%8C%E6%80%BB%E7%BB%93"><span class="toc-number">7.4.</span> <span class="toc-text">6.4 实战和总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%93%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">7 并发编程–多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E7%BA%BF%E7%A8%8B"><span class="toc-number">8.1.</span> <span class="toc-text">7.1 线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%98%9F%E5%88%97"><span class="toc-number">8.2.</span> <span class="toc-text">7.2 线程安全队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E7%BA%BF%E7%A8%8B%E9%94%81"><span class="toc-number">8.3.</span> <span class="toc-text">7.3 线程锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">8.4.</span> <span class="toc-text">7.4 线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%98%E6%98%AFAsyncio"><span class="toc-number">8.5.</span> <span class="toc-text">7.5 多线程还是Asyncio</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-GIL%EF%BC%88%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">8  GIL（全局解释器锁）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E4%BB%80%E4%B9%88%E6%98%AFGIL"><span class="toc-number">9.1.</span> <span class="toc-text">8.1 什么是GIL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-GIL%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">9.2.</span> <span class="toc-text">8.2 GIL如何工作的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87GIL"><span class="toc-number">9.3.</span> <span class="toc-text">8.3 如何绕过GIL</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%93%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">10.</span> <span class="toc-text">9 并发编程–多进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">10.1.</span> <span class="toc-text">9.1 多进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E8%BF%9B%E7%A8%8B%E6%B1%A0"><span class="toc-number">10.2.</span> <span class="toc-text">9.2 进程池</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-Python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">11.</span> <span class="toc-text">10 Python垃圾回收机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8%E5%92%8CWith%E8%AF%AD%E5%8F%A5"><span class="toc-number">12.</span> <span class="toc-text">11 上下文管理器和With语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-With%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">12.1.</span> <span class="toc-text">11.1 With语句的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.2.</span> <span class="toc-text">11.2 上下文管理器的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-1-%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">12.2.1.</span> <span class="toc-text">11.2.1 基于类的上下文管理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-2-%E5%9F%BA%E4%BA%8E%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">12.2.2.</span> <span class="toc-text">11.2.2 基于生成器的上下文管理器</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/01/260%20-%20%E5%90%8E%E7%AB%AF&amp;%E6%9E%B6%E6%9E%84/261%20-%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02%20-%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/" title="Untitled">Untitled</a><time datetime="2024-08-01T07:16:13.710Z" title="Created 2024-08-01 07:16:13">2024-08-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/01/000%20-%20Inbox/%E7%81%AB%E5%B1%B1%E4%BA%91waf/" title="Untitled">Untitled</a><time datetime="2024-08-01T07:16:13.610Z" title="Created 2024-08-01 07:16:13">2024-08-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/24/240%20-%20%E8%99%9A%E6%8B%9F%E5%8C%96&amp;%E4%BA%91%E8%AE%A1%E7%AE%97/244%20-%20%E4%BA%91%E5%8E%9F%E7%94%9F/01%20-%20Kuberbetes%20%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89/" title="Kuberbetes 核心组件（一）">Kuberbetes 核心组件（一）</a><time datetime="2024-07-24T00:00:00.000Z" title="Created 2024-07-24 00:00:00">2024-07-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/07/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/214%20-%20Java%20&amp;%20Lua/09%20-%20Java--File%E7%B1%BB%E4%B8%8EIO%E6%B5%81/" title="Java--File类与IO流">Java--File类与IO流</a><time datetime="2024-07-07T00:00:00.000Z" title="Created 2024-07-07 00:00:00">2024-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/05/210%20-%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/214%20-%20Java%20&amp;%20Lua/05%20-%20Java--%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API/" title="Java--常用类和基础API">Java--常用类和基础API</a><time datetime="2024-07-05T00:00:00.000Z" title="Created 2024-07-05 00:00:00">2024-07-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 梦之痕</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>