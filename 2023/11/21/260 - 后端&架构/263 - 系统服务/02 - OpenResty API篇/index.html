<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>OpenResty API篇 | 梦之痕</title><meta name="author" content="梦之痕"><meta name="copyright" content="梦之痕"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="2 OpenResty开发平台2.1.1 协程和事件驱动在 OpenResty 层面，Lua 的协程会与 NGINX 的事件机制相互配合。如果 Lua 代码中出现类似查询 MySQL 数据库这样的 I&#x2F;O 操作，就会先调用 Lua 协程的 yield 把自己挂起，然后在 NGINX 中注册回调；在 I&#x2F;O 操作完成（也可能是超时或者出错）后，再由 NGINX 回调 resume">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenResty API篇">
<meta property="og:url" content="https://baihlup.github.io/2023/11/21/260%20-%20%E5%90%8E%E7%AB%AF&%E6%9E%B6%E6%9E%84/263%20-%20%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/02%20-%20OpenResty%20API%E7%AF%87/index.html">
<meta property="og:site_name" content="梦之痕">
<meta property="og:description" content="2 OpenResty开发平台2.1.1 协程和事件驱动在 OpenResty 层面，Lua 的协程会与 NGINX 的事件机制相互配合。如果 Lua 代码中出现类似查询 MySQL 数据库这样的 I&#x2F;O 操作，就会先调用 Lua 协程的 yield 把自己挂起，然后在 NGINX 中注册回调；在 I&#x2F;O 操作完成（也可能是超时或者出错）后，再由 NGINX 回调 resume">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg">
<meta property="article:published_time" content="2023-11-21T16:27:41.000Z">
<meta property="article:modified_time" content="2024-09-22T07:46:10.170Z">
<meta property="article:author" content="梦之痕">
<meta property="article:tag" content="OpenResty">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://baihlup.github.io/2023/11/21/260%20-%20%E5%90%8E%E7%AB%AF&amp;%E6%9E%B6%E6%9E%84/263%20-%20%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/02%20-%20OpenResty%20API%E7%AF%87/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OpenResty API篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-22 07:46:10'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="梦之痕"><span class="site-name">梦之痕</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">OpenResty API篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-11-21T16:27:41.000Z" title="Created 2023-11-21 16:27:41">2023-11-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-09-22T07:46:10.170Z" title="Updated 2024-09-22 07:46:10">2024-09-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF-%E6%9E%B6%E6%9E%84/">后端&amp;架构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="OpenResty API篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="2-OpenResty开发平台"><a href="#2-OpenResty开发平台" class="headerlink" title="2 OpenResty开发平台"></a>2 OpenResty开发平台</h1><h3 id="2-1-1-协程和事件驱动"><a href="#2-1-1-协程和事件驱动" class="headerlink" title="2.1.1 协程和事件驱动"></a>2.1.1 协程和事件驱动</h3><p>在 OpenResty 层面，Lua 的协程会与 NGINX 的事件机制相互配合。如果 Lua 代码中出现类似查询 MySQL 数据库这样的 I&#x2F;O 操作，就会先调用 Lua 协程的 yield 把自己挂起，然后在 NGINX 中注册回调；在 I&#x2F;O 操作完成（也可能是超时或者出错）后，再由 NGINX 回调 resume 来唤醒 Lua 协程。这样就完成了 Lua 协程和 NGINX 事件驱动的配合，避免在 Lua 代码中写回调。<br>我们可以来看下面这张图，描述了这整个流程。其中，<code>lua_yield</code> 和 <code>lua_resume</code> 都属于 Lua 提供的 <code>lua_CFunction</code>。<br><img src="https://i.loli.net/2020/09/14/sdrcA42uWpTaQ9x.png"></p>
<p>下面是 <code>ngx.sleep</code> 的一段源码，可以帮你更清晰理解这一点。 这段代码位于 <code>ngx_http_lua_sleep.c</code> 中，你可以在 <code>lua-nginx-module</code> 项目的 <a target="_blank" rel="noopener" href="https://github.com/openresty/lua-nginx-module/tree/master/src">src</a> 目录中找到它。<br>在<code>ngx_http_lua_sleep.c</code> 中，我们可以看到 sleep 函数的具体实现。你需要先通过 C 函数 <code>ngx_http_lua_ngx_sleep</code>，来注册 <code>ngx.sleep</code> 这个 Lua API：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ngx_http_lua_inject_sleep_api</span><span class="params">(lua_State *L)</span></span><br><span class="line">&#123;</span><br><span class="line">     lua_pushcfunction(L, ngx_http_lua_ngx_sleep);</span><br><span class="line">     lua_setfield(L, <span class="number">-2</span>, <span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面便是 sleep 的主函数，这里我只摘取了几行主要的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ngx_http_lua_ngx_sleep</span><span class="params">(lua_State *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    coctx-&gt;sleep.handler = ngx_http_lua_sleep_handler;</span><br><span class="line">    ngx_add_timer(&amp;coctx-&gt;sleep, (<span class="type">ngx_msec_t</span>) delay);</span><br><span class="line">    <span class="keyword">return</span> lua_yield(L, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里先增加了 <code>ngx_http_lua_sleep_handler</code> 这个回调函数；</li>
<li>然后调用 <code>ngx_add_timer</code> 这个 NGINX 提供的接口，向 NGINX 的事件循环中增加一个定时器；</li>
<li>最后使用 <code>lua_yield</code> 把 Lua 协程挂起，把控制权交给 NGINX 的事件循环。</li>
</ul>
<p>当 sleep 操作完成后， <code>ngx_http_lua_sleep_handler</code> 这个回调函数就被触发了。它里面调用了 <code>ngx_http_lua_sleep_resume</code>, 并最终使用 <code>lua_resume</code> 唤醒了 Lua 协程。更具体的调用过程，可以自己去代码里面检索。</p>
<h3 id="2-1-2-OpenResty-的阶段"><a href="#2-1-2-OpenResty-的阶段" class="headerlink" title="2.1.2 OpenResty 的阶段"></a>2.1.2 OpenResty 的阶段</h3><ul>
<li><code>set_by_lua</code>，用于设置变量；</li>
<li><code>rewrite_by_lua</code>，改写URI，可用于实现跳转&#x2F;重定向；</li>
<li><code>access_by_lua</code>，用于处理访问控制或限速；</li>
<li><code>content_by_lua</code>，用于生成返回内容；</li>
<li><code>header_filter_by_lua</code>，用于应答头过滤处理；</li>
<li><code>body_filter_by_lua</code>，用于应答体过滤处理；</li>
<li><code>log_by_lua</code>，用于日志记录。</li>
</ul>
<p>在编写模块时，不同的API在使用前应该弄清楚这个API的context，如果使用不当会报错。如下示例：<br>以<code>ngx.sleep</code> 为例，通过查阅文档，我知道它只能用于下面列出的上下文中，并不包括 log 阶段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context: rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*_</span><br></pre></td></tr></table></figure>
<p>而如果你不知道这一点，在它不支持的 log 阶段使用 sleep 的话：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    log_by_lua_block &#123;</span><br><span class="line">        ngx.sleep(<span class="number">1</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 NGINX 的错误日志中，就会出现 error 级别的提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[error] 62666#0: *6 failed to run log_by_lua*: log_by_lua(nginx.conf:14):2: API disabled in the context of log_by_lua*</span><br><span class="line">stack traceback:</span><br><span class="line">    [C]: in function &#x27;sleep&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-文档和测试案例"><a href="#2-2-文档和测试案例" class="headerlink" title="2.2 文档和测试案例"></a>2.2 文档和测试案例</h2><p>在学习 OpenResty 时一定要多看文档和测试用例，在模块的 <code>t</code> 目录下有模块的完整用例集，可以方便测试和学习。<br>下边简单以<code>shdict get API</code> 为例：<br><a target="_blank" rel="noopener" href="https://github.com/openresty/lua-nginx-module/#ngxshareddictget">文档链接</a> 为对照。下边是一个get方法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    lua_shared_dict dogs <span class="number">10</span>m;</span><br><span class="line">    server &#123;</span><br><span class="line">        location /demo &#123;</span><br><span class="line">            content_by_lua_block &#123;</span><br><span class="line">                <span class="keyword">local</span> dogs = ngx.shared.dogs</span><br><span class="line">       dogs:set(<span class="string">&quot;Jim&quot;</span>, <span class="number">8</span>)</span><br><span class="line">       <span class="keyword">local</span> v = dogs:get(<span class="string">&quot;Jim&quot;</span>)</span><br><span class="line">                ngx.say(v)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单说明一下，在 Lua 代码中使用 shared dict 之前，我们需要在 nginx.conf 中用 <code>lua_shared_dict</code> 指令增加一块内存空间，它的名字是 dogs，大小为 10M。修改完 nginx.conf 后，你还需要重启进程，用浏览器或者 curl 访问才能看到结果。<br>下边是shdict get API 的一个测试用例：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">=== TEST <span class="number">1</span>: string key, <span class="keyword">int</span> value</span><br><span class="line"> --- http_config</span><br><span class="line">     lua_shared_dict dogs <span class="number">1</span>m;</span><br><span class="line"> --- config</span><br><span class="line">     location = <span class="regexp">/test &#123;</span></span><br><span class="line"><span class="regexp">         init_by_lua &#x27;</span></span><br><span class="line"><span class="regexp">             local dogs = ngx.shared.dogs</span></span><br><span class="line"><span class="regexp">             local val = dogs:get(&quot;foo&quot;)</span></span><br><span class="line"><span class="regexp">             ngx.say(val)</span></span><br><span class="line"><span class="regexp">         &#x27;;</span></span><br><span class="line"><span class="regexp">     &#125;</span></span><br><span class="line"><span class="regexp"> --- request</span></span><br><span class="line"><span class="regexp"> GET /</span>test</span><br><span class="line"> --- response_body</span><br><span class="line"> <span class="number">32</span></span><br><span class="line"> --- no_error_log</span><br><span class="line"> [error]</span><br><span class="line"> --- ONLY</span><br></pre></td></tr></table></figure>

<h1 id="3-OpenResty-处理终端请求和响应"><a href="#3-OpenResty-处理终端请求和响应" class="headerlink" title="3 OpenResty 处理终端请求和响应"></a>3 OpenResty 处理终端请求和响应</h1><h2 id="3-1-API-分类"><a href="#3-1-API-分类" class="headerlink" title="3.1 API 分类"></a>3.1 API 分类</h2><p><strong>OpenResty 的 API 主要分为下面几个大类：</strong></p>
<ul>
<li>处理请求和响应；</li>
<li>SSL 相关；</li>
<li>shared dict；</li>
<li>cosocket；</li>
<li>处理四层流量；</li>
<li>process 和 worker；</li>
<li>获取 NGINX 变量和配置；</li>
<li>字符串、时间、编解码等通用功能。</li>
</ul>
<p>OpenResty 的 API 不仅仅存在于 nginx-lua-module 项目中，也存在于 <code>lua-resty-core</code> 项目中，比如 <code>ngx.ssl</code>、<code>ngx.base64</code>、<code>ngx.errlog</code>、<code>ngx.process</code>、<code>ngx.re.split</code>、<code>ngx.resp.add_header</code>、<code>ngx.balancer</code>、<code>ngx.semaphore</code>、<code>ngx.ocsp</code> 这些 API 。</p>
<p>而对于不在 nginx-lua-module 项目中的 API，你需要单独 require 才能使用。</p>
<h2 id="3-2-请求处理"><a href="#3-2-请求处理" class="headerlink" title="3.2 请求处理"></a>3.2 请求处理</h2><h3 id="3-2-1-请求行"><a href="#3-2-1-请求行" class="headerlink" title="3.2.1 请求行"></a>3.2.1 请求行</h3><p>OpenResty 中的 <code>ngx.var.*</code> 这个 API可以取出响应的数据，如下：</p>
<ul>
<li><code>ngx.var.scheme</code> 返回协议名字，是“http”或“https”</li>
<li><code>ngx.var.request_method</code>  代表请求方法</li>
</ul>
<p>但是在OpenResty 提供了有相应的ngx.req开头的 API，为什么还要有ngx.var 呢。</p>
<ul>
<li>首先是对性能的考虑。ngx.var 的效率不高，不建议反复读取；</li>
<li>也有对程序友好的考虑，ngx.var 返回的是字符串，而非 Lua 对象，遇到获取 args 这种可能返回多个值的情况，就不好处理了；</li>
<li>另外是对灵活性的考虑，绝大部分的 ngx.var 是只读的，只有很少数的变量是可写的，比如 $args 和 limit_rate，可很多时候，我们会有修改 method、URI 和 args 的需求。</li>
</ul>
<p>可以打开 <a target="_blank" rel="noopener" href="https://github.com/openresty/lua-nginx-module/#nginx-api-for-lua">API列表</a> 具体查看。</p>
<ul>
<li><code>ngx.req.get_method</code>  返回：字符串格式的方法名</li>
<li><code>ngx.req.set_method(ngx.HTTP_POST)</code> 参数是数字常量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost]<span class="comment">#resty -e &#x27;print(ngx.HTTP_POST)&#x27;</span></span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ngx.req.set_uri</code> 和 <code>ngx.req.set_uri_args</code> 这两个 API，可以用来改写 uri 和 args。</li>
</ul>
<h3 id="3-2-2-请求头"><a href="#3-2-2-请求头" class="headerlink" title="3.2.2 请求头"></a>3.2.2 请求头</h3><p><code>ngx.req.get_headers</code> 来解析和获取请求头，返回值的类型则是 table：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> h, err = ngx.req.get_headers()</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> err == <span class="string">&quot;truncated&quot;</span> <span class="keyword">then</span></span><br><span class="line">      <span class="comment">-- one can choose to ignore or reject the current request here</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(h) <span class="keyword">do</span></span><br><span class="line">      ...</span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这里默认返回前 100 个 header，如果请求头超过了 100 个，就会返回 truncated 的错误信息，由开发者自己决定如何处理。</p>
<ul>
<li>改写和删除请求头：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_header(&quot;Content-Type&quot;, &quot;text/css&quot;)</span><br><span class="line">ngx.req.clear_header(&quot;Content-Type&quot;)</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>需要注意的是，OpenResty 并没有提供获取某一个指定请求头的 API，也就是没有 <code>ngx.req.header[&#39;host&#39;]</code> 这种形式。如果你有这样的需求，那就需要借助 NGINX 的变量 $http_xxx 来实现了，那么在 OpenResty 中，就是 <code>ngx.var.http_xxx</code> 这样的获取方式。</p>
</blockquote>
<h3 id="3-2-3-请求体"><a href="#3-2-3-请求体" class="headerlink" title="3.2.3 请求体"></a>3.2.3 请求体</h3><p>出于性能考虑，OpenResty 不会主动读取请求体的内容，除非在 nginx.conf 中强制开启了 <code>lua_need_request_body</code> 指令。此外，对于比较大的请求体，OpenResty 会把内容保存在磁盘的临时文件中，所以读取请求体的完整流程是下面这样的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.read_body()</span><br><span class="line"><span class="keyword">local</span> data = ngx.req.get_body_data()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> data <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">local</span> tmp_file = ngx.req.get_body_file()</span><br><span class="line">     <span class="comment">-- io.open(tmp_file)</span></span><br><span class="line">     <span class="comment">-- ...</span></span><br><span class="line"> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-处理响应"><a href="#3-3-处理响应" class="headerlink" title="3.3 处理响应"></a>3.3 处理响应</h2><h3 id="3-3-1-响应状态"><a href="#3-3-1-响应状态" class="headerlink" title="3.3.1 响应状态"></a>3.3.1 响应状态</h3><p>在默认情况下，返回的 HTTP 状态码是 200，也就是 OpenResty 中内置的常量 ngx.HTTP_OK。<br>OpenResty 的 HTTP 状态码中，有一个特别的常量：ngx.OK。当 ngx.exit(ngx.OK) 时，请求会退出当前处理阶段，进入下一个阶段，而不是直接返回给客户端。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.<span class="built_in">exit</span>(ngx.HTTP_BAD_REQUEST)</span><br></pre></td></tr></table></figure>
<p>改写状态码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.<span class="built_in">status</span> = ngx.HTTP_FORBIDDEN</span><br></pre></td></tr></table></figure>
<p>更多的状态码常量，查看<a target="_blank" rel="noopener" href="https://github.com/openresty/lua-nginx-module/#http-status-constants">文档</a></p>
<h3 id="3-3-2-响应头"><a href="#3-3-2-响应头" class="headerlink" title="3.3.2 响应头"></a>3.3.2 响应头</h3><p>响应头，其实，你有两种方法来设置它。第一种是最简单的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx.header.content_type = <span class="string">&#x27;text/plain&#x27;</span></span><br><span class="line">ngx.header[<span class="string">&quot;X-My-Header&quot;</span>] = <span class="string">&#x27;blah blah&#x27;</span></span><br><span class="line">ngx.header[<span class="string">&quot;X-My-Header&quot;</span>] = <span class="literal">nil</span> <span class="comment">-- 删除</span></span><br></pre></td></tr></table></figure>
<p>这里的 ngx.header 保存了响应头的信息，可以读取、修改和删除。<br>第二种设置响应头的方法是 <code>ngx_resp.add_header</code> ，来自 lua-resty-core 仓库，它可以增加一个头信息，用下面的方法来调用：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> ngx_resp = <span class="built_in">require</span> <span class="string">&quot;ngx.resp&quot;</span></span><br><span class="line">ngx_resp.add_header(<span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;bar&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>与第一种方法的不同之处在于，add header 不会覆盖已经存在的同名字段。</p>
<h3 id="3-3-3-响应体"><a href="#3-3-3-响应体" class="headerlink" title="3.3.3 响应体"></a>3.3.3 响应体</h3><p>可以使用 <code>ngx.say</code> 和 <code>ngx.print</code> 来输出响应体：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(<span class="string">&#x27;hello, world&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这两个 API 的功能是一致的，唯一的不同在于， <code>ngx.say</code> 会在最后多一个换行符。</p>
<h2 id="3-4-常量"><a href="#3-4-常量" class="headerlink" title="3.4 常量"></a>3.4 常量</h2><h3 id="3-4-1-状态码"><a href="#3-4-1-状态码" class="headerlink" title="3.4.1 状态码"></a>3.4.1 状态码</h3><ul>
<li>ngx.HTTP OK：200，请求已成功处理</li>
<li>ngx.HTTP MOVED TEMPORARILY：302，重定向跳转</li>
<li>ngx.HTTP BAD REQUEST：400，客户端请求错误</li>
<li>ngx.HTTP UNAUTHORIZED：401，未认证</li>
<li>ngx.HTTP FORBIDDEN：禁止访问 403</li>
<li>ngx.HTTP NOT FOUND：404，资源未找到</li>
<li>ngx.HTTP INTERNAL SERVER ERROR：500，服务器内部错误</li>
<li>ngx.HTTP BAD GATEWAY：502，网关错误，反向代理后端无效响应</li>
<li>ngX.HTTP SERVICE UNAVAILABLE：503，服务器暂不可用</li>
<li>ngx.HTTP GATEWAY TIMEOUT：504，网关超时，反向代理时后端超时</li>
</ul>
<p>在编写代码时不使用这些常量，直接用200、404这样的数字字面值也是可以的，两者完全等价，OpenResty对此没有强制要求。</p>
<h3 id="3-4-2-请求方法"><a href="#3-4-2-请求方法" class="headerlink" title="3.4.2 请求方法"></a>3.4.2 请求方法</h3><ul>
<li>ngx.HTTP GET：读操作，获取数据</li>
<li>ngx.HTTP HEAD：读操作，获取元数据</li>
<li>ngx.HTTP POST：写操作，提交数据</li>
<li>ngx.HTTP PUT：写操作，更新数据</li>
<li>ngX.HTTP DELETE：写操作，删除数据</li>
<li>ngx.HTTP PATCH：写操作，局部更新数据</li>
</ul>
<p>要注意的是这些常量并不是字符串，而是数字。</p>
<h1 id="4-OpenResty-中数据共享的方式"><a href="#4-OpenResty-中数据共享的方式" class="headerlink" title="4 OpenResty 中数据共享的方式"></a>4 OpenResty 中数据共享的方式</h1><p>OpenResty中的共享内存字典 shared dict，是最重要的数据结构。它不仅支持数据的存放和读取，还支持原子计数和队列操作。<br>基于 shared dict，你可以实现多个 worker 之间的缓存和通信，以及限流限速、流量统计等功能。你可以把 shared dict 当作简单的 Redis 来使用，只不过 shared dict 中的数据不能持久化，所以存放在其中的数据，一定要考虑到丢失的情况。<br>除了shared dict 还有其他几种数据共享的方式。</p>
<h2 id="4-1-Nginx-中的变量"><a href="#4-1-Nginx-中的变量" class="headerlink" title="4.1 Nginx 中的变量"></a>4.1 Nginx 中的变量</h2><p>它可以在 Nginx C 模块之间共享数据，自然的，也可以在 C 模块和 OpenResty 提供的 <code>lua-nginx-module</code> 之间共享数据，比如下面这段代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">     set $my_var <span class="string">&#x27;&#x27;</span>; # this line is required to <span class="built_in">create</span> $my_var at <span class="built_in">config</span> <span class="built_in">time</span></span><br><span class="line">     content_by_lua_block &#123;</span><br><span class="line">         ngx.var.my_var = <span class="number">123</span>;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>不过，使用 Nginx 变量这种方式来共享数据是比较慢的，因为它涉及到 hash 查找和内存分配。同时，这种方法有其局限性，只能用来存储字符串，不能支持复杂的 Lua 类型。</p>
<h2 id="4-2-ngx-ctx"><a href="#4-2-ngx-ctx" class="headerlink" title="4.2 ngx.ctx"></a>4.2 ngx.ctx</h2><p>可以在同一个请求的不同阶段之间共享数据。它其实就是一个普通的 Lua 的 table，所以速度很快，还可以存储各种 Lua 的对象。它的生命周期是请求级别的，当一个请求结束的时候，ngx.ctx 也会跟着被销毁掉。</p>
<p>下面是一个典型的使用场景，我们用 ngx.ctx 来缓存 Nginx 变量 这种昂贵的调用，并在不同阶段都可以使用到它：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">     rewrite_by_lua_block &#123;</span><br><span class="line">         ngx.ctx.host = ngx.var.host</span><br><span class="line">     &#125;</span><br><span class="line">     access_by_lua_block &#123;</span><br><span class="line">        <span class="keyword">if</span> (ngx.ctx.host == <span class="string">&#x27;openresty.org&#x27;</span>) <span class="keyword">then</span></span><br><span class="line">            ngx.ctx.host = <span class="string">&#x27;test.com&#x27;</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">     &#125;</span><br><span class="line">     content_by_lua_block &#123;</span><br><span class="line">         ngx.say(ngx.ctx.host)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>如果你使用 curl 访问的话：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i 127.0.0.1:8080/test -H <span class="string">&#x27;host:openresty.org&#x27;</span></span><br></pre></td></tr></table></figure>
<p>则响应 <code>test.com</code>。<br>需要注意的是 ngx.ctx 的生命周期是请求级别的，所以并不能在模块级别进行缓存。<br>如下使用就是错误的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> ngx_ctx = ngx.ctx</span><br><span class="line"> </span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">    ngx_ctx.host =  <span class="string">&#x27;test.com&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>应该在函数级别进行调用和缓存：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> ngx = ngx</span><br><span class="line"> </span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">local</span> ngx_ctx = ngx.ctx</span><br><span class="line">    ngx_ctx.host =  <span class="string">&#x27;test.com&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="4-3-模块级别的变量"><a href="#4-3-模块级别的变量" class="headerlink" title="4.3 模块级别的变量"></a>4.3 模块级别的变量</h2><p>可以在同一个 worker 内的所有请求之间共享数据。<br>下边先解释下模块级别的变量是什么？</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- mydata.lua</span></span><br><span class="line"> <span class="keyword">local</span> _M = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">local</span> data = &#123;</span><br><span class="line">     dog = <span class="number">3</span>,</span><br><span class="line">     cat = <span class="number">4</span>,</span><br><span class="line">     pig = <span class="number">5</span>,</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">_M.get_age</span><span class="params">(name)</span></span></span><br><span class="line">     <span class="keyword">return</span> data[name]</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure>
<p>在 nginx.conf 的配置如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /lua &#123;</span><br><span class="line">     content_by_lua_block &#123;</span><br><span class="line">         <span class="keyword">local</span> mydata = <span class="built_in">require</span> <span class="string">&quot;mydata&quot;</span></span><br><span class="line">         ngx.say(mydata.get_age(<span class="string">&quot;dog&quot;</span>))</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，mydata 就是一个模块，它只会被 worker 进程加载一次，之后，这个 worker 处理的所有请求，都会共享 mydata 模块的代码和数据。<br>自然，mydata 模块中的 data 这个变量，就是 模块级别的变量。</p>
<p>需要特别注意的是，一般我们只用这种方式来保存只读的数据。</p>
<h2 id="4-4-shared-dict"><a href="#4-4-shared-dict" class="headerlink" title="4.4 shared dict"></a>4.4 shared dict</h2><p>这些数据可以在多个 worker 之间共享。<br>这种方法是基于红黑树实现的，性能很好，但也有自己的局限性——你必须事先在 Nginx 的配置文件中，声明共享内存的大小，并且这不能在运行期更改：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_shared_dict dogs <span class="number">10</span>m;</span><br></pre></td></tr></table></figure>
<p>shared dict 同样只能缓存字符串类型的数据，不支持复杂的 Lua 数据类型。详细API查看<a target="_blank" rel="noopener" href="https://github.com/openresty/lua-nginx-module#ngxshareddict">文档</a></p>
<blockquote>
<p>前面三种数据共享的范围都是在请求级别，或者单个 worker 级别。所以，在当前的 OpenResty 的实现中，只有 shared dict 可以完成 worker 间的数据共享，并借此实现 worker 之间的通信，这也是它存在的价值。</p>
</blockquote>
<p>shared dict 在实现多个进程共享时，并不需要加锁，因为其中的接口已经实现了原子操作。</p>
<ul>
<li>读写类</li>
</ul>
<p>首先来看字典读写类。在最初的版本中，只有字典读写类的 API，它们也是共享字典最常用的功能。下面是一个最简单的示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ resty <span class="comment">--shdict=&#x27;dogs 1m&#x27; -e &#x27;local dict = ngx.shared.dogs</span></span><br><span class="line">                               dict:set(<span class="string">&quot;Tom&quot;</span>, <span class="number">56</span>)</span><br><span class="line">                               <span class="built_in">print</span>(dict:get(<span class="string">&quot;Tom&quot;</span>))<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>
<p>除了 set 外，OpenResty 还提供了 safe_set、add、safe_add、replace 这四种写入的方法。这里safe 前缀的含义是，在内存占满的情况下，不根据 LRU 淘汰旧的数据，而是写入失败并返回 no memory 的错误信息。<br><code>get_stale</code> 的读取数据的方法，相比 get 方法，它多了一个过期数据的返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, flags, stale = ngx.shared.DICT:get_stale(key)</span><br></pre></td></tr></table></figure>
<p>可以调用 delete 方法来删除指定的 key，它和 set(key, nil) 是等价的。</p>
<ul>
<li><p>队列操作类</p>
</li>
<li><p>lpush&#x2F;rpush，表示在队列两端增加元素；</p>
</li>
<li><p>lpop&#x2F;rpop，表示在队列两端弹出元素；</p>
</li>
<li><p>llen，表示返回队列的元素数量。</p>
</li>
</ul>
<p>测试案例查看 <code>145-shdict-list.t</code> 文件</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">=== TEST <span class="number">1</span>: lpush &amp; lpop</span><br><span class="line">--- http_config</span><br><span class="line">    lua_shared_dict dogs <span class="number">1</span>m;</span><br><span class="line">--- config</span><br><span class="line">    location = <span class="regexp">/test &#123;</span></span><br><span class="line"><span class="regexp">        content_by_lua_block &#123;</span></span><br><span class="line"><span class="regexp">            local dogs = ngx.shared.dogs</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">            local len, err = dogs:lpush(&quot;foo&quot;, &quot;bar&quot;)</span></span><br><span class="line"><span class="regexp">            if len then</span></span><br><span class="line"><span class="regexp">                ngx.say(&quot;push success&quot;)</span></span><br><span class="line"><span class="regexp">            else</span></span><br><span class="line"><span class="regexp">                ngx.say(&quot;push err: &quot;, err)</span></span><br><span class="line"><span class="regexp">            end</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">            local val, err = dogs:llen(&quot;foo&quot;)</span></span><br><span class="line"><span class="regexp">            ngx.say(val, &quot; &quot;, err)</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">            local val, err = dogs:lpop(&quot;foo&quot;)</span></span><br><span class="line"><span class="regexp">            ngx.say(val, &quot; &quot;, err)</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">            local val, err = dogs:llen(&quot;foo&quot;)</span></span><br><span class="line"><span class="regexp">            ngx.say(val, &quot; &quot;, err)</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">            local val, err = dogs:lpop(&quot;foo&quot;)</span></span><br><span class="line"><span class="regexp">            ngx.say(val, &quot; &quot;, err)</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">--- request</span></span><br><span class="line"><span class="regexp">GET /</span>test</span><br><span class="line">--- response_body</span><br><span class="line"><span class="keyword">push</span> success</span><br><span class="line"><span class="number">1</span> nil</span><br><span class="line">bar nil</span><br><span class="line"><span class="number">0</span> nil</span><br><span class="line">nil nil</span><br><span class="line">--- no_error_log</span><br><span class="line">[error]</span><br></pre></td></tr></table></figure>

<ul>
<li>管理类</li>
</ul>
<ol>
<li>get_keys(max_count?)，它默认也只返回前 1024 个 key；如果你把 max_count 设置为 0，那就返回所有 key。</li>
<li>capacity 和 free_space，这两个 API 都属于 lua-resty-core 仓库，所以需要你 require 后才能使用：<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span> <span class="string">&quot;resty.core.shdict&quot;</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">local</span> cats = ngx.shared.cats</span><br><span class="line"> <span class="keyword">local</span> capacity_bytes = cats:capacity()</span><br><span class="line"> <span class="keyword">local</span> free_page_bytes = cats:free_space()</span><br></pre></td></tr></table></figure>
它们分别返回的，是共享内存的大小（也就是 lua_shared_dict 中配置的大小）和空闲页的字节数。因为 shared dict 是按照页来分配的，即使 free_space 返回为 0，在已经分配的页面中也可能存在空间，所以它的返回值并不能代表共享内存实际被占用的情况。</li>
</ol>
<h1 id="5-cosocket"><a href="#5-cosocket" class="headerlink" title="5 cosocket"></a>5 cosocket</h1><p>cosocket 是各种 <code>lua-resty-*</code> 非阻塞库的基础，没有 cosocket，开发者就无法用 Lua 来快速连接各种外部的网络服务。</p>
<h2 id="5-1-什么是-cosocket？"><a href="#5-1-什么是-cosocket？" class="headerlink" title="5.1 什么是 cosocket？"></a>5.1 什么是 cosocket？</h2><p>cosocket 是 OpenResty 中的专有名词，是把协程和网络套接字的英文拼在一起形成的，即 cosocket &#x3D; coroutine + socket。所以，你可以把 cosocket 翻译为“协程套接字”。<br>如果我们在 OpenResty 中调用一个 cosocket 相关函数，内部实现便是下面这张图的样子：<br><img src="https://i.loli.net/2020/09/14/3KuNVFmaEhjIlUD.png"><br>遇到网络 I&#x2F;O 时，它会交出控制权（yield），把网络事件注册到 Nginx 监听列表中，并把权限交给 Nginx；当有 Nginx 事件达到触发条件时，便唤醒对应的协程继续处理（resume）。</p>
<p>OpenResty 正是以此为蓝图，封装实现 connect、send、receive 等操作，形成了我们如今见到的 cosocket API。下面，我就以处理 TCP 的 API 为例来介绍一下。处理 UDP 和 Unix Domain Socket ，与 TCP 的接口基本是一样的。</p>
<h2 id="5-2-cosocket-API-和指令简介"><a href="#5-2-cosocket-API-和指令简介" class="headerlink" title="5.2 cosocket API 和指令简介"></a>5.2 cosocket API 和指令简介</h2><p>TCP 相关的 cosocket API 可以分为下面这几类。</p>
<ul>
<li>创建对象：ngx.socket.tcp。</li>
<li>设置超时：tcpsock:settimeout 和 tcpsock:settimeouts。</li>
<li>建立连接：tcpsock:connect。</li>
<li>发送数据：tcpsock:send。</li>
<li>接受数据：tcpsock:receive、tcpsock:receiveany 和 - tcpsock:receiveuntil。</li>
<li>连接池：tcpsock:setkeepalive。</li>
<li>关闭连接：tcpsock:close。</li>
</ul>
<p>这些 API 可以使用的上下文：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*_</span><br></pre></td></tr></table></figure>

<p>与这些 API 相关的，还有 8 个 <code>lua_socket_</code> 开头的 Nginx 指令：</p>
<ul>
<li>lua_socket_connect_timeout：连接超时，默认 60 秒。</li>
<li>lua_socket_send_timeout：发送超时，默认 60 秒。</li>
<li>lua_socket_send_lowat：发送阈值（low water），默认为 0。</li>
<li>lua_socket_read_timeout： 读取超时，默认 60 秒。</li>
<li>lua_socket_buffer_size：读取数据的缓存区大小，默认 4k&#x2F;8k。</li>
<li>lua_socket_pool_size：连接池大小，默认 30。</li>
<li>lua_socket_keepalive_timeout：连接池 cosocket 对象的空闲时间，默认 60 秒。</li>
<li>lua_socket_log_errors：cosocket 发生错误时，是否记录日志，默认为 on。</li>
</ul>
<p>这里你也可以看到，有些指令和 API 的功能一样的，比如设置超时时间和连接池大小等。不过，如果两者有冲突的话，API 的优先级高于指令，会覆盖指令设置的值。</p>
<p><strong>示例：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ resty -e <span class="string">&#x27;local sock = ngx.socket.tcp()</span></span><br><span class="line"><span class="string">        sock:settimeout(1000)  -- one second timeout</span></span><br><span class="line"><span class="string">        local ok, err = sock:connect(&quot;www.baidu.com&quot;, 80)</span></span><br><span class="line"><span class="string">        if not ok then</span></span><br><span class="line"><span class="string">            ngx.say(&quot;failed to connect: &quot;, err)</span></span><br><span class="line"><span class="string">            return</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        local req_data = &quot;GET / HTTP/1.1\r\nHost: www.baidu.com\r\n\r\n&quot;</span></span><br><span class="line"><span class="string">        local bytes, err = sock:send(req_data)</span></span><br><span class="line"><span class="string">        if err then</span></span><br><span class="line"><span class="string">            ngx.say(&quot;failed to send: &quot;, err)</span></span><br><span class="line"><span class="string">            return</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        local data, err, partial = sock:receive()</span></span><br><span class="line"><span class="string">        if err then</span></span><br><span class="line"><span class="string">            ngx.say(&quot;failed to receive: &quot;, err)</span></span><br><span class="line"><span class="string">            return</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        sock:close()</span></span><br><span class="line"><span class="string">        ngx.say(&quot;response is: &quot;, data)&#x27;</span></span><br></pre></td></tr></table></figure>
<p>我们来具体分析下这段代码：</p>
<ul>
<li>首先，通过 ngx.socket.tcp() ，创建 TCP 的 cosocket 对象，名字是 sock。</li>
<li>然后，使用 settimeout() ，把超时时间设置为 1 秒。注意这里的超时没有区分 connect、receive，是统一的设置。</li>
<li>接着，使用 connect() 去连接指定网站的 80 端口，如果失败就直接退出。</li>
<li>连接成功的话，就使用 send() 来发送构造好的数据，如果发送失败就退出。</li>
<li>发送数据成功的话，就使用 receive() 来接收网站返回的数据。这里 receive() 的默认参数值是 <code>*l</code>，也就是只返回第一行的数据；如果参数设置为了<code>*a</code>，就是持续接收数据，直到连接关闭；</li>
<li>最后，调用 close() ，主动关闭 socket 连接。</li>
</ul>
<p>下边做一些调整：</p>
<ol>
<li>对 socket 连接、发送和读取这三个动作，分别设置超时时间。</li>
</ol>
<p>settimeout() ，作用是把超时时间统一设置为一个值。如果要想分开设置，就需要使用 settimeouts() 函数，比如下面这样的写法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sock:settimeouts(<span class="number">1000</span>, <span class="number">2000</span>, <span class="number">3000</span>) </span><br></pre></td></tr></table></figure>
<p>这行代码表示连接超时为 1 秒，发送超时为 2 秒，读取超时为 3 秒。<br>在 OpenResty 和 lua-resty 库中，大部分和时间相关的 API 的参数，都以毫秒为单位，但也有例外，需要你在调用的时候特别注意下。</p>
<ol start="2">
<li>receive 接收指定大小的内容。</li>
</ol>
<p>刚才的 receive() 接口可以接收一行数据，也可以持续接收数据。如果要接收比如10K 大小的数据，使用如下接口：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> data, err, partial = sock:receiveany(<span class="number">10240</span>)</span><br></pre></td></tr></table></figure>

<p>receiveuntil()  可以持续获取数据，直到遇到指定字符串就停止。返回的是一个迭代器：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> reader = sock:receiveuntil(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line"> <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">     <span class="keyword">local</span> data, err, partial = reader(<span class="number">4</span>)</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> data <span class="keyword">then</span></span><br><span class="line">         <span class="keyword">if</span> err <span class="keyword">then</span></span><br><span class="line">             ngx.say(<span class="string">&quot;failed to read the data stream: &quot;</span>, err)</span><br><span class="line">             <span class="keyword">break</span></span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">         ngx.say(<span class="string">&quot;read done&quot;</span>)</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line">     ngx.say(<span class="string">&quot;read chunk: [&quot;</span>, data, <span class="string">&quot;]&quot;</span>)</span><br><span class="line"> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这段代码中的 receiveuntil 会返回 \r\n 之前的数据，并通过迭代器每次读取其中的 4 个字节，也就实现了我们想要的功能。</p>
<ol start="3">
<li>不直接关闭 socket，而是放入连接池中。</li>
</ol>
<p>没有连接池的话，每次请求进来都要新建一个连接，就会导致 cosocket 对象被频繁地创建和销毁，造成不必要的性能损耗。<br>为了避免这个问题，在你使用完一个 cosocket 后，可以调用 setkeepalive() 放到连接池中，比如下面这样的写法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> ok, err = sock:setkeepalive(<span class="number">2</span> * <span class="number">1000</span>, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">    ngx.say(<span class="string">&quot;failed to set reusable: &quot;</span>, err)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这段代码设置了连接的空闲时间为 2 秒，连接池的大小为 100。这样，在调用 connect() 函数时，就会优先从连接池中获取 cosocket 对象。<br>关于连接池的使用，有两点需要注意一下：</p>
<ul>
<li>第一，不能把发生错误的连接放入连接池，否则下次使用时，就会导致收发数据失败。这也是为什么需要判断每一个 API 调用是否成功的一个原因。</li>
<li>第二，要搞清楚连接的数量。连接池是 worker 级别的，每个 worker 都有自己的连接池。所以，如果你有 10 个 worker，连接池大小设置为 30，那么对于后端的服务来讲，就等于有 300 个连接。</li>
</ul>
<h1 id="6-特权任务和定时任务"><a href="#6-特权任务和定时任务" class="headerlink" title="6 特权任务和定时任务"></a>6 特权任务和定时任务</h1><h2 id="6-1-OpenResty-中启动定时任务"><a href="#6-1-OpenResty-中启动定时任务" class="headerlink" title="6.1 OpenResty 中启动定时任务"></a>6.1 OpenResty 中启动定时任务</h2><p>OpenResty 的定时任务可以分为下面两种：</p>
<ol>
<li><code>ngx.timer.at</code> 用来执行一次性的定时任务</li>
<li><code>ngx.time.every</code> 用来执行固定周期的定时任务</li>
</ol>
<p>示例，启动了一个延时为 0 的定时任务。回调handler函数，并在函数中用cosocket访问一个网站：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">init_worker_by_lua_block &#123;</span><br><span class="line">        <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">handler</span><span class="params">()</span></span></span><br><span class="line">            <span class="keyword">local</span> sock = ngx.socket.tcp()</span><br><span class="line">            <span class="keyword">local</span> ok, err = sock:connect(“www.baidu.com<span class="string">&quot;, 80)</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">        local ok, err = ngx.timer.at(0, handler)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br></pre></td></tr></table></figure>
<p>OpenResty中并没有接口可以取消设置的定时任务，所以如果定时任务的数量很多，就很容易耗尽系统资源：<br>OpenResty 提供了 <code>lua_max_pending_timers</code> 和 <code>lua_max_running_timers</code> 这两个指令，来对其进行限制。前者代表等待执行的定时任务的最大值，后者代表当前正在运行的定时任务的最大值。<br>你也可以通过 Lua API，来获取当前等待执行和正在执行的定时任务的值，下面是两个示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">content_by_lua_block &#123;</span><br><span class="line">            ngx.timer.at(<span class="number">3</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">end</span>)</span><br><span class="line">            ngx.say(ngx.timer.pending_count())</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>代码会打印出 1，表示有 1 个计划任务正在等待被执行。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">content_by_lua_block &#123;</span><br><span class="line">            ngx.timer.at(<span class="number">0.1</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> ngx.sleep(<span class="number">0.3</span>) <span class="keyword">end</span>)</span><br><span class="line">            ngx.sleep(<span class="number">0.2</span>)</span><br><span class="line">            ngx.say(ngx.timer.running_count())</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>代码会打印出 1，表示有 1 个计划任务正在运行中。</p>
<h2 id="6-2-特权进程"><a href="#6-2-特权进程" class="headerlink" title="6.2 特权进程"></a>6.2 特权进程</h2><p> OpenResty 在 Nginx 的基础上进行了扩展，增加了特权进程：privileged agent。特权进程很特别：</p>
<ul>
<li>它不监听任何端口，这就意味着不会对外提供任何服务；</li>
<li>它拥有和 master 进程一样的权限，一般来说是 root 用户的权限，这就让它可以做很多 worker 进程不可能完成的任务；</li>
<li>特权进程只能在 <code>init_by_lua</code> 上下文中开启；</li>
<li>另外，特权进程只有运行在 <code>init_worker_by_lua</code> 上下文中才有意义，因为没有请求触发，也就不会走到content、access 等上下文去。</li>
</ul>
<p>下面，我们来看一个开启特权进程的示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">init_by_lua_block &#123;</span><br><span class="line">    <span class="keyword">local</span> process = <span class="built_in">require</span> <span class="string">&quot;ngx.process&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">local</span> ok, err = process.enable_privileged_agent()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">&quot;enables privileged agent failed error:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置以上之后，再启动OpenResty，可以看到Nginx进程中多了特权进行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx: master process</span><br><span class="line">nginx: worker process</span><br><span class="line">nginx: privileged agent process</span><br></pre></td></tr></table></figure>
<p>因为特权只在 <code>init_worker_by_lua</code> 阶段运行一次，所以如果需要定时执行，就需要使用上边的定时器功能，下边使用<code>ngx.timer</code>，周期性地触发：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">init_worker_by_lua_block &#123;</span><br><span class="line">    <span class="keyword">local</span> process = <span class="built_in">require</span> <span class="string">&quot;ngx.process&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">reload</span><span class="params">(premature)</span></span></span><br><span class="line">        <span class="keyword">local</span> f, err = <span class="built_in">io</span>.<span class="built_in">open</span>(ngx.<span class="built_in">config</span>.prefix() .. <span class="string">&quot;/logs/nginx.pid&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> f <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">local</span> pid = f:<span class="built_in">read</span>()</span><br><span class="line">        f:<span class="built_in">close</span>()</span><br><span class="line">        <span class="built_in">os</span>.<span class="built_in">execute</span>(<span class="string">&quot;kill -HUP &quot;</span> .. pid)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> process.<span class="built_in">type</span>() == <span class="string">&quot;privileged agent&quot;</span> <span class="keyword">then</span></span><br><span class="line">         <span class="keyword">local</span> ok, err = ngx.timer.every(<span class="number">5</span>, reload)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">            ngx.<span class="built_in">log</span>(ngx.ERR, err)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码，实现了每 5 秒给 master 进程发送 HUP 信号量的功能。自然，你也可以在此基础上实现更多有趣的功能，比如轮询数据库，看是否有特权进程的任务并执行。因为特权进程是 root 权限，这显然就有点儿“后门”程序的意味了。</p>
<blockquote>
<p>特权进程的使用场景，一般用特权进程来处理的是清理日志、重启 OpenResty 自身等需要高权限的任务。需要注意的是，不要把 worker 进程的任务交给特权进程来处理。这并非因为特权进程不能做到，而是其存在安全隐患。</p>
</blockquote>
<h2 id="6-3-非阻塞的-ngx-pipe"><a href="#6-3-非阻塞的-ngx-pipe" class="headerlink" title="6.3 非阻塞的 ngx.pipe"></a>6.3 非阻塞的 ngx.pipe</h2><p>下边示例，给master发送信号的操作：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">os</span>.<span class="built_in">execute</span>(<span class="string">&quot;kill -HUP &quot;</span> .. pid) </span><br></pre></td></tr></table></figure>
<p>这里使用了Lua的标准库，是阻塞操作，这里可以使用<code>lua-resty-shell</code> 来非阻塞的操作。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ resty -e <span class="string">&#x27;local shell = require &quot;resty.shell&quot;</span></span><br><span class="line"><span class="string">local ok, stdout, stderr, reason, status =</span></span><br><span class="line"><span class="string">    shell.run([[echo &quot;hello, world&quot;]])</span></span><br><span class="line"><span class="string">    ngx.say(stdout)</span></span><br></pre></td></tr></table></figure>
<p>这段代码可以算是 hello world 的另外一种写法了，它调用系统的 echo 命令来完成输出。类似的，可以用 resty.shell ，来替代 Lua 中的 os.execute 调用。<br>lua-resty-shell 的底层实现，依赖了 lua-resty-core 中的 <a target="_blank" rel="noopener" href="https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/pipe.md">ngx.pipe</a> API，所以，这个使用 lua-resty-shell 打印出 hello wrold 的示例，改用 ngx.pipe ，可以写成下面这样：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ resty -e <span class="string">&#x27;local ngx_pipe = require &quot;ngx.pipe&quot;</span></span><br><span class="line"><span class="string">local proc = ngx_pipe.spawn(&#123;&quot;echo&quot;, &quot;hello world&quot;&#125;)</span></span><br><span class="line"><span class="string">local data, err = proc:stdout_read_line()</span></span><br><span class="line"><span class="string">ngx.say(data)&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="7-OpenResy中使用正则、时间等API"><a href="#7-OpenResy中使用正则、时间等API" class="headerlink" title="7 OpenResy中使用正则、时间等API"></a>7 OpenResy中使用正则、时间等API</h1><h2 id="7-1-正则"><a href="#7-1-正则" class="headerlink" title="7.1 正则"></a>7.1 正则</h2><p>在OpenResty中的正则引擎是基于回溯的NFA来实现的，那么就有可能出现灾难性回溯，即正则在匹配的时候回溯过多，造成CPU 100%，正常服务被阻塞。<br>在OpenResty中可以使用如下配置进行规避：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_regex_match_limit <span class="number">100000</span>;</span><br></pre></td></tr></table></figure>
<p><code>lua_regex_match_limit</code> ，就是用来限制 PCRE 正则引擎的回溯次数的。这样，即使出现了灾难性回溯，后果也会被限制在一个范围内，不会导致你的 CPU 满载。</p>
<h2 id="7-2-时间API"><a href="#7-2-时间API" class="headerlink" title="7.2 时间API"></a>7.2 时间API</h2><p><code>ngx.now</code> 返回当前的时间戳，包括小数部分：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resty -e <span class="string">&#x27;ngx.say(ngx.now())&#x27;</span></span><br></pre></td></tr></table></figure>
<p>其他的 <code>ngx.localtime</code>、<code>ngx.utctime</code>、<code>ngx.cookie_time</code> 和 <code>ngx.http_time</code> ，主要是返回和处理时间的不同格式。</p>
<p>需要注意的是，这些返回当前时间的 API，如果没有非阻塞网络 IO 操作来触发，便会一直返回缓存的值，而不是像我们想的那样，能够返回当前的实时时间，下边示例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ resty -e <span class="string">&#x27;ngx.say(ngx.now())</span></span><br><span class="line"><span class="string">os.execute(&quot;sleep 1&quot;)</span></span><br><span class="line"><span class="string">ngx.say(ngx.now())&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在两次调用 <code>ngx.now</code> 之间，我们使用 Lua 的阻塞函数 sleep 了 1 秒钟，但从打印的结果来看，这两次返回的时间戳却是一模一样的。</p>
<p>那么，如果换成是非阻塞的 sleep 函数呢？比如下面这段新的代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ resty -e <span class="string">&#x27;ngx.say(ngx.now())</span></span><br><span class="line"><span class="string">ngx.sleep(1)</span></span><br><span class="line"><span class="string">ngx.say(ngx.now())&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这里出现这种情况的原因是，<code>ngx.now()</code>这个获取当前时间的函数对时间做了缓存。下边是<code>ngx.now()</code> 的源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">ngx_http_lua_ngx_now</span><span class="params">(lua_State *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_time_t</span>              *tp;</span><br><span class="line"> </span><br><span class="line">    tp = ngx_timeofday();</span><br><span class="line"> </span><br><span class="line">    lua_pushnumber(L, (lua_Number) (tp-&gt;sec + tp-&gt;msec / <span class="number">1000.0L</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，ngx.now()这个获取当前时间函数的背后，隐藏的其实是 Nginx 的 ngx_timeofday 函数。而ngx_timeofday 函数，其实是一个宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_timeofday()      (ngx_time_t *) ngx_cached_time</span></span><br></pre></td></tr></table></figure>
<p>这里<code>ngx_cached_time</code> 的值，只在函数 <code>ngx_time_update</code> 中会更新。<br>ngx_time_update什么时候会被调用？如果你在 Nginx 的源码中去跟踪它的话，就会发现， ngx_time_update 的调用都出现在事件循环中。</p>
<h2 id="7-3-真值和空值"><a href="#7-3-真值和空值" class="headerlink" title="7.3 真值和空值"></a>7.3 真值和空值</h2><p>在OpenResty中真值和空值的判断，一直是个比较头痛的点。下边列出不同情况下的空值和真值。<br>首先在Lua中，除了 nil 和 false 之外，都是真值。</p>
<ul>
<li>ngx.null 的布尔值为真</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ resty -e <span class="string">&#x27;if ngx.null then</span></span><br><span class="line"><span class="string">ngx.say(&quot;true&quot;)    ---&gt; true</span></span><br><span class="line"><span class="string">end&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>cdata:NULL<br>当你通过 LuaJIT FFI 接口去调用 C 函数，而这个函数返回一个 NULL 指针，那么你就会遇到另外一种空值，即<code>cdata:NULL</code> 。<br>和ngx.null一样，cdata:NULL 也是真<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ resty -e <span class="string">&#x27;local ffi = require &quot;ffi&quot;</span></span><br><span class="line"><span class="string">local cdata_null = ffi.new(&quot;void*&quot;, nil)</span></span><br><span class="line"><span class="string">if cdata_null then</span></span><br><span class="line"><span class="string">    ngx.say(&quot;true&quot;)    ---&gt; true</span></span><br><span class="line"><span class="string">end&#x27;</span></span><br></pre></td></tr></table></figure>
但是令人想不到的是下边的代码会打印出true，也就是说cdata:NULL 是和 nil 相等的：</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ resty -e <span class="string">&#x27;local ffi = require &quot;ffi&quot;</span></span><br><span class="line"><span class="string">local cdata_null = ffi.new(&quot;void*&quot;, nil)</span></span><br><span class="line"><span class="string">ngx.say(cdata_null == nil)&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>cjson.null 布尔值为真<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ resty -e <span class="string">&#x27;local cjson = require &quot;cjson&quot;</span></span><br><span class="line"><span class="string">local data = cjson.encode(nil)</span></span><br><span class="line"><span class="string">local decode_null = cjson.decode(data)</span></span><br><span class="line"><span class="string">ngx.say(decode_null == cjson.null)&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="8-OpenResty第三方库的阅读技巧"><a href="#8-OpenResty第三方库的阅读技巧" class="headerlink" title="8 OpenResty第三方库的阅读技巧"></a>8 OpenResty第三方库的阅读技巧</h1><p>在OpenResty中没有自带的HTTP client库，下边列出两个比较优秀的：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ledgetech/lua-resty-http">lua-resty-http</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/tokers/lua-resty-requests">lua-resty-requests</a></li>
</ul>
<p>先来看下第三方库的代码结构：<br><img src="https://i.loli.net/2020/09/21/wT81XAtDPKsRMiJ.png"></p>
<p>在首页也有对开源库的接口介绍，可以根据文档进行测试学习。</p>
<h1 id="9-OpenResty-处理四层流量"><a href="#9-OpenResty-处理四层流量" class="headerlink" title="9 OpenResty 处理四层流量"></a>9 OpenResty 处理四层流量</h1><p>OpenResty中处理四层流量是在 stream上下文，OpenResty 其实还提供了 stream-lua-nginx-module 模块来处理四层的流量。它提供的指令和 API ，与 lua-nginx-module 基本一致。<br>下边实现一个服务端缓存session的功能，具体功能点如下：</p>
<ol>
<li>实现set操作，通过key:value方式保存</li>
<li>实现get操作，通过key获取value</li>
<li>支持过期</li>
</ol>
<p>先来设置好 Nginx 的配置文件，因为 stream 和 shared dict 要在其中预设。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    lua_shared_dict memcached 100m;</span><br><span class="line">    lua_package_path &#x27;lib/?.lua;;&#x27;;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 11212;</span><br><span class="line">        content_by_lua_block &#123;</span><br><span class="line">            local m = require(&quot;resty.memcached.server&quot;)</span><br><span class="line">            m.run()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这段配置文件中有几个关键的信息：</p>
<ul>
<li>首先，代码运行在 Nginx 的 stream 上下文中，而非 HTTP 上下文中，并且监听了 11212 端口；</li>
<li>其次，shared dict 的名字为 memcached，大小是 100M，这些在运行期是不可以修改的；</li>
<li>另外，代码所在目录为 lib&#x2F;resty&#x2F;memcached, 文件名为 server.lua, 入口函数为 run()，这些信息你都可以从lua_package_path 和 <code>content_by_lua_block</code> 中找到。</li>
</ul>
<p>下边是完整代码：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> new_tab = <span class="built_in">require</span> <span class="string">&quot;table.new&quot;</span></span><br><span class="line"><span class="keyword">local</span> str_sub = <span class="built_in">string</span>.<span class="built_in">sub</span></span><br><span class="line"><span class="keyword">local</span> re_find = ngx.re.<span class="built_in">find</span></span><br><span class="line"><span class="keyword">local</span> mc_shdict = ngx.shared.memcached</span><br><span class="line"> </span><br><span class="line"><span class="keyword">local</span> _M = &#123; <span class="built_in">_VERSION</span> = <span class="string">&#x27;0.01&#x27;</span> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">parse_args</span><span class="params">(s, start)</span></span></span><br><span class="line">    <span class="keyword">local</span> arr = &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> from, to = re_find(s, <span class="string">[[\S+]]</span>, <span class="string">&quot;jo&quot;</span>, &#123;pos = start&#125;)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> from <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(arr, str_sub(s, from, to))</span><br><span class="line"> </span><br><span class="line">        start = to + <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_M.get</span><span class="params">(tcpsock, keys)</span></span></span><br><span class="line">    <span class="keyword">local</span> reply = <span class="string">&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span>, #keys <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> key = keys[i]</span><br><span class="line">        <span class="keyword">local</span> value, flags = mc_shdict:get(key)</span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> flags  = flags <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">            reply = reply .. <span class="string">&quot;VALUE&quot;</span> .. key .. <span class="string">&quot; &quot;</span> .. flags .. <span class="string">&quot; &quot;</span> .. #value .. <span class="string">&quot;\r\n&quot;</span> .. value .. <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    reply = reply ..  <span class="string">&quot;END\r\n&quot;</span></span><br><span class="line"> </span><br><span class="line">    tcpsock:settimeout(<span class="number">1000</span>)  <span class="comment">-- one second timeout</span></span><br><span class="line">    <span class="keyword">local</span> bytes, err = tcpsock:send(reply)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_M.set</span><span class="params">(tcpsock, res)</span></span></span><br><span class="line">    <span class="keyword">local</span> reply =  <span class="string">&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">local</span> key = res[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">local</span> flags = res[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">local</span> exptime = res[<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">local</span> bytes = res[<span class="number">4</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">local</span> value, err = tcpsock:receive(<span class="built_in">tonumber</span>(bytes) + <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> str_sub(value, <span class="number">-2</span>, <span class="number">-1</span>) == <span class="string">&quot;\r\n&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> succ, err, forcible = mc_shdict:set(key, str_sub(value, <span class="number">1</span>, bytes), exptime, flags)</span><br><span class="line">        <span class="keyword">if</span> succ <span class="keyword">then</span></span><br><span class="line">            reply = reply .. <span class="string">&quot;STORED\r\n&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            reply = reply .. <span class="string">&quot;SERVER_ERROR &quot;</span> .. err .. <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        reply = reply .. <span class="string">&quot;ERROR\r\n&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">    tcpsock:settimeout(<span class="number">1000</span>)  <span class="comment">-- one second timeout</span></span><br><span class="line">    <span class="keyword">local</span> bytes, err = tcpsock:send(reply)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_M.run</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> tcpsock = <span class="built_in">assert</span>(ngx.req.socket(<span class="literal">true</span>))</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        tcpsock:settimeout(<span class="number">60000</span>) <span class="comment">-- 60 seconds</span></span><br><span class="line">        <span class="keyword">local</span> data, err = tcpsock:receive(<span class="string">&quot;*l&quot;</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">local</span> command, args</span><br><span class="line">        <span class="keyword">if</span> data <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> from, to, err = re_find(data, <span class="string">[[(\S+)]]</span>, <span class="string">&quot;jo&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> from <span class="keyword">then</span></span><br><span class="line">                command = str_sub(data, from, to)</span><br><span class="line">                args = parse_args(data, to + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> args <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> args_len = #args</span><br><span class="line">            <span class="keyword">if</span> command == <span class="string">&#x27;get&#x27;</span> <span class="keyword">and</span> args_len &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                _M.get(tcpsock, args)</span><br><span class="line">            <span class="keyword">elseif</span> command == <span class="string">&quot;set&quot;</span> <span class="keyword">and</span> args_len == <span class="number">4</span> <span class="keyword">then</span></span><br><span class="line">                _M.set(tcpsock, args)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure>
<h2 id="9-1-测试框架"><a href="#9-1-测试框架" class="headerlink" title="9.1 测试框架"></a>9.1 测试框架</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ resty -e <span class="string">&#x27;local memcached = require &quot;resty.memcached&quot;</span></span><br><span class="line"><span class="string">    local memc, err = memcached:new()</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    memc:set_timeout(1000) -- 1 sec</span></span><br><span class="line"><span class="string">    local ok, err = memc:connect(&quot;127.0.0.1&quot;, 11212)</span></span><br><span class="line"><span class="string">    local ok, err = memc:set(&quot;dog&quot;, 32)</span></span><br><span class="line"><span class="string">    if not ok then</span></span><br><span class="line"><span class="string">        ngx.say(&quot;failed to set dog: &quot;, err)</span></span><br><span class="line"><span class="string">        return</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    local res, flags, err = memc:get(&quot;dog&quot;)</span></span><br><span class="line"><span class="string">    ngx.say(&quot;dog: &quot;, res)&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这段测试代码，使用 lua-rety-memcached 客户端库发起 connect 和 set 操作，并假设 memcached 的服务端监听本机的 11212 端口。</p>
<h2 id="9-2-使用test-nginx测试框架"><a href="#9-2-使用test-nginx测试框架" class="headerlink" title="9.2 使用test::nginx测试框架"></a>9.2 使用test::nginx测试框架</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> Test::Nginx::Socket::Lua::Stream;</span><br><span class="line"><span class="keyword">use</span> Test::Nginx::Socket <span class="string">&#x27;no_plan&#x27;</span>;</span><br><span class="line"></span><br><span class="line">run_tests();</span><br><span class="line"> </span><br><span class="line"><span class="language-mojolicious"><span class="meta">__DATA__</span><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">  </span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">=== TEST 1: basic get and set</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">--- config</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">        location /test &#123;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">            content_by_lua_block &#123;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">                local memcached = require &quot;resty.memcached&quot;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">                local memc, err = memcached:new()</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">                if not memc then</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">                    ngx.say(&quot;failed to instantiate memc: &quot;, err)</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">                    return</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">                end</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious"> </span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">                memc:set_timeout(1000) -- 1 sec</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">                local ok, err = memc:connect(&quot;127.0.0.1&quot;, 11212)</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious"> </span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">                local ok, err = memc:set(&quot;dog&quot;, 32)</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">                if not ok then</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">                    ngx.say(&quot;failed to set dog: &quot;, err)</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">                    return</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">                end</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious"> </span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">                local res, flags, err = memc:get(&quot;dog&quot;)</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">                ngx.say(&quot;dog: &quot;, res)</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">            &#125;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">        &#125;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious"> </span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">--- stream_config</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">    lua_shared_dict memcached 100m;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">       lua_package_path &#x27;/home/workspace/geektime/lualib/lib/?.lua;;&#x27;;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious"> </span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">--- stream_server_config</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">    listen 11212;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">    </span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">    content_by_lua_block &#123;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">        local m = require(&quot;resty.memcached.server&quot;)</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">        m.run()</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">    &#125;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious"> </span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">--- request</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">GET /test</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">--- response_body</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">dog: nil</span></span></span><br><span class="line"><span class="language-xml"><span class="language-mojolicious">--- error_code: 200</span></span></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://baihlup.github.io">梦之痕</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://baihlup.github.io/2023/11/21/260%20-%20%E5%90%8E%E7%AB%AF&amp;%E6%9E%B6%E6%9E%84/263%20-%20%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/02%20-%20OpenResty%20API%E7%AF%87/">https://baihlup.github.io/2023/11/21/260%20-%20%E5%90%8E%E7%AB%AF&amp;%E6%9E%B6%E6%9E%84/263%20-%20%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/02%20-%20OpenResty%20API%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OpenResty/">OpenResty</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/21/260%20-%20%E5%90%8E%E7%AB%AF&amp;%E6%9E%B6%E6%9E%84/263%20-%20%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/01%20-%20OpenResty%20%E5%9F%BA%E7%A1%80%E7%AF%87/" title="OpenResty 基础篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">OpenResty 基础篇</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/21/260%20-%20%E5%90%8E%E7%AB%AF&amp;%E6%9E%B6%E6%9E%84/263%20-%20%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/04%20-%20OpenResty%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="OpenResty 性能优化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">OpenResty 性能优化</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/11/21/260%20-%20%E5%90%8E%E7%AB%AF&%E6%9E%B6%E6%9E%84/263%20-%20%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/01%20-%20OpenResty%20%E5%9F%BA%E7%A1%80%E7%AF%87/" title="OpenResty 基础篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-21</div><div class="title">OpenResty 基础篇</div></div></a></div><div><a href="/2023/11/21/260%20-%20%E5%90%8E%E7%AB%AF&%E6%9E%B6%E6%9E%84/263%20-%20%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/04%20-%20OpenResty%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="OpenResty 性能优化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-21</div><div class="title">OpenResty 性能优化</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/BaihlUp/Figurebed/master/2024/41710043961_.pic.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">梦之痕</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">61</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/BaihlUp"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">个人笔记迁移中ing....</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2-OpenResty%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0"><span class="toc-number">1.</span> <span class="toc-text">2 OpenResty开发平台</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E5%8D%8F%E7%A8%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8"><span class="toc-number">1.0.1.</span> <span class="toc-text">2.1.1 协程和事件驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-OpenResty-%E7%9A%84%E9%98%B6%E6%AE%B5"><span class="toc-number">1.0.2.</span> <span class="toc-text">2.1.2 OpenResty 的阶段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%96%87%E6%A1%A3%E5%92%8C%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8B"><span class="toc-number">1.1.</span> <span class="toc-text">2.2 文档和测试案例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-OpenResty-%E5%A4%84%E7%90%86%E7%BB%88%E7%AB%AF%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94"><span class="toc-number">2.</span> <span class="toc-text">3 OpenResty 处理终端请求和响应</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-API-%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">3.1 API 分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">3.2 请求处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E8%AF%B7%E6%B1%82%E8%A1%8C"><span class="toc-number">2.2.1.</span> <span class="toc-text">3.2.1 请求行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-number">2.2.2.</span> <span class="toc-text">3.2.2 请求头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E8%AF%B7%E6%B1%82%E4%BD%93"><span class="toc-number">2.2.3.</span> <span class="toc-text">3.2.3 请求体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%A4%84%E7%90%86%E5%93%8D%E5%BA%94"><span class="toc-number">2.3.</span> <span class="toc-text">3.3 处理响应</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.3.1 响应状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.3.2 响应头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E5%93%8D%E5%BA%94%E4%BD%93"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.3.3 响应体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%B8%B8%E9%87%8F"><span class="toc-number">2.4.</span> <span class="toc-text">3.4 常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">2.4.1.</span> <span class="toc-text">3.4.1 状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.2.</span> <span class="toc-text">3.4.2 请求方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-OpenResty-%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">4 OpenResty 中数据共享的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Nginx-%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">3.1.</span> <span class="toc-text">4.1 Nginx 中的变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-ngx-ctx"><span class="toc-number">3.2.</span> <span class="toc-text">4.2 ngx.ctx</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%A8%A1%E5%9D%97%E7%BA%A7%E5%88%AB%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">3.3.</span> <span class="toc-text">4.3 模块级别的变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-shared-dict"><span class="toc-number">3.4.</span> <span class="toc-text">4.4 shared dict</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-cosocket"><span class="toc-number">4.</span> <span class="toc-text">5 cosocket</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E4%BB%80%E4%B9%88%E6%98%AF-cosocket%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">5.1 什么是 cosocket？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-cosocket-API-%E5%92%8C%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B"><span class="toc-number">4.2.</span> <span class="toc-text">5.2 cosocket API 和指令简介</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E7%89%B9%E6%9D%83%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.</span> <span class="toc-text">6 特权任务和定时任务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-OpenResty-%E4%B8%AD%E5%90%AF%E5%8A%A8%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.1.</span> <span class="toc-text">6.1 OpenResty 中启动定时任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E7%89%B9%E6%9D%83%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">6.2 特权进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84-ngx-pipe"><span class="toc-number">5.3.</span> <span class="toc-text">6.3 非阻塞的 ngx.pipe</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-OpenResy%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E3%80%81%E6%97%B6%E9%97%B4%E7%AD%89API"><span class="toc-number">6.</span> <span class="toc-text">7 OpenResy中使用正则、时间等API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%AD%A3%E5%88%99"><span class="toc-number">6.1.</span> <span class="toc-text">7.1 正则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%97%B6%E9%97%B4API"><span class="toc-number">6.2.</span> <span class="toc-text">7.2 时间API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E7%9C%9F%E5%80%BC%E5%92%8C%E7%A9%BA%E5%80%BC"><span class="toc-number">6.3.</span> <span class="toc-text">7.3 真值和空值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-OpenResty%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E9%98%85%E8%AF%BB%E6%8A%80%E5%B7%A7"><span class="toc-number">7.</span> <span class="toc-text">8 OpenResty第三方库的阅读技巧</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-OpenResty-%E5%A4%84%E7%90%86%E5%9B%9B%E5%B1%82%E6%B5%81%E9%87%8F"><span class="toc-number">8.</span> <span class="toc-text">9 OpenResty 处理四层流量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6"><span class="toc-number">8.1.</span> <span class="toc-text">9.1 测试框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E4%BD%BF%E7%94%A8test-nginx%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6"><span class="toc-number">8.2.</span> <span class="toc-text">9.2 使用test::nginx测试框架</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/22/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/279%20-%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/05%20-%20%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%94%A8%E5%8F%8C%E5%8D%81%E4%B8%80%E7%9A%84%E6%95%85%E4%BA%8B%E4%B8%B2%E8%B5%B7%E7%A2%8E%E7%89%87%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8A%EF%BC%89/" title="Untitled">Untitled</a><time datetime="2024-09-22T07:46:10.172Z" title="Created 2024-09-22 07:46:10">2024-09-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/22/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/279%20-%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/06%20-%20%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%94%A8%E5%8F%8C%E5%8D%81%E4%B8%80%E7%9A%84%E6%95%85%E4%BA%8B%E4%B8%B2%E8%B5%B7%E7%A2%8E%E7%89%87%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%AD%EF%BC%89/" title="Untitled">Untitled</a><time datetime="2024-09-22T07:46:10.172Z" title="Created 2024-09-22 07:46:10">2024-09-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/22/270%20-%20%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/279%20-%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/07%20-%20%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E4%B8%B2%E8%AE%B2%EF%BC%9A%E7%94%A8%E5%8F%8C%E5%8D%81%E4%B8%80%E7%9A%84%E6%95%85%E4%BA%8B%E4%B8%B2%E8%B5%B7%E7%A2%8E%E7%89%87%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8B%EF%BC%89/" title="Untitled">Untitled</a><time datetime="2024-09-22T07:46:10.172Z" title="Created 2024-09-22 07:46:10">2024-09-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/22/260%20-%20%E5%90%8E%E7%AB%AF&amp;%E6%9E%B6%E6%9E%84/261%20-%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02%20-%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/" title="Untitled">Untitled</a><time datetime="2024-09-22T07:46:10.170Z" title="Created 2024-09-22 07:46:10">2024-09-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/22/000%20-%20Inbox/%E7%81%AB%E5%B1%B1%E4%BA%91waf/" title="Untitled">Untitled</a><time datetime="2024-09-22T07:46:10.129Z" title="Created 2024-09-22 07:46:10">2024-09-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 梦之痕</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>